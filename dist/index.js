/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./entry/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./components/context/context.component.ts":
/*!*************************************************!*\
  !*** ./components/context/context.component.ts ***!
  \*************************************************/
/*! exports provided: ContextComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ContextComponent", function() { return ContextComponent; });
/* harmony import */ var _hypertype_ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hypertype/ui */ "./node_modules/@hypertype/ui/dist/index.js");
/* harmony import */ var _hypertype_ui__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_hypertype_ui__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _model_root__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../model/root */ "./model/root.ts");
/* harmony import */ var _store_selection_store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../store/selection.store */ "./store/selection.store.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




let ContextComponent = class ContextComponent extends _hypertype_ui__WEBPACK_IMPORTED_MODULE_0__["HyperComponent"] {
    constructor(selectionStore, root) {
        super();
        this.selectionStore = selectionStore;
        this.root = root;
        this.contextInitial$ = this.path$.pipe(Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["switchMap"])(ids => this.root.GetContext$(ids)), Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["filter"])(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["Fn"].Ib), Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["first"])());
        this.context$ = this.root.State$.pipe(Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["withLatestFrom"])(this.contextInitial$), Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["map"])(([, context]) => context), Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["distinctUntilChanged"])(null, context => `${context.toString()}.${context.Children.map(c => c.Key).join('.')}`), 
        // tap(context => console.log(`${context.toString()}.${context.Children.map(c => c.Key).join('.')}`)),
        Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["shareReplay"])(1));
        this.IsSelected$ = Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["combineLatest"])([
            this.selectionStore.asObservable(),
            this.contextInitial$,
        ]).pipe(Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["map"])(([state, context]) => {
            if (!state || !context)
                return false;
            return state.Key == context.Key;
        }), Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["distinctUntilChanged"])(), Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["shareReplay"])(1));
        this.State$ = Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["combineLatest"])([
            this.context$,
            this.IsSelected$,
        ]).pipe(Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["map"])(([context, isSelected]) => ({
            context, isSelected,
            state: [
                isSelected ? 'selected' : '',
                (context.Children.length == 0) ? 'empty' : '',
                (context.Collapsed) ? 'collapsed' : ''
            ],
        })), Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["filter"])(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["Fn"].Ib));
        this.Editor$ = Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["combineLatest"])([this.Element$, this.context$]).pipe(Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["first"])(), Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["map"])(([element, context]) => element.querySelector(`#editor${context.Key}`)));
        this.Actions$ = Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["merge"])(Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["combineLatest"])([this.IsSelected$, this.Editor$]).pipe(Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["tap"])(([isSelected, editor]) => {
            if (isSelected && document.activeElement != editor) {
                console.log('focus', this.path, isSelected);
                editor.focus();
            }
        })), this.Events$.pipe(Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["filter"])(e => e.type == 'focus'), Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["tap"])(({ args }) => __awaiter(this, void 0, void 0, function* () {
            this.selectionStore.Actions.Path(this.path);
        })))).pipe(Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["mapTo"])(null));
    }
};
__decorate([
    Object(_hypertype_ui__WEBPACK_IMPORTED_MODULE_0__["property"])(),
    __metadata("design:type", _hypertype_core__WEBPACK_IMPORTED_MODULE_1__["Observable"])
], ContextComponent.prototype, "path$", void 0);
ContextComponent = __decorate([
    Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])(true),
    Object(_hypertype_ui__WEBPACK_IMPORTED_MODULE_0__["Component"])({
        name: 'app-context',
        template: (html, state, events) => {
            if (!state.context)
                return html ``;
            const context = state.context;
            const isEmpty = state.state.includes('empty');
            const isCollapsed = state.state.includes('collapsed');
            console.log('render', context.Key, ...context.Children.map(c => c.Key));
            return html `
            <div class="${`context-inner ${state.state.join(' ')}`}">
                <div class="body">
                    <span class="arrow"></span>
                    <span id=${`editor${context.Key}`} 
                          onclick="${events.focus(e => e)}" 
                          contenteditable="true">
                        ${context.toString()}
                    </span>
                </div>
                <div class="children">
                ${isCollapsed ? '' : context.Children.map(child => Object(_hypertype_ui__WEBPACK_IMPORTED_MODULE_0__["wire"])(_hypertype_ui__WEBPACK_IMPORTED_MODULE_0__["wire"], `context${child.Key}`) `
                        <app-context path="${child.Path}"></app-context>
                    `)}
                </div>
            </div>
        `;
        },
        style: __webpack_require__(/*! ./context.style.less */ "./components/context/context.style.less")
    }),
    __metadata("design:paramtypes", [_store_selection_store__WEBPACK_IMPORTED_MODULE_3__["SelectionStore"],
        _model_root__WEBPACK_IMPORTED_MODULE_2__["Root"]])
], ContextComponent);



/***/ }),

/***/ "./components/context/context.style.less":
/*!***********************************************!*\
  !*** ./components/context/context.style.less ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js")(false);
// Module
exports.push([module.i, "app-context {\n  display: block;\n  padding: 10px 0;\n}\napp-context .body {\n  box-sizing: border-box;\n  height: 2em;\n}\napp-context .arrow {\n  display: inline-block;\n  width: 1em;\n  text-align: center;\n}\napp-context .context-inner:not(.empty) .arrow:before {\n  content: 'v';\n}\napp-context .context-inner:not(.empty).collapsed .arrow:before {\n  content: '>';\n}\napp-context .context-inner.empty .arrow:before {\n  content: ' ';\n}\napp-context .children {\n  margin-left: 0.5em;\n  margin-top: 0px;\n  padding: 0.5em 0 0 20px;\n  border-left: 0.01em solid #666;\n}\napp-context .empty .children {\n  display: none;\n}\napp-context [contenteditable]:focus {\n  border: none;\n  outline: none;\n}\n", ""]);


/***/ }),

/***/ "./components/google-login.component.ts":
/*!**********************************************!*\
  !*** ./components/google-login.component.ts ***!
  \**********************************************/
/*! exports provided: GoogleLoginComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GoogleLoginComponent", function() { return GoogleLoginComponent; });
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_hypertype_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _hypertype_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @hypertype/ui */ "./node_modules/@hypertype/ui/dist/index.js");
/* harmony import */ var _hypertype_ui__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_hypertype_ui__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _entry_google_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../entry/google-api */ "./entry/google-api.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



let GoogleLoginComponent = class GoogleLoginComponent extends _hypertype_ui__WEBPACK_IMPORTED_MODULE_1__["HyperComponent"] {
    constructor(auth) {
        super();
        this.auth = auth;
        this.State$ = this.auth.isSignedIn$.pipe(Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_0__["switchMap"])(isLoggedIn => isLoggedIn ?
            this.auth.getMessages() :
            Promise.resolve(null)));
        this.Events = {
            login: () => {
                this.auth.Login();
            },
            logout: () => {
                this.auth.Logout();
            }
        };
    }
};
GoogleLoginComponent = __decorate([
    Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"])(true),
    Object(_hypertype_ui__WEBPACK_IMPORTED_MODULE_1__["Component"])({
        name: 'google-login',
        style: ``,
        template: (html, user, events) => html `
        ${user && user.displayName || JSON.stringify(user)}
        <button onclick="${user ? events.logout(e => e) : events.login(e => e)}">
            ${user ? 'logout' : 'login'}
        </button>
    `
    }),
    __metadata("design:paramtypes", [_entry_google_api__WEBPACK_IMPORTED_MODULE_2__["GoogleApiAuth"]])
], GoogleLoginComponent);



/***/ }),

/***/ "./components/root/root.component.ts":
/*!*******************************************!*\
  !*** ./components/root/root.component.ts ***!
  \*******************************************/
/*! exports provided: RootComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RootComponent", function() { return RootComponent; });
/* harmony import */ var _hypertype_ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hypertype/ui */ "./node_modules/@hypertype/ui/dist/index.js");
/* harmony import */ var _hypertype_ui__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_hypertype_ui__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _model_root__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../model/root */ "./model/root.ts");
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_hypertype_core__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _store_selection_store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../store/selection.store */ "./store/selection.store.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




let RootComponent = class RootComponent extends _hypertype_ui__WEBPACK_IMPORTED_MODULE_0__["HyperComponent"] {
    constructor(root, selectionStore) {
        super();
        this.root = root;
        this.selectionStore = selectionStore;
        this.State$ = this.root.State$;
        this.Actions$ = Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_2__["merge"])(Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_2__["fromEvent"])(document, 'keydown').pipe(Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_2__["tap"])((event) => {
            switch (event.key) {
                case 'ArrowUp':
                    event.preventDefault();
                    if (event.ctrlKey)
                        this.selectionStore.Actions.MoveUp();
                    else
                        this.selectionStore.Actions.Prev();
                    break;
                case 'ArrowDown':
                    event.preventDefault();
                    if (event.ctrlKey)
                        this.selectionStore.Actions.MoveDown();
                    else
                        this.selectionStore.Actions.Next();
                    break;
                case 'Tab':
                    event.preventDefault();
                    event.shiftKey ?
                        this.selectionStore.Actions.MoveLeft() :
                        this.selectionStore.Actions.MoveRight();
                    break;
            }
        })), Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_2__["fromEvent"])(document, 'keyup').pipe(Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_2__["tap"])(() => {
        })));
    }
};
RootComponent = __decorate([
    Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_2__["Injectable"])(true),
    Object(_hypertype_ui__WEBPACK_IMPORTED_MODULE_0__["Component"])({
        name: 'app-root',
        template: (html, root) => html `
        <app-context path="${root.MainContext.Path}"></app-context>
    `,
        style: __webpack_require__(/*! ./root.style.less */ "./components/root/root.style.less")
    }),
    __metadata("design:paramtypes", [_model_root__WEBPACK_IMPORTED_MODULE_1__["Root"],
        _store_selection_store__WEBPACK_IMPORTED_MODULE_3__["SelectionStore"]])
], RootComponent);



/***/ }),

/***/ "./components/root/root.style.less":
/*!*****************************************!*\
  !*** ./components/root/root.style.less ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js")(false);
// Module
exports.push([module.i, "app-root {\n  position: fixed;\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n  color: #DDD;\n  background: #444;\n  font-family: \"RootUI\", \"Ubuntu Light\";\n}\n@font-face {\n  font-family: 'RootUI';\n  src: url(\"data:font/woff;base64,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\") format('woff');\n}\n", ""]);


/***/ }),

/***/ "./entry/google-api.ts":
/*!*****************************!*\
  !*** ./entry/google-api.ts ***!
  \*****************************/
/*! exports provided: GoogleApiAuth, GoogleApi */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GoogleApiAuth", function() { return GoogleApiAuth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GoogleApi", function() { return GoogleApi; });
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_hypertype_core__WEBPACK_IMPORTED_MODULE_0__);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

function promisify() {
}
class GoogleApiAuth {
    constructor() {
        this.authInstance = gapi['auth2'].getAuthInstance();
        this.isSignedIn$ = new _hypertype_core__WEBPACK_IMPORTED_MODULE_0__["Observable"](subscr => {
            this.authInstance.isSignedIn
                .listen((isLoggedIn) => {
                subscr.next(isLoggedIn);
            });
        }).pipe(Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_0__["startWith"])(this.authInstance.isSignedIn.get()));
    }
    getUser() {
        return __awaiter(this, void 0, void 0, function* () {
            const { result } = yield gapi.client.request({
                'path': 'https://people.googleapis.com/v1/people/me?requestMask.includeField=person.names',
            });
            return Object.assign(Object.assign({}, result.names[0]), { metadata: undefined });
        });
    }
    getMessages() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { result } = yield gapi.client.request({
                    'path': 'https://www.googleapis.com/gmail/v1/users/me/threads',
                });
                return result.threads.map(m => m.snippet);
            }
            catch (e) {
                console.log(e);
                return null;
            }
        });
    }
    Login() {
        return __awaiter(this, void 0, void 0, function* () {
            this.authInstance.signIn({
                scope: 'https://www.googleapis.com/auth/gmail.modify'
            });
        });
    }
    Logout() {
        this.authInstance.signOut();
    }
}
class GoogleApi {
    static Load() {
        return __awaiter(this, void 0, void 0, function* () {
            yield new Promise((resolve, reject) => {
                gapi.load('client:auth2', resolve);
            });
            yield gapi.client.init({
                'apiKey': 'AIzaSyBXHHiYMNV6j3Ynv5oRgvcZ-fA4sT2xT14',
                // Your API key will be automatically added to the Discovery Document URLs.
                'discoveryDocs': ['https://people.googleapis.com/$discovery/rest'],
                // clientId and scope are optional if auth is not required.
                'clientId': '851972563081-vta7ptgrctccu0f7543volp9k6kam27b.apps.googleusercontent.com',
                'scope': 'profile',
            });
            return new GoogleApiAuth();
        });
    }
}


/***/ }),

/***/ "./entry/index.ts":
/*!************************!*\
  !*** ./entry/index.ts ***!
  \************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hypertype_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hypertype/app */ "./node_modules/@hypertype/app/dist/esm/index.js");
/* harmony import */ var _hypertype_app__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_hypertype_app__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _components_google_login_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/google-login.component */ "./components/google-login.component.ts");
/* harmony import */ var _components_root_root_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/root/root.component */ "./components/root/root.component.ts");
/* harmony import */ var _components_context_context_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/context/context.component */ "./components/context/context.component.ts");
/* harmony import */ var _store_RootStore__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../store/RootStore */ "./store/RootStore.ts");
/* harmony import */ var _hypertype_infr__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @hypertype/infr */ "./node_modules/@hypertype/infr/dist/esm/common/index.js");
/* harmony import */ var _hypertype_infr_browser__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @hypertype/infr-browser */ "./node_modules/@hypertype/infr-browser/dist/esm/index.js");
/* harmony import */ var _hypertype_infr_browser__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_hypertype_infr_browser__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _model_container__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../model/container */ "./model/container.ts");
/* harmony import */ var _store_selection_store__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../store/selection.store */ "./store/selection.store.ts");










const app = _hypertype_app__WEBPACK_IMPORTED_MODULE_0__["ApplicationBuilder"]
    .withInfrustructure(_model_container__WEBPACK_IMPORTED_MODULE_8__["ContextDomainContainer"])
    .withInfrustructure(_hypertype_infr__WEBPACK_IMPORTED_MODULE_6__["InfrContainer"])
    .withInfrustructure(_hypertype_infr_browser__WEBPACK_IMPORTED_MODULE_7__["BrowserContainer"])
    .withUI(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["Container"].withProviders(_components_google_login_component__WEBPACK_IMPORTED_MODULE_2__["GoogleLoginComponent"], _components_root_root_component__WEBPACK_IMPORTED_MODULE_3__["RootComponent"], _components_context_context_component__WEBPACK_IMPORTED_MODULE_4__["ContextComponent"], _store_RootStore__WEBPACK_IMPORTED_MODULE_5__["RootStore"], _store_selection_store__WEBPACK_IMPORTED_MODULE_9__["SelectionStore"]))
    .build();
// GoogleApi.Load().then((auth)=>{
//     app.Provide({
//         provide: GoogleApiAuth,
//         useValue: auth
//     });
app.Init();
app.get(_hypertype_app__WEBPACK_IMPORTED_MODULE_0__["RootStore"]).createStore();
// });
// 1. Load the JavaScript client library.


/***/ }),

/***/ "./model/base/id.ts":
/*!**************************!*\
  !*** ./model/base/id.ts ***!
  \**************************/
/*! exports provided: Id */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Id", function() { return Id; });
let counter = 0;
function Id() {
    return (counter++).toString();
}


/***/ }),

/***/ "./model/base/tree.ts":
/*!****************************!*\
  !*** ./model/base/tree.ts ***!
  \****************************/
/*! exports provided: GeneralTree, treeMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeneralTree", function() { return GeneralTree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "treeMap", function() { return treeMap; });
class GeneralTree {
    get this() {
        return this;
    }
    flatMap(fn) {
        return [
            fn(this.this),
            ...this.Children.map(c => c.flatMap(fn)).flat()
        ];
    }
    map(fn) {
        const mapItem = item => {
            const result = fn(item);
            result.Children = item.Children
                .map(mapItem);
            return result;
        };
        return mapItem(this);
    }
    forEach(fn) {
        const forEachItem = item => {
            fn(item);
            item.Children.forEach(forEachItem);
        };
        forEachItem(this);
    }
    get(ids) {
        const [id, ...rest] = ids;
        const child = this.Children.find(c => c.Id == id);
        if (!child)
            return null;
        if (!rest.length)
            return child.this;
        return child.get(rest);
    }
    MoveLeft() {
        if (!this.Parent || !this.Parent.Parent)
            return;
        const index = this.Parent.Parent.Children.indexOf(this.Parent);
        const grandParent = this.Parent.Parent;
        this.Parent.Children.remove(this.this);
        grandParent.Children.splice(index + 1, 0, this.this);
        this.Parent = grandParent;
    }
    MoveRight() {
        if (!this.Parent || !this.PrevSibling)
            return;
        const prevSibling = this.PrevSibling;
        this.Parent.Children.remove(this.this);
        prevSibling.Children.push(this.this);
        this.Parent = prevSibling;
    }
    MoveUp() {
        if (!this.Parent || !this.PrevSibling)
            return;
        const index = this.Parent.Children.indexOf(this.this);
        this.Parent.Children.splice(index - 1, 2, this.this, this.Parent.Children[index - 1]);
    }
    MoveDown() {
        if (!this.Parent)
            return;
        if (this.NextSibling) {
            const index = this.Parent.Children.indexOf(this.this);
            this.Parent.Children.splice(index, 2, this.Parent.Children[index + 1], this.this);
        }
        else {
            this.MoveLeft();
        }
    }
    get PrevSibling() {
        return this.Parent && this.Parent.Children[this.Parent.Children.indexOf(this.this) - 1];
    }
    get NextSibling() {
        return this.Parent && this.Parent.Children[this.Parent.Children.indexOf(this.this) + 1];
    }
    get Prev() {
        return this.PrevSibling || this.Parent;
    }
    get Next() {
        return this.Children[0] || this.NextSibling || (this.Parent && this.Parent.NextSibling);
    }
}
function treeMap(root, children) {
    return {
        map: (fn) => {
            const mapItem = item => {
                const result = fn(item);
                result.Children = children(item)
                    .map(mapItem);
                result.Children.forEach(child => child.Parent = result);
                return result;
            };
            return mapItem(root);
        },
        forEach: (fn) => {
            const forEachItem = item => {
                fn(item);
                children(item)
                    .forEach(forEachItem);
            };
            forEachItem(root);
        }
    };
}


/***/ }),

/***/ "./model/container.ts":
/*!****************************!*\
  !*** ./model/container.ts ***!
  \****************************/
/*! exports provided: ContextDomainContainer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ContextDomainContainer", function() { return ContextDomainContainer; });
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_hypertype_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _hypertype_domain__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @hypertype/domain */ "./node_modules/@hypertype/domain/dist/esm/index.js");
/* harmony import */ var _hypertype_domain__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_hypertype_domain__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./root */ "./model/root.ts");



const root = new _root__WEBPACK_IMPORTED_MODULE_2__["Root"]();
const ContextDomainContainer = _hypertype_core__WEBPACK_IMPORTED_MODULE_0__["Container"].withProviders({ provide: _hypertype_domain__WEBPACK_IMPORTED_MODULE_1__["Model"], useValue: root }, { provide: _root__WEBPACK_IMPORTED_MODULE_2__["Root"], useValue: root }, _hypertype_domain__WEBPACK_IMPORTED_MODULE_1__["ProxyDomainContainer"]);


/***/ }),

/***/ "./model/context.ts":
/*!**************************!*\
  !*** ./model/context.ts ***!
  \**************************/
/*! exports provided: Context */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Context", function() { return Context; });
/* harmony import */ var _base_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base/tree */ "./model/base/tree.ts");
/* harmony import */ var _base_id__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base/id */ "./model/base/id.ts");


class Context extends _base_tree__WEBPACK_IMPORTED_MODULE_0__["GeneralTree"] {
    constructor(root, dbo) {
        super();
        this.root = root;
        this.Children = [];
        this.Users = new Map();
        this.Collapsed = false;
        this.Key = Object(_base_id__WEBPACK_IMPORTED_MODULE_1__["Id"])();
        this.Actions = {
            Move: {
                Left: () => {
                    this.MoveLeft();
                    this.root.Update.next();
                },
                Right: () => {
                    this.MoveRight();
                    this.root.Update.next();
                },
                Down: () => {
                    this.MoveDown();
                    this.root.Update.next();
                },
                Up: () => {
                    this.MoveUp();
                    this.root.Update.next();
                }
            }
        };
        this.Data = dbo;
    }
    GetDbo() {
        return [
            this.Data,
            ...this.Children.map(child => child.GetDbo())
        ].distinct(dbo => dbo.Id);
    }
    toString() {
        return this.Data.Content.map(t => t['Text']).join(' ');
    }
    get Id() {
        return this.Data.Id;
    }
    get Path() {
        if (!this.Parent)
            return [this.Id];
        return [...this.Parent.Path, this.Id];
    }
}


/***/ }),

/***/ "./model/dbo/context.dbo.ts":
/*!**********************************!*\
  !*** ./model/dbo/context.dbo.ts ***!
  \**********************************/
/*! exports provided: RelationType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RelationType", function() { return RelationType; });
var RelationType;
(function (RelationType) {
    RelationType["View"] = "view";
    RelationType["Notify"] = "notify";
    RelationType["Write"] = "write";
    RelationType["Responsibility"] = "responsibility";
    RelationType["Owner"] = "owner";
})(RelationType || (RelationType = {}));


/***/ }),

/***/ "./model/dbo/default.ts":
/*!******************************!*\
  !*** ./model/dbo/default.ts ***!
  \******************************/
/*! exports provided: DefaultData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultData", function() { return DefaultData; });
/* harmony import */ var _context_dbo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./context.dbo */ "./model/dbo/context.dbo.ts");
/* harmony import */ var _base_id__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/id */ "./model/base/id.ts");
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_hypertype_core__WEBPACK_IMPORTED_MODULE_2__);



const InititalData = () => ({
    Contexts: [
        {
            Id: Object(_base_id__WEBPACK_IMPORTED_MODULE_1__["Id"])(),
            ParentIds: [],
            Time: Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_2__["utc"])().toISO(),
            Content: [{
                    Text: '...',
                }]
        }
    ],
    Users: [],
    Relations: [],
    UserState: {
        ContextsState: {}
    }
});
const DefaultDataTest1 = () => ({
    Contexts: [
        {
            Id: '1',
            ParentIds: [],
            Time: Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_2__["utc"])().toISO(),
            Content: [{
                    Text: '1 ',
                }]
        },
        {
            Id: '1.1',
            ParentIds: ['1'],
            Time: Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_2__["utc"])().toISO(),
            Content: [{
                    Text: '1.1  ',
                }]
        },
        {
            Id: '1.2',
            ParentIds: ['1'],
            Time: Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_2__["utc"])().toISO(),
            Content: [{
                    Text: '1.2 ',
                }]
        },
        {
            Id: '1.2.1',
            ParentIds: ['1.2'],
            Time: Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_2__["utc"])().toISO(),
            Content: [{
                    Text: '1.2.1 ',
                }]
        },
        {
            Id: '1.2.2',
            ParentIds: ['1.2'],
            Time: Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_2__["utc"])().toISO(),
            Content: [{
                    Text: '1.2.2 ',
                }]
        }
    ],
    Users: [{
            Id: 's',
            Name: '',
            Email: 'styopa@contextify.app'
        }, {
            Id: 'f',
            Name: '',
            Email: 'fra@contextify.app'
        }, {
            Id: 'a',
            Name: '',
            Email: 'anna@contextify.app'
        }, {
            Id: 'b',
            Name: '',
            Email: 'bob@contextify.app'
        }],
    Relations: [{
            UserId: 'b',
            ContextId: '1',
            Type: _context_dbo__WEBPACK_IMPORTED_MODULE_0__["RelationType"].Owner
        }, {
            UserId: 's',
            ContextId: '1.1',
            Type: _context_dbo__WEBPACK_IMPORTED_MODULE_0__["RelationType"].Owner
        }, {
            UserId: 'f',
            ContextId: '1.2',
            Type: _context_dbo__WEBPACK_IMPORTED_MODULE_0__["RelationType"].Owner
        }],
    UserState: {
        ContextsState: {
            '1.2': {
                Collapsed: false
            }
        }
    }
});
const DefaultData = DefaultDataTest1;


/***/ }),

/***/ "./model/root.ts":
/*!***********************!*\
  !*** ./model/root.ts ***!
  \***********************/
/*! exports provided: Root */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Root", function() { return Root; });
/* harmony import */ var _dbo_default__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dbo/default */ "./model/dbo/default.ts");
/* harmony import */ var _base_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base/tree */ "./model/base/tree.ts");
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./context */ "./model/context.ts");
/* harmony import */ var _user__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./user */ "./model/user.ts");
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_hypertype_core__WEBPACK_IMPORTED_MODULE_4__);





class Root extends _base_tree__WEBPACK_IMPORTED_MODULE_1__["GeneralTree"] {
    constructor(dbo = Object(_dbo_default__WEBPACK_IMPORTED_MODULE_0__["DefaultData"])()) {
        super();
        this.Update = new _hypertype_core__WEBPACK_IMPORTED_MODULE_4__["ReplaySubject"](1);
        this.State$ = this.Update.pipe(Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_4__["debounceTime"])(0), Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_4__["tap"])(() => {
            console.log(...this.MainContext.flatMap(t => t.Path));
        }), Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_4__["mapTo"])(this), Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_4__["shareReplay"])(1));
        window['root'] = this;
        this.UserMap = new Map(dbo.Users.map(userDbo => [userDbo.Id, new _user__WEBPACK_IMPORTED_MODULE_3__["User"](userDbo)]));
        const mainContextDbo = dbo.Contexts.find(c => c.ParentIds.length == 0);
        const contextDboTree = Object(_base_tree__WEBPACK_IMPORTED_MODULE_1__["treeMap"])(mainContextDbo, item => dbo.Contexts
            .filter(c => c.ParentIds.includes(item.Id)));
        this.MainContext = contextDboTree.map(t => new _context__WEBPACK_IMPORTED_MODULE_2__["Context"](this, t));
        this.ContextMap = this.MainContext
            .flatMap(c => c)
            .groupBy(c => c.Id);
        dbo.Relations.forEach(relation => {
            const contexts = this.ContextMap.get(relation.ContextId);
            const user = this.UserMap.get(relation.UserId);
            contexts.forEach(context => {
                user.Contexts.set(context, relation.Type);
                context.Users.set(user, relation.Type);
            });
        });
        for (const key in dbo.UserState.ContextsState) {
            const state = dbo.UserState.ContextsState[key];
            for (const context of this.ContextMap.get(key)) {
                context.Collapsed = state.Collapsed;
            }
        }
        this.Update.next();
    }
    get Children() {
        return [this.MainContext];
    }
    GetContext$(ids) {
        return this.State$.pipe(Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_4__["map"])(root => root.get(ids)));
    }
}


/***/ }),

/***/ "./model/user.ts":
/*!***********************!*\
  !*** ./model/user.ts ***!
  \***********************/
/*! exports provided: User */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "User", function() { return User; });
class User {
    constructor(dbo) {
        this.Contexts = new Map();
        this.Data = dbo;
    }
}


/***/ }),

/***/ "./node_modules/@hypertype/app/dist/esm/app/application.builder.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@hypertype/app/dist/esm/app/application.builder.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
const router_1 = __webpack_require__(/*! ./router */ "./node_modules/@hypertype/app/dist/esm/app/router.js");
const application_1 = __webpack_require__(/*! ./application */ "./node_modules/@hypertype/app/dist/esm/app/application.js");
const store_1 = __webpack_require__(/*! ../store */ "./node_modules/@hypertype/app/dist/esm/store/index.js");
const logger_1 = __webpack_require__(/*! ./logger */ "./node_modules/@hypertype/app/dist/esm/app/logger.js");
const infr_1 = __webpack_require__(/*! @hypertype/infr */ "./node_modules/@hypertype/infr/dist/esm/common/index.js");
class ApplicationBuilder {
    static build() {
        this.container.provide([
            // {provide: AppRoot, multiple: true},
            { provide: store_1.RootStore, useClass: store_1.RootStore, deps: [infr_1.StateLogger] },
            { provide: application_1.Application, deps: [core_1.Container, store_1.RootStore] },
            { provide: router_1.Router, deps: [router_1.IRouterOptions] },
            { provide: logger_1.Logger }
        ]);
        return this.container.get(application_1.Application);
    }
    static withRouter(options) {
        this.container.provide([{ provide: router_1.IRouterOptions, useValue: options }]);
        return this;
    }
    static withUI(uiContainer) {
        this.container.provide(uiContainer);
        return this;
    }
    static withInfrustructure(infrContainer) {
        this.container.provide(infrContainer);
        return this;
    }
    static withStores(...stores) {
        this.container.provide(stores.map(s => ({ provide: s })));
        return this;
    }
}
ApplicationBuilder.container = new core_1.Container();
exports.ApplicationBuilder = ApplicationBuilder;


/***/ }),

/***/ "./node_modules/@hypertype/app/dist/esm/app/application.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@hypertype/app/dist/esm/app/application.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
const ui_1 = __webpack_require__(/*! @hypertype/ui */ "./node_modules/@hypertype/ui/dist/index.js");
let Application = class Application {
    constructor(container) {
        this.container = container;
    }
    Init() {
        ui_1.init(this.container);
    }
    Provide(...providers) {
        this.container.provide(providers);
    }
    get(type) {
        return this.container.get(type);
    }
};
Application = __decorate([
    core_1.Injectable(),
    __metadata("design:paramtypes", [core_1.Container])
], Application);
exports.Application = Application;


/***/ }),

/***/ "./node_modules/@hypertype/app/dist/esm/app/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@hypertype/app/dist/esm/app/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./application */ "./node_modules/@hypertype/app/dist/esm/app/application.js"));
__export(__webpack_require__(/*! ./router */ "./node_modules/@hypertype/app/dist/esm/app/router.js"));
__export(__webpack_require__(/*! ./logger */ "./node_modules/@hypertype/app/dist/esm/app/logger.js"));
__export(__webpack_require__(/*! ./application.builder */ "./node_modules/@hypertype/app/dist/esm/app/application.builder.js"));


/***/ }),

/***/ "./node_modules/@hypertype/app/dist/esm/app/logger.js":
/*!************************************************************!*\
  !*** ./node_modules/@hypertype/app/dist/esm/app/logger.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class Logger {
    send(data) {
        console.log(data);
    }
    sendMessage(data, level) {
        if (typeof data === 'string') {
            this.send({
                message: data,
                level: level
            });
        }
        else {
            this.send({
                ...data,
                level: level
            });
        }
    }
    error(data) {
        this.sendMessage(data, LoggerLevel.Error);
    }
    success(data) {
        this.sendMessage(data, LoggerLevel.Success);
    }
    info(data) {
        this.sendMessage(data, LoggerLevel.Info);
    }
    debug(data) {
        this.sendMessage(data, LoggerLevel.Debug);
    }
    warning(data) {
        this.sendMessage(data, LoggerLevel.Warning);
    }
    failure(data) {
        this.sendMessage(data, LoggerLevel.Failure);
    }
}
exports.Logger = Logger;
var LoggerLevel;
(function (LoggerLevel) {
    LoggerLevel[LoggerLevel["Info"] = -1] = "Info";
    LoggerLevel[LoggerLevel["Debug"] = 0] = "Debug";
    LoggerLevel[LoggerLevel["Warning"] = 1] = "Warning";
    LoggerLevel[LoggerLevel["Error"] = 2] = "Error";
    LoggerLevel[LoggerLevel["Failure"] = 3] = "Failure";
    LoggerLevel[LoggerLevel["Success"] = 4] = "Success";
})(LoggerLevel = exports.LoggerLevel || (exports.LoggerLevel = {}));


/***/ }),

/***/ "./node_modules/@hypertype/app/dist/esm/app/router.js":
/*!************************************************************!*\
  !*** ./node_modules/@hypertype/app/dist/esm/app/router.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const router5_1 = __webpack_require__(/*! router5 */ "./node_modules/router5/dist/index.js");
const browserPlugin = __webpack_require__(/*! router5-plugin-browser/dist */ "./node_modules/router5-plugin-browser/dist/index.js");
const core_1 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
class IRouterOptions {
}
exports.IRouterOptions = IRouterOptions;
class Router {
    constructor(routerInit) {
        this.Actions = {
            navigate: (route, params) => {
                this.router.navigate(route, params);
            }
        };
        this.router = router5_1.default(routerInit.routes, routerInit.options);
        this.router.usePlugin(browserPlugin());
        this.router.start();
        this.State$ = new core_1.Observable(subscr => {
            this.router.subscribe(change => subscr.next(change.route));
        }).pipe(core_1.startWith(this.router.getState()));
    }
}
exports.Router = Router;


/***/ }),

/***/ "./node_modules/@hypertype/app/dist/esm/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@hypertype/app/dist/esm/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./store */ "./node_modules/@hypertype/app/dist/esm/store/index.js"));
__export(__webpack_require__(/*! ./app */ "./node_modules/@hypertype/app/dist/esm/app/index.js"));


/***/ }),

/***/ "./node_modules/@hypertype/app/dist/esm/store/ActionsCreator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@hypertype/app/dist/esm/store/ActionsCreator.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
/**
 * Created by xamidylin on 06.07.2017.
 */
class ActionsCreator {
    constructor() {
        this.path = [];
        this.DIFF_ACTION = `diff`;
        this.ONLOAD_ACTION = `onload`;
        this.INIT_ACTION = `init`;
        this.INIT_IF_NULL_ACTION = 'init_if_null';
        this.actionQueueSubject$ = new core_1.ReplaySubject();
        this.actionQueue = this.actionQueueSubject$.asObservable();
    }
    get prefix() {
        return this.path.map(k => `${k}.`).join('');
    }
    Diff(diff) {
        return this.Action({
            type: this.DIFF_ACTION,
            payload: diff
        });
    }
    Init(state) {
        return this.Action({
            type: this.INIT_ACTION,
            payload: state
        });
    }
    InitIfNull(state) {
        return this.Action({
            type: this.INIT_IF_NULL_ACTION,
            payload: state
        });
    }
    RouteAction(action) {
        if (typeof action === "string")
            return this.RouteAction({ type: action }).type;
        return Object.assign({}, action, {
            type: `${this.prefix}${action.type}`
        });
    }
    Action(action) {
        if (!this.store) {
            //  ,    
            this.actionQueueSubject$.next(action);
            return;
        }
        const routedAction = this.RouteAction(action);
        this.dispatch(routedAction);
    }
    dispatch(action) {
        if (this.store)
            return this.store.dispatch(action);
        //  ,  
        this.actionQueueSubject$.next(action);
    }
    InitActionCreator(store, path, state = {}) {
        this.store = store;
        this.path = path;
        if (state == {}) {
            this.InitIfNull(state);
        }
        else {
            this.InitIfNull(state);
        }
        this.actionQueue
            .subscribe(this.Action.bind(this));
        this.actionQueueSubject$.complete();
    }
}
exports.ActionsCreator = ActionsCreator;


/***/ }),

/***/ "./node_modules/@hypertype/app/dist/esm/store/BaseStore.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@hypertype/app/dist/esm/store/BaseStore.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const reducers_1 = __webpack_require__(/*! ./reducers */ "./node_modules/@hypertype/app/dist/esm/store/reducers.js");
const ActionsCreator_1 = __webpack_require__(/*! ./ActionsCreator */ "./node_modules/@hypertype/app/dist/esm/store/ActionsCreator.js");
const core_1 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
const core_2 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
class BaseStore {
    constructor(parentStore, key) {
        this.key = key;
        this.path = [];
        this.Actions = new ActionsCreator_1.ActionsCreator();
        this.StoresMap = {};
        this.epic = {
            epic$: (action$, store) => core_2.NEVER
        };
        this.reducer = {
            reduce: reducers_1.objectReducer(x => x)
        };
        this.OnInit = new core_1.Subject();
        if (!parentStore)
            //   rootStore
            return;
        this.parentStore = parentStore;
        this.store = this.parentStore.store;
        parentStore.Register(this, key);
        setTimeout(() => this.Init());
    }
    get epicRegistrator() {
        return this.parentStore.epicRegistrator;
    }
    get combinedReducer() {
        return (state = null, action) => {
            try {
                if (!action.type)
                    return state;
                const keys = action.type.split(".");
                const key = keys[0];
                const targetStore = this.StoresMap[key];
                if (!targetStore)
                    return this.reducer.reduce(state, action);
                const newSubState = targetStore.reduce(state && state[key] || null, reducers_1.downgradeAction(action));
                return Object.assign({}, state, {
                    [key]: newSubState
                });
            }
            catch (e) {
                console.log(e);
                return state;
            }
        };
    }
    dispatch(action) {
        return this.store.dispatch(action);
    }
    Register(childStore, key) {
        this.StoresMap[key] = childStore;
        childStore.path = [...this.path, key];
        // console.log('registered', childStore.path.join('.'));
        // setTimeout(() =>childStore.Init({}));
    }
    reduce(state, action) {
        return this.combinedReducer(state, action);
    }
    getState() {
        return this.parentStore.getState()[this.key];
    }
    Init(state = {}) {
        // Object.keys(this.StoresMap).forEach(key => this.StoresMap[key].Init());
        this.Actions.InitActionCreator(this.store, this.path, state);
        this.epicRegistrator(this.epic.epic$, this);
        this.OnInit.next(state);
        this.OnInit.complete();
    }
}
exports.BaseStore = BaseStore;


/***/ }),

/***/ "./node_modules/@hypertype/app/dist/esm/store/ObservableStore.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@hypertype/app/dist/esm/store/ObservableStore.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseStore_1 = __webpack_require__(/*! ./BaseStore */ "./node_modules/@hypertype/app/dist/esm/store/BaseStore.js");
const core_1 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
const core_2 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
class ObservableStore extends BaseStore_1.BaseStore {
    constructor(parentStore, key) {
        super(parentStore, key);
        this.selector = state => {
            const parentState = this.parentStore.selector(state);
            return parentState && parentState[this.key] || null;
        };
        this.initSubject = new core_1.ReplaySubject(1);
        this.state$ = this.initSubject.asObservable().pipe(core_2.mergeMap(a => this.store.select(this.selector)));
        this.parentStore = parentStore;
    }
    getState() {
        return this.selector(this.store.getState());
    }
    asObservable() {
        return this.state$;
    }
    Init(state = {}) {
        super.Init(state);
        this.initSubject.next('init');
        this.initSubject.complete();
    }
}
exports.ObservableStore = ObservableStore;


/***/ }),

/***/ "./node_modules/@hypertype/app/dist/esm/store/RootStore.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@hypertype/app/dist/esm/store/RootStore.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ObservableStore_1 = __webpack_require__(/*! ./ObservableStore */ "./node_modules/@hypertype/app/dist/esm/store/ObservableStore.js");
const redux_1 = __webpack_require__(/*! redux */ "./node_modules/redux/lib/redux.js");
const redux_observable_1 = __webpack_require__(/*! ./redux-observable */ "./node_modules/@hypertype/app/dist/esm/store/redux-observable/index.js");
const core_1 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
const store_1 = __webpack_require__(/*! ./store */ "./node_modules/@hypertype/app/dist/esm/store/store.js");
/**
 * Created by xamidylin on 20.06.2017.
 */
class RootStore extends ObservableStore_1.ObservableStore {
    constructor(stateLogger) {
        super(null, null);
        this.stateLogger = stateLogger;
        this.store = new store_1.Store();
        this.selector = x => x;
        this.epic$ = (action$) => {
            const actionSubject = new core_1.Subject();
            //replay actions for epics dynamically loaded in future
            const replayActions$ = action$.pipe(core_1.shareReplay());
            replayActions$.subscribe();
            this._epicRegistrator = (epic, store) => {
                const path = store.path.join('.');
                const downgraded = this.downgradeActions(replayActions$, path);
                const result = epic(downgraded, store);
                const upgraded = this.upgradeActions(result, path);
                const catched = upgraded.pipe(core_1.catchError(e => {
                    console.log(e);
                    return core_1.NEVER;
                }));
                return actionSubject.next(catched);
            };
            for (let key in this.StoresMap) {
                this.epicRegistrator(this.StoresMap[key].epic.epic$, this.StoresMap[key]);
            }
            this.epicRegistrator(this.epic.epic$, this);
            return actionSubject.asObservable().pipe(core_1.mergeMap(x => x));
        };
    }
    get epicRegistrator() {
        return this._epicRegistrator;
    }
    initStore(state) {
        if (state)
            this.dispatch({
                type: 'newState',
                payload: state
            });
        return this.store;
    }
    createStore(state) {
        // if (this.store) {
        //     if (state)
        //         this.dispatch({
        //             type: 'newState',
        //             payload: state
        //         });
        //     return this.store;
        // }
        console.log('store');
        const epicMiddleware = redux_observable_1.createEpicMiddleware();
        this.store.provide(this.combinedReducer, state, (redux_1.applyMiddleware(epicMiddleware, this.getLogMiddleware(), ...this.getOtherMiddlewares())));
        epicMiddleware.run(this.epic$);
        // state && state.History && state.History.forEach(this.ngRedux.dispatch);
        return this.store;
    }
    dispatch(a) {
        const res = this.store.dispatch(a);
        return res;
    }
    getState() {
        return this.store.getState();
    }
    getLogMiddleware() {
        return store => next => action => {
            const result = next(action);
            this.stateLogger.send(action, store.getState());
            // global['actions'] = [action, ...(global['actions'] || [])];
            // global['state'] = store.getState();
            return result;
        };
    }
    getOtherMiddlewares() {
        return [];
    }
    //to convert actions deep-out hierarchy of stores
    upgradeActions(action$, path) {
        return action$.pipe(core_1.map(a => Object.assign({}, a, {
            type: `${path}.${a.type}`
        })));
    }
    //to convert actions deep-into hierarchy of stores
    downgradeActions(action$, path) {
        return action$.pipe(core_1.filter(a => a.type.startsWith(path)), core_1.map(a => Object.assign({}, a, {
            type: a.type.substr((path.length || -1) + 1)
        })));
    }
}
exports.RootStore = RootStore;


/***/ }),

/***/ "./node_modules/@hypertype/app/dist/esm/store/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@hypertype/app/dist/esm/store/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./ActionsCreator */ "./node_modules/@hypertype/app/dist/esm/store/ActionsCreator.js"));
// export * from './ObservableArrayStore';
__export(__webpack_require__(/*! ./ObservableStore */ "./node_modules/@hypertype/app/dist/esm/store/ObservableStore.js"));
__export(__webpack_require__(/*! ./RootStore */ "./node_modules/@hypertype/app/dist/esm/store/RootStore.js"));
__export(__webpack_require__(/*! ./reducers */ "./node_modules/@hypertype/app/dist/esm/store/reducers.js"));
__export(__webpack_require__(/*! ./store */ "./node_modules/@hypertype/app/dist/esm/store/store.js"));
__export(__webpack_require__(/*! ./redux-observable/index */ "./node_modules/@hypertype/app/dist/esm/store/redux-observable/index.js"));


/***/ }),

/***/ "./node_modules/@hypertype/app/dist/esm/store/reducers.js":
/*!****************************************************************!*\
  !*** ./node_modules/@hypertype/app/dist/esm/store/reducers.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const redux_1 = __webpack_require__(/*! redux */ "./node_modules/redux/lib/redux.js");
const core_1 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
exports.downgradeAction = action => Object.assign({}, action, { type: action.type.split('.').slice(1).join('.') });
function combineReducers(object) {
    const defReducer = redux_1.combineReducers(object);
    return (state = null, action) => {
        if (state == null)
            return null;
        return defReducer(state, action);
    };
}
exports.combineReducers = combineReducers;
function objectReducerInner(reducer, initial = null) {
    return (state = initial, action) => {
        switch (action.type) {
            case "init_if_null":
                return state || reducer(action.payload, action);
            case 'init':
                return reducer(action.payload, action);
            case 'diff':
                return core_1.deepAssign({}, reducer(state, exports.downgradeAction(action)), action.payload);
            case 'assign':
                return Object.assign({}, reducer(state, exports.downgradeAction(action)), action.payload);
            default:
                return reducer(state, action);
        }
    };
}
function objectReducer(reducer, initial = null, key = null) {
    if (typeof reducer === "object")
        return objectReducer(combineReducers(reducer), initial, key);
    if (key)
        return exports.filterReducer(objectReducer(reducer, initial), key, initial);
    return objectReducerInner(reducer, initial);
}
exports.objectReducer = objectReducer;
exports.filterReducer = (reducer, key, initial = {}) => (state = initial, action) => {
    let result = action.type.split('.')[0] == key
        ? reducer(state, exports.downgradeAction(action))
        : state || null;
    return result;
};
function arrayReducer(itemReducer = core_1.Fn.I, arrayReducer = core_1.Fn.I, filterKey, filter = typeof filterKey === "function" ? filterKey : filterKey ?
    (t, a, i) => t[filterKey] == (a[filterKey] || a.payload[filterKey]) :
    (t, a, i) => i == a.index) {
    const check = (item, action, index) => {
        if (filter)
            return filter(item, action, index) && itemReducer(item, action);
        const result = itemReducer(item, action);
        if (result != item)
            return result;
    };
    const updateReducer = (items = [], action) => {
        for (let i = 0; i < items.length; i++) {
            let item = items[i];
            let result = check(item, action, i);
            if (result && result != item) {
                return [
                    ...items.slice(0, i),
                    result,
                    ...items.slice(i + 1)
                ];
            }
        }
    };
    const deleteReducer = (items = [], action) => {
        for (let i = 0; i < items.length; i++) {
            let item = items[i];
            if (filter && filter(item, action, i)) {
                return [
                    ...items.slice(0, i),
                    ...items.slice(i + 1)
                ];
            }
            let result = check(item, action, i);
            if (result && result != item) {
                return [
                    ...items.slice(0, i),
                    ...items.slice(i + 1)
                ];
            }
        }
    };
    const innerReducer = (items = null, action) => {
        if (!items)
            items = [];
        if (!Array.isArray(items))
            items = [];
        switch (action.type.split('.')[0].toUpperCase()) {
            case "init_if_null".toUpperCase():
                return items && items.length && items || action.payload;
            case "set".toUpperCase():
            case "init".toUpperCase():
                return action.payload;
            case "add".toUpperCase():
                return items.concat([itemReducer(action.payload, action)]);
            case "addRange".toUpperCase():
                return items.concat(action.payload);
            case "remove".toUpperCase():
                return [
                    ...items.slice(0, action.index),
                    ...items.slice(action.index + 1)
                ];
            case "delete".toUpperCase():
                return deleteReducer(items, exports.downgradeAction(action))
                    || items;
            case "update".toUpperCase():
                return updateReducer(items, exports.downgradeAction(action))
                    || items;
            case "addOrUpdate".toUpperCase():
                return updateReducer(items, exports.downgradeAction(action))
                    || items.concat(action.payload);
            default:
                return updateReducer(items, action)
                    || items;
        }
    };
    return (items = null, action) => arrayReducer(innerReducer(items, action), action);
}
exports.arrayReducer = arrayReducer;
function arrayFilterReducer(itemReducer, arrReducer = core_1.Fn.I, key, filter) {
    return exports.filterReducer(arrayReducer(itemReducer, arrReducer, filter), key, []);
}
exports.arrayFilterReducer = arrayFilterReducer;


/***/ }),

/***/ "./node_modules/@hypertype/app/dist/esm/store/redux-observable/ActionsObservable.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@hypertype/app/dist/esm/store/redux-observable/ActionsObservable.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
const core_2 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
const core_3 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
const operators_1 = __webpack_require__(/*! ./operators */ "./node_modules/@hypertype/app/dist/esm/store/redux-observable/operators.js");
class ActionsObservable extends core_1.Observable {
    constructor(actionsSubject) {
        super();
        this.source = actionsSubject;
    }
    static of(...actions) {
        return new this(core_2.of(...actions));
    }
    static from(actions, scheduler) {
        return new this(core_3.from(actions, scheduler));
    }
    ofType(...keys) {
        return operators_1.ofType(...keys)(this);
    }
}
exports.ActionsObservable = ActionsObservable;


/***/ }),

/***/ "./node_modules/@hypertype/app/dist/esm/store/redux-observable/StateObservable.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@hypertype/app/dist/esm/store/redux-observable/StateObservable.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
const core_2 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
class StateObservable extends core_2.Observable {
    constructor(stateSubject, initialState) {
        super(subscriber => {
            const subscription = this.__notifier.subscribe(subscriber);
            if (subscription && !subscription.closed) {
                subscriber.next(this.value);
            }
            return subscription;
        });
        this.value = initialState;
        this.__notifier = new core_1.Subject();
        this.__subscription = stateSubject.subscribe(value => {
            // We only want to update state$ if it has actually changed since
            // redux requires reducers use immutability patterns.
            // This is basically what distinctUntilChanged() does but it's so simple
            // we don't need to pull that code in
            if (value !== this.value) {
                this.value = value;
                this.__notifier.next(value);
            }
        });
    }
}
exports.StateObservable = StateObservable;


/***/ }),

/***/ "./node_modules/@hypertype/app/dist/esm/store/redux-observable/combineEpics.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@hypertype/app/dist/esm/store/redux-observable/combineEpics.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
/**
  Merges all epics into a single one.
 */
exports.combineEpics = (...epics) => {
    const merger = ((...args) => core_1.merge(...epics.map(epic => {
        const output$ = epic(...args);
        if (!output$) {
            throw new TypeError(`combineEpics: one of the provided Epics "${epic.name || '<anonymous>'}" does not return a stream. Double check you\'re not missing a return statement!`);
        }
        return output$;
    })));
    // Technically the `name` property on Function's are supposed to be read-only.
    // While some JS runtimes allow it anyway (so this is useful in debugging)
    // some actually throw an exception when you attempt to do so.
    try {
        Object.defineProperty(merger, 'name', {
            value: `combineEpics(${epics.map(epic => epic.name || '<anonymous>').join(', ')})`,
        });
    }
    catch (e) { }
    return merger;
};


/***/ }),

/***/ "./node_modules/@hypertype/app/dist/esm/store/redux-observable/createEpicMiddleware.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@hypertype/app/dist/esm/store/redux-observable/createEpicMiddleware.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
const core_2 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
const core_3 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
const core_4 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
const ActionsObservable_1 = __webpack_require__(/*! ./ActionsObservable */ "./node_modules/@hypertype/app/dist/esm/store/redux-observable/ActionsObservable.js");
const StateObservable_1 = __webpack_require__(/*! ./StateObservable */ "./node_modules/@hypertype/app/dist/esm/store/redux-observable/StateObservable.js");
function createEpicMiddleware(options = {}) {
    const epic$ = new core_1.Subject();
    let store;
    const epicMiddleware = (_store => {
        store = _store;
        const actionSubject$ = new core_1.Subject().pipe();
        const stateSubject$ = new core_1.Subject().pipe();
        const action$ = new ActionsObservable_1.ActionsObservable(actionSubject$);
        const state$ = new StateObservable_1.StateObservable(stateSubject$, store.getState());
        const result$ = epic$.pipe(core_3.map(epic => {
            const output$ = 'dependencies' in options
                ? epic(action$, state$, options.dependencies)
                : epic(action$, state$);
            if (!output$) {
                throw new TypeError(`Your root Epic "${epic.name || '<anonymous>'}" does not return a stream. Double check you\'re not missing a return statement!`);
            }
            return output$;
        }), core_4.mergeMap(output$ => core_2.from(output$).pipe()));
        result$.subscribe(store.dispatch);
        return next => {
            return action => {
                // Downstream middleware gets the action first,
                // which includes their reducers, so state is
                // updated before epics receive the action
                const result = next(action);
                // It's important to update the state$ before we emit
                // the action because otherwise it would be stale
                stateSubject$.next(store.getState());
                actionSubject$.next(action);
                return result;
            };
        };
    });
    epicMiddleware.run = rootEpic => {
        epic$.next(rootEpic);
    };
    return epicMiddleware;
}
exports.createEpicMiddleware = createEpicMiddleware;


/***/ }),

/***/ "./node_modules/@hypertype/app/dist/esm/store/redux-observable/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@hypertype/app/dist/esm/store/redux-observable/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var createEpicMiddleware_1 = __webpack_require__(/*! ./createEpicMiddleware */ "./node_modules/@hypertype/app/dist/esm/store/redux-observable/createEpicMiddleware.js");
exports.createEpicMiddleware = createEpicMiddleware_1.createEpicMiddleware;
var ActionsObservable_1 = __webpack_require__(/*! ./ActionsObservable */ "./node_modules/@hypertype/app/dist/esm/store/redux-observable/ActionsObservable.js");
exports.ActionsObservable = ActionsObservable_1.ActionsObservable;
var StateObservable_1 = __webpack_require__(/*! ./StateObservable */ "./node_modules/@hypertype/app/dist/esm/store/redux-observable/StateObservable.js");
exports.StateObservable = StateObservable_1.StateObservable;
var combineEpics_1 = __webpack_require__(/*! ./combineEpics */ "./node_modules/@hypertype/app/dist/esm/store/redux-observable/combineEpics.js");
exports.combineEpics = combineEpics_1.combineEpics;
var operators_1 = __webpack_require__(/*! ./operators */ "./node_modules/@hypertype/app/dist/esm/store/redux-observable/operators.js");
exports.ofType = operators_1.ofType;
__export(__webpack_require__(/*! ./types */ "./node_modules/@hypertype/app/dist/esm/store/redux-observable/types.js"));


/***/ }),

/***/ "./node_modules/@hypertype/app/dist/esm/store/redux-observable/operators.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@hypertype/app/dist/esm/store/redux-observable/operators.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
const keyHasType = (type, key) => {
    return type === key || typeof key === 'function' && type === key.toString();
};
exports.ofType = (...keys) => (source) => source.pipe(core_1.filter(({ type }) => {
    const len = keys.length;
    if (len === 1) {
        return keyHasType(type, keys[0]);
    }
    else {
        for (let i = 0; i < len; i++) {
            if (keyHasType(type, keys[i])) {
                return true;
            }
        }
    }
    return false;
}));


/***/ }),

/***/ "./node_modules/@hypertype/app/dist/esm/store/redux-observable/types.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@hypertype/app/dist/esm/store/redux-observable/types.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");


/***/ }),

/***/ "./node_modules/@hypertype/app/dist/esm/store/store.js":
/*!*************************************************************!*\
  !*** ./node_modules/@hypertype/app/dist/esm/store/store.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const redux_1 = __webpack_require__(/*! redux */ "./node_modules/redux/lib/redux.js");
const core_1 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
class Store {
    dispatch(action) {
        this.store.dispatch(action);
    }
    provide(reducer, initState, middlewares) {
        this.store = redux_1.createStore(reducer, initState, middlewares);
    }
    getState() {
        return this.store.getState();
    }
    select(selector) {
        return new core_1.Observable(subscr => {
            subscr.next(selector(this.getState()));
            this.store.subscribe(() => {
                subscr.next(selector(this.getState()));
            });
        });
    }
}
exports.Store = Store;


/***/ }),

/***/ "./node_modules/@hypertype/core/dist/esm/di/container.js":
/*!***************************************************************!*\
  !*** ./node_modules/@hypertype/core/dist/esm/di/container.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const store_1 = __webpack_require__(/*! ./store */ "./node_modules/@hypertype/core/dist/esm/di/store.js");
class Container {
    constructor() {
        this.store = new store_1.Store();
    }
    getProviders() {
        return this.store.getProviders()
            .map(provider => {
            if (!provider.provide)
                provider = { provide: provider };
            if (!provider.useClass && !provider.useValue && !provider.useFactory)
                provider.useClass = provider.provide;
            if (Container.StaticDepsMap.has(provider.useClass)) {
                const { deps, multiple } = Container.StaticDepsMap.get(provider.useClass);
                provider.deps = deps;
                provider.multi = multiple;
            }
            return provider;
        });
    }
    get(target) {
        if (target === Container)
            return this;
        let existing = this.store.find(target);
        if (!existing) {
            throw new Error(`unknown dependency, ${target.name || target}`);
            // console.warn('should register', target);
            // existing = this.store.register({provide: target, useClass: target, deps: []});
        }
        return this.resolve(existing);
    }
    static withProviders(...providers) {
        const result = new Container();
        result.provide(providers);
        return result;
    }
    provide(providers) {
        if (providers instanceof Container) {
            this.store.register(providers.store);
        }
        else {
            providers.forEach(p => this.store.register(p));
        }
    }
    resolve(provider) {
        if (provider.useValue)
            return provider.useValue;
        if (!provider.useClass) {
            provider.useClass = provider.provide;
        }
        if (Container.StaticDepsMap.has(provider.useClass)) {
            const { deps, multiple } = Container.StaticDepsMap.get(provider.useClass);
            provider.deps = deps;
            provider.multiple = multiple;
        }
        if (provider.useClass) {
            if (!provider.deps) {
                // console.warn('no deps in provider', provider.provide, provider.useClass);
                provider.deps = (provider.useClass && provider.useClass.deps) || provider.provide.deps || [];
            }
            const deps = provider.deps.map(dep => {
                try {
                    return this.get(dep);
                }
                catch (e) {
                    e.message = `
                        couldn't resolve ${provider.provide.name}
                           ${e.message}`;
                    throw e;
                }
            });
            const instance = new provider.useClass(...deps);
            if (!provider.multiple) {
                provider.useValue = instance;
            }
            return instance;
        }
        throw new Error('need useClass or useValue');
    }
}
exports.Container = Container;
Container.StaticDepsMap = new Map();


/***/ }),

/***/ "./node_modules/@hypertype/core/dist/esm/di/decorators.js":
/*!****************************************************************!*\
  !*** ./node_modules/@hypertype/core/dist/esm/di/decorators.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
const container_1 = __webpack_require__(/*! ./container */ "./node_modules/@hypertype/core/dist/esm/di/container.js");
function Injectable(multiple = false) {
    return ((target, deps) => {
        if ('getMetadata' in Reflect) {
            deps = Reflect['getMetadata']("design:paramtypes", target);
        }
        if (container_1.Container.StaticDepsMap.has(target)) {
            const { deps: oldDeps } = container_1.Container.StaticDepsMap.get(target);
            oldDeps.forEach((d, i) => {
                if (d)
                    deps[i] = d;
            });
        }
        container_1.Container.StaticDepsMap.set(target, { deps, multiple });
    });
}
exports.Injectable = Injectable;
exports.Inject = (injectionToken) => {
    return (target, deps, index) => {
        if (!container_1.Container.StaticDepsMap.has(target)) {
            container_1.Container.StaticDepsMap.set(target, { deps: [], multiple: false });
        }
        container_1.Container.StaticDepsMap.get(target).deps[index] = injectionToken;
    };
};
//
// Object.assign(Reflect, {
//     decorate: (decoratorsAndDeps: any[], target, key, desc) => {
//         if (key) {
//             decoratorsAndDeps[0](target, key, desc);
//         } else {
//             const deps = decoratorsAndDeps.pop();
//             decoratorsAndDeps.reverse().forEach(decorator => decorator(target, deps));
//             return target;
//         }
//     },
//     metadata: (kind, deps) => {
//         if (kind == "design:paramtypes") {
//             return deps;
//         }
//     }
// });


/***/ }),

/***/ "./node_modules/@hypertype/core/dist/esm/di/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@hypertype/core/dist/esm/di/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./container */ "./node_modules/@hypertype/core/dist/esm/di/container.js"));
__export(__webpack_require__(/*! ./decorators */ "./node_modules/@hypertype/core/dist/esm/di/decorators.js"));
__export(__webpack_require__(/*! ./token */ "./node_modules/@hypertype/core/dist/esm/di/token.js"));


/***/ }),

/***/ "./node_modules/@hypertype/core/dist/esm/di/store.js":
/*!***********************************************************!*\
  !*** ./node_modules/@hypertype/core/dist/esm/di/store.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class Store {
    constructor(global = false) {
        this.providers = [];
        if (!global) {
            this.providers = [...exports.GlobalStore.providers];
        }
    }
    register(provider) {
        if (provider instanceof Store) {
            provider.providers.forEach(p => this.register(p));
        }
        else {
            if (!provider.provide)
                provider = { provide: provider };
            this.providers.push(provider);
            return provider;
        }
    }
    find(type) {
        return this.providers.filter(p => p.provide == type).pop();
    }
    getProviders() {
        return this.providers;
    }
}
exports.Store = Store;
exports.GlobalStore = new Store(true);


/***/ }),

/***/ "./node_modules/@hypertype/core/dist/esm/di/token.js":
/*!***********************************************************!*\
  !*** ./node_modules/@hypertype/core/dist/esm/di/token.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class InjectionToken {
    constructor(name) {
        this.name = name;
    }
}
exports.InjectionToken = InjectionToken;


/***/ }),

/***/ "./node_modules/@hypertype/core/dist/esm/frp/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@hypertype/core/dist/esm/frp/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./operators */ "./node_modules/@hypertype/core/dist/esm/frp/operators.js"));
__export(__webpack_require__(/*! ./switch-throttle */ "./node_modules/@hypertype/core/dist/esm/frp/switch-throttle.js"));


/***/ }),

/***/ "./node_modules/@hypertype/core/dist/esm/frp/operators.js":
/*!****************************************************************!*\
  !*** ./node_modules/@hypertype/core/dist/esm/frp/operators.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! rxjs/internal/Observable */ "./node_modules/rxjs/internal/Observable.js"));
__export(__webpack_require__(/*! rxjs/internal/ReplaySubject */ "./node_modules/rxjs/internal/ReplaySubject.js"));
__export(__webpack_require__(/*! rxjs/internal/Subject */ "./node_modules/rxjs/internal/Subject.js"));
__export(__webpack_require__(/*! rxjs/internal/BehaviorSubject */ "./node_modules/rxjs/internal/BehaviorSubject.js"));
__export(__webpack_require__(/*! rxjs/internal/observable/interval */ "./node_modules/rxjs/internal/observable/interval.js"));
__export(__webpack_require__(/*! rxjs/internal/observable/combineLatest */ "./node_modules/rxjs/internal/observable/combineLatest.js"));
__export(__webpack_require__(/*! rxjs/internal/observable/merge */ "./node_modules/rxjs/internal/observable/merge.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/filter */ "./node_modules/rxjs/internal/operators/filter.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/skip */ "./node_modules/rxjs/internal/operators/skip.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/skipWhile */ "./node_modules/rxjs/internal/operators/skipWhile.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/skipUntil */ "./node_modules/rxjs/internal/operators/skipUntil.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/map */ "./node_modules/rxjs/internal/operators/map.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/mapTo */ "./node_modules/rxjs/internal/operators/mapTo.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/startWith */ "./node_modules/rxjs/internal/operators/startWith.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/scan */ "./node_modules/rxjs/internal/operators/scan.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/tap */ "./node_modules/rxjs/internal/operators/tap.js"));
__export(__webpack_require__(/*! rxjs/internal/observable/never */ "./node_modules/rxjs/internal/observable/never.js"));
__export(__webpack_require__(/*! rxjs/internal/observable/of */ "./node_modules/rxjs/internal/observable/of.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/bufferTime */ "./node_modules/rxjs/internal/operators/bufferTime.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/concatMap */ "./node_modules/rxjs/internal/operators/concatMap.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/debounceTime */ "./node_modules/rxjs/internal/operators/debounceTime.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/mergeMap */ "./node_modules/rxjs/internal/operators/mergeMap.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/pairwise */ "./node_modules/rxjs/internal/operators/pairwise.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/shareReplay */ "./node_modules/rxjs/internal/operators/shareReplay.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/throttleTime */ "./node_modules/rxjs/internal/operators/throttleTime.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/withLatestFrom */ "./node_modules/rxjs/internal/operators/withLatestFrom.js"));
__export(__webpack_require__(/*! rxjs/internal/observable/from */ "./node_modules/rxjs/internal/observable/from.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/take */ "./node_modules/rxjs/internal/operators/take.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/takeUntil */ "./node_modules/rxjs/internal/operators/takeUntil.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/throttle */ "./node_modules/rxjs/internal/operators/throttle.js"));
__export(__webpack_require__(/*! rxjs/internal/observable/fromEvent */ "./node_modules/rxjs/internal/observable/fromEvent.js"));
__export(__webpack_require__(/*! rxjs/internal/scheduler/animationFrame */ "./node_modules/rxjs/internal/scheduler/animationFrame.js"));
__export(__webpack_require__(/*! rxjs/internal/scheduler/async */ "./node_modules/rxjs/internal/scheduler/async.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/distinctUntilChanged */ "./node_modules/rxjs/internal/operators/distinctUntilChanged.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/switchMap */ "./node_modules/rxjs/internal/operators/switchMap.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/toArray */ "./node_modules/rxjs/internal/operators/toArray.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/catchError */ "./node_modules/rxjs/internal/operators/catchError.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/finalize */ "./node_modules/rxjs/internal/operators/finalize.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/first */ "./node_modules/rxjs/internal/operators/first.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/delay */ "./node_modules/rxjs/internal/operators/delay.js"));
__export(__webpack_require__(/*! rxjs/internal/observable/throwError */ "./node_modules/rxjs/internal/observable/throwError.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/groupBy */ "./node_modules/rxjs/internal/operators/groupBy.js"));
__export(__webpack_require__(/*! rxjs/internal/operators/last */ "./node_modules/rxjs/internal/operators/last.js"));


/***/ }),

/***/ "./node_modules/@hypertype/core/dist/esm/frp/switch-throttle.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@hypertype/core/dist/esm/frp/switch-throttle.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const operators_1 = __webpack_require__(/*! ./operators */ "./node_modules/@hypertype/core/dist/esm/frp/operators.js");
function switchThrottle(time) {
    return (target, key, decorator) => {
        const requestSymbol = Symbol('request');
        const responseSymbol = Symbol('response');
        const fn = target[key];
        decorator.value = function (...args) {
            const requests$ = this[requestSymbol] = this[requestSymbol]
                || new operators_1.ReplaySubject(0);
            const response$ = this[responseSymbol] = this[responseSymbol] || requests$.pipe(operators_1.startWith((() => operators_1.of(null))), operators_1.mergeMap(a => [a, a]), operators_1.throttleTime(time, operators_1.async, { leading: true, trailing: true }), operators_1.switchMap(fn => fn()), operators_1.shareReplay(1)).subscribe();
            return new Promise(resolve => {
                requests$.next(() => fn.apply(this, args).then(resolve));
            });
        };
        // Object.defineProperty(target, key, {
        //     value(...args) {
        //     }
        // })
    };
}
exports.switchThrottle = switchThrottle;
function switchDebounce(time) {
    return (target, key, decorator) => {
        const requestSymbol = Symbol('request');
        const responseSymbol = Symbol('response');
        const fn = target[key];
        Object.defineProperty(target, key, {
            value(...args) {
                const requests$ = this[requestSymbol] = this[requestSymbol]
                    || new operators_1.ReplaySubject(0);
                const response$ = this[responseSymbol] = this[responseSymbol] || requests$.pipe(operators_1.debounceTime(time, operators_1.async), operators_1.switchMap(fn => fn()), operators_1.shareReplay(1));
                requests$.next(() => fn.apply(this, args));
                return response$.pipe(operators_1.first()).toPromise();
            }
        });
    };
}
exports.switchDebounce = switchDebounce;
/*
export function serializeAndDebounce() {
    return (target, key, decorator) => {
        const requestSymbol = Symbol('request');
        const responseSymbol = Symbol('response');
        const fn = target[key];
        Object.defineProperty(target, key, {
            value(...args) {
                const requests$: ReplaySubject<Function> = this[requestSymbol] = this[requestSymbol]
                    || new ReplaySubject<Function>(0);
                const response$ = this[responseSymbol] = this[responseSymbol] || requests$.pipe(
                    debounceTime(time, async),
                    switchMap(fn => fn()),
                    shareReplay(1)
                );
                requests$.next(() => fn.apply(this, args));
                return response$.pipe(first()).toPromise();
            }
        })
    }
}*/


/***/ }),

/***/ "./node_modules/@hypertype/core/dist/esm/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@hypertype/core/dist/esm/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__(/*! ./utils/Array */ "./node_modules/@hypertype/core/dist/esm/utils/Array.js");
__export(__webpack_require__(/*! ./frp */ "./node_modules/@hypertype/core/dist/esm/frp/index.js"));
__export(__webpack_require__(/*! ./di */ "./node_modules/@hypertype/core/dist/esm/di/index.js"));
var deepAssign_1 = __webpack_require__(/*! ./utils/deepAssign */ "./node_modules/@hypertype/core/dist/esm/utils/deepAssign.js");
exports.deepAssign = deepAssign_1.deepAssign;
__export(__webpack_require__(/*! ./utils/utc */ "./node_modules/@hypertype/core/dist/esm/utils/utc.js"));
var luxon_1 = __webpack_require__(/*! ./utils/luxon */ "./node_modules/@hypertype/core/dist/esm/utils/luxon.js");
exports.DateTime = luxon_1.DateTime;
exports.Duration = luxon_1.Duration;
var Fn_1 = __webpack_require__(/*! ./utils/Fn */ "./node_modules/@hypertype/core/dist/esm/utils/Fn.js");
exports.Fn = Fn_1.Fn;


/***/ }),

/***/ "./node_modules/@hypertype/core/dist/esm/utils/Array.js":
/*!**************************************************************!*\
  !*** ./node_modules/@hypertype/core/dist/esm/utils/Array.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Fn_1 = __webpack_require__(/*! ./Fn */ "./node_modules/@hypertype/core/dist/esm/utils/Fn.js");
Array.prototype.groupBy = function (selector, descending) {
    return this.reduce((result, item) => {
        const key = selector(item);
        if (result.has(key))
            result.get(key).push(item);
        else
            result.set(key, [item]);
        return result;
    }, new Map());
};
Array.prototype.toMap = function (keySelector, valSelector) {
    return this.reduce((res, cur) => {
        res[keySelector(cur)] = valSelector(cur);
        return res;
    }, {});
};
Array.prototype.orderBy = function (selector = Fn_1.Fn.I, descending = false) {
    return [...this].sort((a, b) => ((selector(a) > selector(b)) ? 1 : -1) * (descending ? -1 : 1));
};
Array.prototype.mapBy = function (selector) {
    return this.reduce((res, cur) => {
        var key = selector(cur);
        if (!res[key])
            res[key] = [];
        res[key].push(cur);
        return res;
    }, {});
};
Array.prototype.distinct = function (selector) {
    if (selector) {
        const map = this.reduce((map, cur) => {
            map.set(selector(cur), cur);
            return map;
        }, new Map());
        return Array.from(map.values());
    }
    return Array.from(new Set(this));
};
Array.prototype.range = function (min, max, step) {
    if (!step)
        step = 1;
    for (var i = min; i < max; i += step) {
        this.push(i);
    }
    return this;
};
Array.prototype.sum = function () {
    if (this.length == 0)
        return 0;
    return this.reduce((a, b) => a + b, 0);
};
Array.prototype.average = function () {
    return this.sum() / this.length;
};
Array.prototype.remove = function (item) {
    var index = this.indexOf(item);
    if (index == -1)
        return false;
    this.splice(index, 1);
    return true;
};
Array.prototype.removeAll = function (test) {
    if (!test) {
        this.length = 0;
        return this;
    }
    var left = 0;
    var right = this.length - 1;
    while (left <= right) {
        if (test(this[left])) {
            var temp = this[right];
            this[right] = left;
            this[left] = temp;
            right--;
        }
        else {
            left++;
        }
    }
    this.length = right + 1;
    return this;
};
Array.prototype.maxVal = function (fn) {
    if (this.length == 0)
        return null;
    var current = this[0];
    var currentVal = fn ? fn(current, 0) : current;
    this.forEach((item, i) => {
        if (current == null) {
            current = item;
            currentVal = fn ? fn(item, i) : item;
            return;
        }
        var val = fn ? fn(item, i) : item;
        if (val > currentVal) {
            current = item;
            currentVal = val;
        }
    });
    return currentVal;
};
Array.prototype.max = function (fn) {
    if (this.length == 0)
        return null;
    var current = this[0];
    var currentVal = fn ? fn(current) : +current;
    this.forEach(item => {
        if (current == null) {
            current = item;
            return;
        }
        var val = fn ? fn(item) : +item;
        if (val > currentVal) {
            current = item;
            currentVal = val;
        }
    });
    return current;
};
Array.prototype.minVal = function (fn) {
    if (this.length == 0)
        return null;
    var current = this[0];
    var currentVal = fn ? fn(current, 0) : current;
    this.forEach((item, i) => {
        if (current == null) {
            current = item;
            currentVal = fn ? fn(item, i) : item;
            return;
        }
        var val = fn ? fn(item, i) : item;
        if (val < currentVal) {
            current = item;
            currentVal = val;
        }
    });
    return currentVal;
};
Array.prototype.min = function (fn) {
    if (this.length == 0)
        return null;
    var current = this[0];
    var currentVal = fn ? fn(current) : current;
    this.forEach(item => {
        if (current == null) {
            current = item;
            return;
        }
        var val = fn ? fn(item) : item;
        if (val < currentVal) {
            current = item;
            currentVal = val;
        }
    });
    return current;
};


/***/ }),

/***/ "./node_modules/@hypertype/core/dist/esm/utils/Fn.js":
/*!***********************************************************!*\
  !*** ./node_modules/@hypertype/core/dist/esm/utils/Fn.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const crc32 = __webpack_require__(/*! crc-32 */ "./node_modules/crc-32/crc32.js");
exports.Fn = {
    I(x) {
        return x || null;
    },
    Ib(x) {
        return !!x;
    },
    Xor: ((x = null) => !x),
    Noop: () => undefined,
    False: () => false,
    True: () => true,
    Of(x) {
        return () => x;
    },
    Equal: x => y => x == y,
    NotEqual: x => y => x != y,
    Or: (x, y) => x || y,
    Class: x => function () {
        Object.assign(this, x);
    },
    Prop: prop => x => x[prop],
    Mult: k => x => x * k,
    Neg: x => -x,
    Cast() {
        return exports.Fn.I;
    },
    combine: (...functions) => {
        return (...args) => {
            return functions.map(f => f(...args)).pop();
        };
    },
    pipe: (...functions) => {
        return functions.reduce((f1, f2) => (...args) => f2(f1(...args)));
    },
    arrayEqual: (arr1, arr2) => {
        if (arr1.length != arr2.length)
            return false;
        return arr1.every((a, i) => a == arr2[i]);
    },
    cache() {
        return (target, key, descr) => {
            const existed = descr.value;
            const cacheSymbol = Symbol("cache");
            descr.value = function (id) {
                if (!this[cacheSymbol])
                    this[cacheSymbol] = {};
                return this[cacheSymbol][id] ||
                    (this[cacheSymbol][id] = existed.call(this, id));
            };
            return descr;
        };
    },
    crc32(value) {
        return crc32.str(JSON.stringify(value));
    }
};


/***/ }),

/***/ "./node_modules/@hypertype/core/dist/esm/utils/deepAssign.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@hypertype/core/dist/esm/utils/deepAssign.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function deepAssign(to, ...sources) {
    if (!sources.length)
        return to;
    return deepAssign(deepAssignInternal(to, sources[0] || {}), ...sources.slice(1));
}
exports.deepAssign = deepAssign;
function deepAssignInternal(to = {}, source) {
    if (!to)
        to = {};
    if (typeof source === "number")
        return source;
    if (typeof source === "string")
        return source;
    if (Array.isArray(source)) {
        return deepArrayAssign(to, source);
    }
    Object.keys(source).forEach(key => {
        to[key] = (source[key] && typeof source[key] === "object")
            ? deepAssignInternal(to[key], source[key])
            : source[key];
    });
    return to;
}
function deepArrayAssign(to, from) {
    return [
        ...from.map((t, i) => deepAssignInternal(to[i] || {}, from[i])),
        ...(Array.isArray(to) ? to.slice(from.length) : [])
    ];
}


/***/ }),

/***/ "./node_modules/@hypertype/core/dist/esm/utils/luxon.js":
/*!**************************************************************!*\
  !*** ./node_modules/@hypertype/core/dist/esm/utils/luxon.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const luxon_1 = __webpack_require__(/*! luxon */ "./node_modules/luxon/build/node/luxon.js");
exports.DateTime = luxon_1.DateTime;
exports.Duration = luxon_1.Duration;


/***/ }),

/***/ "./node_modules/@hypertype/core/dist/esm/utils/utc.js":
/*!************************************************************!*\
  !*** ./node_modules/@hypertype/core/dist/esm/utils/utc.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Created by xamidylin on 2017-01-23.
 */
const luxon_1 = __webpack_require__(/*! ./luxon */ "./node_modules/@hypertype/core/dist/esm/utils/luxon.js");
function utc(d = undefined) {
    if (typeof d === "string") {
        return luxon_1.DateTime.fromISO(d).toUTC();
    }
    if (typeof d === "number") {
        return luxon_1.DateTime.fromMillis(d, { zone: 'utc' });
    }
    if (d instanceof Date) {
        return luxon_1.DateTime.fromJSDate(d, { zone: 'utc' });
    }
    return luxon_1.DateTime.utc();
}
exports.utc = utc;
function utcToday() {
    return utc().startOf('day');
}
exports.utcToday = utcToday;


/***/ }),

/***/ "./node_modules/@hypertype/domain/dist/esm/helpers/DomainError.js":
/*!************************************************************************!*\
  !*** ./node_modules/@hypertype/domain/dist/esm/helpers/DomainError.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class DomainError extends Error {
    constructor(code, info) {
        super('Domain logic error');
        this.code = code;
        this.info = info;
    }
}
exports.DomainError = DomainError;
var DomainErrorCode;
(function (DomainErrorCode) {
    DomainErrorCode[DomainErrorCode["NotFound"] = 404] = "NotFound";
    DomainErrorCode[DomainErrorCode["Logic"] = 1] = "Logic";
})(DomainErrorCode = exports.DomainErrorCode || (exports.DomainErrorCode = {}));


/***/ }),

/***/ "./node_modules/@hypertype/domain/dist/esm/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@hypertype/domain/dist/esm/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./src/model.proxy */ "./node_modules/@hypertype/domain/dist/esm/src/model.proxy.js"));
__export(__webpack_require__(/*! ./src/model.stream */ "./node_modules/@hypertype/domain/dist/esm/src/model.stream.js"));
__export(__webpack_require__(/*! ./src/model */ "./node_modules/@hypertype/domain/dist/esm/src/model.js"));
__export(__webpack_require__(/*! ./src/webworker.entry */ "./node_modules/@hypertype/domain/dist/esm/src/webworker.entry.js"));
__export(__webpack_require__(/*! ./src/websocket.entry */ "./node_modules/@hypertype/domain/dist/esm/src/websocket.entry.js"));
__export(__webpack_require__(/*! ./src/container */ "./node_modules/@hypertype/domain/dist/esm/src/container.js"));
__export(__webpack_require__(/*! ./helpers/DomainError */ "./node_modules/@hypertype/domain/dist/esm/helpers/DomainError.js"));


/***/ }),

/***/ "./node_modules/@hypertype/domain/dist/esm/src/container.js":
/*!******************************************************************!*\
  !*** ./node_modules/@hypertype/domain/dist/esm/src/container.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const web_worker_model_stream_1 = __webpack_require__(/*! ./streams/web-worker-model.stream */ "./node_modules/@hypertype/domain/dist/esm/src/streams/web-worker-model.stream.js");
const model_stream_1 = __webpack_require__(/*! ./model.stream */ "./node_modules/@hypertype/domain/dist/esm/src/model.stream.js");
const core_1 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
const shared_worker_model_stream_1 = __webpack_require__(/*! ./streams/shared-worker-model.stream */ "./node_modules/@hypertype/domain/dist/esm/src/streams/shared-worker-model.stream.js");
const simple_model_stream_1 = __webpack_require__(/*! ./streams/simple-model.stream */ "./node_modules/@hypertype/domain/dist/esm/src/streams/simple-model.stream.js");
const web_socket_model_stream_1 = __webpack_require__(/*! ./streams/web-socket-model.stream */ "./node_modules/@hypertype/domain/dist/esm/src/streams/web-socket-model.stream.js");
const model_proxy_1 = __webpack_require__(/*! ./model.proxy */ "./node_modules/@hypertype/domain/dist/esm/src/model.proxy.js");
const model_1 = __webpack_require__(/*! ./model */ "./node_modules/@hypertype/domain/dist/esm/src/model.js");
const dev_tool_model_stream_1 = __webpack_require__(/*! ./streams/dev-tool-model.stream */ "./node_modules/@hypertype/domain/dist/esm/src/streams/dev-tool-model.stream.js");
const websocket_entry_1 = __webpack_require__(/*! ./websocket.entry */ "./node_modules/@hypertype/domain/dist/esm/src/websocket.entry.js");
const infr_1 = __webpack_require__(/*! @hypertype/infr */ "./node_modules/@hypertype/infr/dist/esm/common/index.js");
const BaseContainer = new core_1.Container();
BaseContainer.provide([
    { provide: model_proxy_1.ModelProxy, deps: [model_stream_1.ModelStream] },
    { provide: websocket_entry_1.WebsocketEntry, deps: [model_1.Model] },
]);
function getStreamProviders(devTools = false) {
    if (devTools) {
        return;
    }
}
exports.ProxyDomainContainer = {
    withSharedWorker(url = '/webworker.js', devTools = false) {
        const container = new core_1.Container();
        container.provide(BaseContainer);
        if (devTools) {
            container.provide([
                { provide: model_stream_1.ModelStream, useClass: dev_tool_model_stream_1.DevToolModelStream, deps: [shared_worker_model_stream_1.SharedWorkerModelStream, infr_1.StateLogger] },
                { provide: shared_worker_model_stream_1.SharedWorkerModelStream, deps: [web_worker_model_stream_1.UrlToken] },
                { provide: web_worker_model_stream_1.UrlToken, useValue: url },
            ]);
        }
        else {
            container.provide([
                { provide: model_stream_1.ModelStream, useClass: shared_worker_model_stream_1.SharedWorkerModelStream, deps: [web_worker_model_stream_1.UrlToken] },
                { provide: web_worker_model_stream_1.UrlToken, useValue: url },
            ]);
        }
        return container;
    },
    withWebWorker(url = '/webworker.js', devTools = false) {
        const container = new core_1.Container();
        container.provide(BaseContainer);
        if (devTools) {
            container.provide([
                { provide: model_stream_1.ModelStream, useClass: dev_tool_model_stream_1.DevToolModelStream, deps: [web_worker_model_stream_1.WebWorkerModelStream, infr_1.StateLogger] },
                { provide: web_worker_model_stream_1.WebWorkerModelStream, deps: [web_worker_model_stream_1.UrlToken] },
                { provide: web_worker_model_stream_1.UrlToken, useValue: url },
            ]);
        }
        else {
            container.provide([
                { provide: model_stream_1.ModelStream, useClass: web_worker_model_stream_1.WebWorkerModelStream, deps: [web_worker_model_stream_1.UrlToken] },
                { provide: web_worker_model_stream_1.UrlToken, useValue: url },
            ]);
        }
        return container;
    },
    withSimple(devTools = false) {
        const container = new core_1.Container();
        container.provide(BaseContainer);
        if (devTools) {
            container.provide([
                { provide: model_stream_1.ModelStream, useClass: dev_tool_model_stream_1.DevToolModelStream, deps: [simple_model_stream_1.SimpleModelStream, infr_1.StateLogger] },
                { provide: simple_model_stream_1.SimpleModelStream, deps: [model_1.Model] },
            ]);
        }
        else {
            container.provide([
                { provide: model_stream_1.ModelStream, useClass: simple_model_stream_1.SimpleModelStream, deps: [model_1.Model] },
            ]);
        }
        return container;
    },
    withWebSocket(url = '/domain/websocket', devTools = false) {
        const container = new core_1.Container();
        container.provide(BaseContainer);
        if (devTools) {
            container.provide([
                { provide: model_stream_1.ModelStream, useClass: dev_tool_model_stream_1.DevToolModelStream, deps: [web_socket_model_stream_1.WebSocketModelStream, infr_1.StateLogger] },
                { provide: web_socket_model_stream_1.WebSocketModelStream, deps: [web_worker_model_stream_1.UrlToken] },
                { provide: web_worker_model_stream_1.UrlToken, useValue: url },
            ]);
        }
        else {
            container.provide([
                { provide: model_stream_1.ModelStream, useClass: web_socket_model_stream_1.WebSocketModelStream, deps: [web_worker_model_stream_1.UrlToken] },
                { provide: web_worker_model_stream_1.UrlToken, useValue: url },
            ]);
        }
        return container;
    }
};


/***/ }),

/***/ "./node_modules/@hypertype/domain/dist/esm/src/model.js":
/*!**************************************************************!*\
  !*** ./node_modules/@hypertype/domain/dist/esm/src/model.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
class Model {
    constructor() {
        this.StateSubject$ = new core_1.Subject();
        this.State$ = this.StateSubject$.asObservable().pipe(core_1.startWith(null), core_1.map(() => this.ToJSON()), core_1.distinctUntilChanged(null, core_1.Fn.crc32), core_1.shareReplay(1));
        this.InvokeSubject$ = new core_1.Subject();
        this.Invoke$ = this.InvokeSubject$.pipe(core_1.switchMap(({ action, resolve, reject }) => {
            // console.log('action start', action.path, action.method, action.args);
            try {
                const res = this.GetSubActions(...(action.path || []))[action.method](...action.args);
                if (res.then) {
                    return res.then(result => {
                        // if (!result)
                        // this.Update();
                        resolve(result);
                    }).catch(reject);
                }
                else {
                    resolve(res);
                    return res;
                }
            }
            catch (e) {
                reject(e);
                // throw e;
            }
        }), core_1.tap(() => this.Update())).subscribe();
        this.Invoke = action => {
            return new Promise((resolve, reject) => this.InvokeSubject$.next(({ action, resolve, reject })));
        };
        this.Update = () => {
            this.StateSubject$.next();
        };
    }
    GetSubModel(...path) {
        const model = this.GetSubState(this, ...path);
        if (!model)
            return null;
        model.Update = this.Update;
        return model;
    }
    GetSubActions(...path) {
        return this.GetSubModel(...path);
    }
    GetSubState(state, ...path) {
        if (!state)
            return null;
        if (!path.length)
            return state;
        if (Array.isArray(state))
            return this.GetSubState(state.find(s => s.Id == path[0]), ...path.slice(1));
        return this.GetSubState(state[path[0]], ...path.slice(1));
    }
}
exports.Model = Model;


/***/ }),

/***/ "./node_modules/@hypertype/domain/dist/esm/src/model.proxy.js":
/*!********************************************************************!*\
  !*** ./node_modules/@hypertype/domain/dist/esm/src/model.proxy.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
class ModelProxy {
    constructor(stream, path = []) {
        this.stream = stream;
        this.path = path;
        this.ActionSubject = new core_1.Subject();
        this.ShareState$ = this.stream.State$.pipe(core_1.shareReplay(1));
        this.State$ = this.ActionSubject.pipe(core_1.startWith(null), core_1.switchMap(_ => this.ShareState$), core_1.distinctUntilChanged(null, core_1.Fn.crc32), core_1.map(state => this.GetSubState(state, this.path)), core_1.shareReplay(1));
        this.Actions = new Proxy({}, {
            get: (target, key, receiver) => {
                return target[key] || (target[key] = (async (...args) => {
                    try {
                        const res = await this.stream.Action({
                            path: this.path,
                            method: key,
                            args: args
                        });
                        return res;
                    }
                    catch (e) {
                        return Promise.reject(e);
                    }
                }));
            }
        });
    }
    GetSubProxy(constructor = ModelProxy, path, ...paths) {
        return new constructor(this.stream.SubStream(), [
            ...this.path,
            path,
            ...paths
        ]);
    }
    GetSubState(state, path) {
        if (!path.length || !state)
            return state;
        if (Array.isArray(state))
            return this.GetSubState(state.find(s => s.Id == path[0]), path.slice(1));
        return this.GetSubState(state[path[0]], path.slice(1));
    }
}
exports.ModelProxy = ModelProxy;


/***/ }),

/***/ "./node_modules/@hypertype/domain/dist/esm/src/model.stream.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@hypertype/domain/dist/esm/src/model.stream.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class ModelStream {
    SubStream() {
        return this;
    }
}
exports.ModelStream = ModelStream;


/***/ }),

/***/ "./node_modules/@hypertype/domain/dist/esm/src/streams/dev-tool-model.stream.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@hypertype/domain/dist/esm/src/streams/dev-tool-model.stream.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const model_stream_1 = __webpack_require__(/*! ../model.stream */ "./node_modules/@hypertype/domain/dist/esm/src/model.stream.js");
const core_1 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
class DevToolModelStream extends model_stream_1.ModelStream {
    constructor(stream, stateLogger) {
        super();
        this.stream = stream;
        this.stateLogger = stateLogger;
        this.State$ = this.stream.State$.pipe(core_1.debounceTime(10), core_1.tap(state => {
            this.lastState = state;
            this.stateLogger.send({ type: 'domain.new-state', payload: null }, state);
        }), core_1.shareReplay(1));
        this.Action = async (action) => {
            const result = await this.stream.Action(action);
            this.stateLogger.send({
                type: [
                    ...action.path,
                    action.method
                ].join(':'),
                payload: action.args,
                result: result
            }, this.lastState);
            return result;
        };
    }
}
exports.DevToolModelStream = DevToolModelStream;


/***/ }),

/***/ "./node_modules/@hypertype/domain/dist/esm/src/streams/shared-worker-model.stream.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@hypertype/domain/dist/esm/src/streams/shared-worker-model.stream.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const web_worker_model_stream_1 = __webpack_require__(/*! ./web-worker-model.stream */ "./node_modules/@hypertype/domain/dist/esm/src/streams/web-worker-model.stream.js");
class SharedWorkerModelStream extends web_worker_model_stream_1.WebWorkerModelStream {
    constructor(sharedWorkerPath) {
        super(sharedWorkerPath);
    }
    createWorker(path) {
        return new SharedWorker(path);
    }
}
exports.SharedWorkerModelStream = SharedWorkerModelStream;


/***/ }),

/***/ "./node_modules/@hypertype/domain/dist/esm/src/streams/simple-model.stream.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@hypertype/domain/dist/esm/src/streams/simple-model.stream.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const model_stream_1 = __webpack_require__(/*! ../model.stream */ "./node_modules/@hypertype/domain/dist/esm/src/model.stream.js");
class SimpleModelStream extends model_stream_1.ModelStream {
    constructor(model) {
        super();
        this.model = model;
        this.State$ = this.model.State$;
        this.Action = (action) => {
            return this.model.Invoke(action);
        };
    }
}
exports.SimpleModelStream = SimpleModelStream;


/***/ }),

/***/ "./node_modules/@hypertype/domain/dist/esm/src/streams/web-socket-model.stream.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@hypertype/domain/dist/esm/src/streams/web-socket-model.stream.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
const model_stream_1 = __webpack_require__(/*! ../model.stream */ "./node_modules/@hypertype/domain/dist/esm/src/model.stream.js");
class WebSocketModelStream extends model_stream_1.ModelStream {
    constructor(webSocketPath) {
        super();
        this.Action = (action) => {
            this.ws.send(JSON.stringify(action));
        };
        this.ws = new WebSocket(webSocketPath);
        this.ws.binaryType = 'arraybuffer';
        this.State$ = core_1.fromEvent(this.ws, 'message').pipe(
        // tap(console.log),
        core_1.map(e => e.data), core_1.map(s => JSON.parse(s)));
    }
}
exports.WebSocketModelStream = WebSocketModelStream;


/***/ }),

/***/ "./node_modules/@hypertype/domain/dist/esm/src/streams/web-worker-model.stream.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@hypertype/domain/dist/esm/src/streams/web-worker-model.stream.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const model_stream_1 = __webpack_require__(/*! ../model.stream */ "./node_modules/@hypertype/domain/dist/esm/src/model.stream.js");
const core_1 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
exports.UrlToken = new core_1.InjectionToken('webworker');
class WebWorkerModelStream extends model_stream_1.ModelStream {
    constructor(webSocketPath) {
        super();
        // =>  Browser Main   ->  Worker
        this.Action = (action) => {
            const id = +performance.now();
            this.worker.postMessage({
                ...action,
                _id: id
            }, ('OffscreenCanvas' in window) ? action.args.filter(a => {
                return (a instanceof OffscreenCanvas);
            }) : []);
            return this.Input$.pipe(core_1.filter(d => d.requestId == id), core_1.mergeMap(d => d.error ? core_1.throwError(d.error) : core_1.of(d.response)), core_1.first()).toPromise();
        };
        this.worker = this.createWorker(webSocketPath);
        // =>  Worker   ->  Browser Main
        this.Input$ = core_1.fromEvent(this.worker, 'message').pipe(core_1.map(e => e.data), core_1.shareReplay(1));
        this.State$ = this.Input$.pipe(core_1.map(d => d.state), core_1.filter(core_1.Fn.Ib));
        this.State$.subscribe();
    }
    createWorker(path) {
        return new Worker(path);
    }
}
exports.WebWorkerModelStream = WebWorkerModelStream;


/***/ }),

/***/ "./node_modules/@hypertype/domain/dist/esm/src/websocket.entry.js":
/*!************************************************************************!*\
  !*** ./node_modules/@hypertype/domain/dist/esm/src/websocket.entry.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
class WebsocketEntry {
    constructor(model) {
        this.model = model;
        this.Output$ = this.model.State$.pipe(core_1.map(s => JSON.stringify(s)), core_1.shareReplay(1));
        this.InputSubject$ = new core_1.ReplaySubject();
        this.Input$ = this.InputSubject$.asObservable().pipe(core_1.map((d) => JSON.parse(d)), core_1.tap(console.log), core_1.catchError(e => core_1.of(null)), core_1.filter(d => d.type), core_1.shareReplay(1));
        this.onMessage = data => {
            const action = JSON.parse(data);
            this.model.Invoke(action);
        };
    }
}
exports.WebsocketEntry = WebsocketEntry;


/***/ }),

/***/ "./node_modules/@hypertype/domain/dist/esm/src/webworker.entry.js":
/*!************************************************************************!*\
  !*** ./node_modules/@hypertype/domain/dist/esm/src/webworker.entry.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
const model_1 = __webpack_require__(/*! ./model */ "./node_modules/@hypertype/domain/dist/esm/src/model.js");
class WebworkerEntry {
    constructor(model) {
        this.model = model;
        this.Responses$ = new core_1.ReplaySubject();
        this.Output$ = core_1.merge(this.model.State$.pipe(core_1.map(d => ({ state: d }))), this.Responses$.asObservable()).pipe(core_1.shareReplay(1));
        // =>  Browser Main   ->  Worker
        this.onMessage = (e) => {
            const request = e.data;
            this.model.Invoke(e.data)
                .then(result => this.Responses$.next({
                response: result,
                requestId: request._id
            }))
                .catch(e => this.Responses$.next({
                error: e,
                requestId: request._id
            }));
        };
    }
    static Start(self, container) {
        const aggregate = container.get(model_1.Model);
        const service = new WebworkerEntry(aggregate);
        if (self.postMessage) {
            self.addEventListener('message', service.onMessage);
            // =>  Worker   ->  Browser Main
            service.Output$.subscribe(d => {
                try {
                    self.postMessage(d);
                }
                catch (e) {
                    console.error(`Failed to sent via web worker`, d);
                }
            });
        }
        // shared worker
        if ('onconnect' in self) {
            self['onconnect'] = function (e) {
                const port = e.ports[0];
                port.addEventListener('message', service.onMessage);
                service.Output$.subscribe(d => {
                    port.postMessage(d);
                });
                port.start();
            };
        }
    }
}
exports.WebworkerEntry = WebworkerEntry;


/***/ }),

/***/ "./node_modules/@hypertype/infr-browser/dist/esm/browser.web-socket.service.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@hypertype/infr-browser/dist/esm/browser.web-socket.service.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const infr_1 = __webpack_require__(/*! @hypertype/infr */ "./node_modules/@hypertype/infr/dist/esm/common/index.js");
const core_1 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
let BrowserWebSocketService = class BrowserWebSocketService extends infr_1.BaseWebSocketService {
    constructor(url, api, tokenStore) {
        super(url, api, tokenStore);
    }
    getConfig() {
        return {
            transport: infr_1.HttpTransportType.WebSockets,
            WebSocket: WebSocket,
            EventSource: EventSource
        };
    }
};
BrowserWebSocketService = __decorate([
    core_1.Injectable(),
    __param(0, core_1.Inject(infr_1.WebSocketUrlInjectionToken)),
    __metadata("design:paramtypes", [Object, infr_1.ApiHttpClient,
        infr_1.ITokenStore])
], BrowserWebSocketService);
exports.BrowserWebSocketService = BrowserWebSocketService;


/***/ }),

/***/ "./node_modules/@hypertype/infr-browser/dist/esm/dev-tools.state-logger.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@hypertype/infr-browser/dist/esm/dev-tools.state-logger.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const infr_1 = __webpack_require__(/*! @hypertype/infr */ "./node_modules/@hypertype/infr/dist/esm/common/index.js");
const devToolsName = '__REDUX_DEVTOOLS_EXTENSION__';
class DevToolsStateLogger extends infr_1.StateLogger {
    constructor() {
        super();
        if (window[devToolsName]) {
            this.devTools = window[devToolsName].connect({
                name: document.title
            });
            this.devTools.init();
        }
    }
    send({ type, payload }, state) {
        if (this.devTools) {
            this.devTools.send({
                type, payload
            }, state);
        }
    }
}
exports.DevToolsStateLogger = DevToolsStateLogger;


/***/ }),

/***/ "./node_modules/@hypertype/infr-browser/dist/esm/fetchRequestService.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@hypertype/infr-browser/dist/esm/fetchRequestService.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
class FetchRequestService {
    request(method, url, body = null, options = {}) {
        if (options.params) {
            url += '?' + Object.entries(options.params).map(([key, value]) => `${key}=${value}`).join('&');
        }
        return core_1.from(fetch(url, {
            method: method,
            body: body && JSON.stringify(body),
            headers: {
                'Content-Type': 'application/json',
                ...options.headers,
            }
        })
            .then(t => {
            if (t.status >= 300) {
                throw {
                    code: t.status,
                    message: t.text()
                };
            }
            // if (+t.headers.get('Content-Length') == 0) {
            //     return of('');
            // }
            if (options.responseType == "blob")
                return t.blob();
            if (/json/.test(t.headers.get('Content-Type'))) {
                return t.json();
            }
            return t.text();
        }));
    }
}
exports.FetchRequestService = FetchRequestService;


/***/ }),

/***/ "./node_modules/@hypertype/infr-browser/dist/esm/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@hypertype/infr-browser/dist/esm/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
const infr_1 = __webpack_require__(/*! @hypertype/infr */ "./node_modules/@hypertype/infr/dist/esm/common/index.js");
const fetchRequestService_1 = __webpack_require__(/*! ./fetchRequestService */ "./node_modules/@hypertype/infr-browser/dist/esm/fetchRequestService.js");
exports.FetchRequestService = fetchRequestService_1.FetchRequestService;
const browser_web_socket_service_1 = __webpack_require__(/*! ./browser.web-socket.service */ "./node_modules/@hypertype/infr-browser/dist/esm/browser.web-socket.service.js");
const dev_tools_state_logger_1 = __webpack_require__(/*! ./dev-tools.state-logger */ "./node_modules/@hypertype/infr-browser/dist/esm/dev-tools.state-logger.js");
exports.DevToolsStateLogger = dev_tools_state_logger_1.DevToolsStateLogger;
exports.BrowserContainer = new core_1.Container();
exports.BrowserContainer.provide(infr_1.InfrContainer);
exports.BrowserContainer.provide([
    { provide: infr_1.StateLogger, useClass: dev_tools_state_logger_1.DevToolsStateLogger },
    { provide: infr_1.IRequestService, useClass: fetchRequestService_1.FetchRequestService },
    { provide: infr_1.IWebSocketService, useClass: browser_web_socket_service_1.BrowserWebSocketService },
]);


/***/ }),

/***/ "./node_modules/@hypertype/infr/dist/esm/common/api-http.client.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@hypertype/infr/dist/esm/common/api-http.client.js ***!
  \*************************************************************************/
/*! exports provided: ApiHttpClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ApiHttpClient", function() { return ApiHttpClient; });
/* harmony import */ var _signalr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./signalr */ "./node_modules/@hypertype/infr/dist/esm/common/signalr/index.js");
/* harmony import */ var _api_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./api.service */ "./node_modules/@hypertype/infr/dist/esm/common/api.service.js");
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_hypertype_core__WEBPACK_IMPORTED_MODULE_2__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



let ApiHttpClient = class ApiHttpClient extends _signalr__WEBPACK_IMPORTED_MODULE_0__["HttpClient"] {
    constructor(apiService) {
        super();
        this.apiService = apiService;
    }
    send(request) {
        return this.apiService.request(request.method, request.url, request.content, {
            headers: request.headers,
        }).toPromise()
            .then(res => new _signalr__WEBPACK_IMPORTED_MODULE_0__["HttpResponse"](200, 'OK', JSON.stringify(res)))
            .catch(err => new _signalr__WEBPACK_IMPORTED_MODULE_0__["HttpResponse"](err.code, err.message, err));
    }
};
ApiHttpClient = __decorate([
    Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_2__["Injectable"])(),
    __metadata("design:paramtypes", [_api_service__WEBPACK_IMPORTED_MODULE_1__["ApiService"]])
], ApiHttpClient);



/***/ }),

/***/ "./node_modules/@hypertype/infr/dist/esm/common/api.service.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@hypertype/infr/dist/esm/common/api.service.js ***!
  \*********************************************************************/
/*! exports provided: ApiUrlInjectionToken, ApiService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ApiUrlInjectionToken", function() { return ApiUrlInjectionToken; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ApiService", function() { return ApiService; });
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_hypertype_core__WEBPACK_IMPORTED_MODULE_0__);

const ApiUrlInjectionToken = new _hypertype_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('apiUrl');
class ApiService {
    constructor(http, ApiUrl) {
        this.http = http;
        this.ApiUrl = ApiUrl;
        // protected http: IRequestService;
        this.isBSON = false;
        this.loadingCounter = 0;
        this.loadingSubject$ = new _hypertype_core__WEBPACK_IMPORTED_MODULE_0__["ReplaySubject"]();
        this.Loading$ = this.loadingSubject$.asObservable().pipe(
        // map(d => d != 0),
        Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_0__["startWith"])(0));
        this.processResult = (body) => {
            if (!this.isBSON) {
                return Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_0__["of"])(body);
            }
            const fileReader = new FileReader();
            fileReader.readAsArrayBuffer(body);
            return Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_0__["fromEvent"])(fileReader, 'loadend').pipe(Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_0__["map"])(_ => fileReader.result), Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_0__["map"])(array => new Uint8Array(array)));
        };
    }
    get(url, options = {}) {
        return this.request('GET', url, null, options);
    }
    post(url, body, options = {}) {
        return this.request('POST', url, body, options);
    }
    delete(url) {
        return this.request('DELETE', url);
    }
    put(url, body, options = {}) {
        return this.request('PUT', url, body, options);
    }
    request(method, url, body = null, options = {}) {
        //WTF?
        if (!/accessTime/.test(url)) {
            this.loadingCounter++;
            this.loadingSubject$.next(this.loadingCounter);
        }
        if (!/^(http|ws)s?:\/\//.test(url))
            url = this.ApiUrl.toString() + url;
        const res = this.http.request(method, url, body, {
            headers: {
                ...(options.headers || {}),
                'Accept': this.isBSON ? 'application/bson' : 'application/json'
            },
            params: options.params,
            responseType: options.responseType || (this.isBSON ? 'blob' : 'json')
        }).pipe(
        // filter(event => {
        //   return (event instanceof HttpResponse);
        // }),
        // map(event => (<HttpResponse<Blob>>event).body),
        Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_0__["tap"])(() => {
            this.loadingCounter--;
            this.loadingSubject$.next(this.loadingCounter);
        }), Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_0__["catchError"])(e => {
            this.loadingCounter--;
            this.loadingSubject$.next(this.loadingCounter);
            return Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_0__["throwError"])(e);
        }), Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_0__["mergeMap"])(this.processResult));
        return res;
    }
}


/***/ }),

/***/ "./node_modules/@hypertype/infr/dist/esm/common/auth-api.service.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@hypertype/infr/dist/esm/common/auth-api.service.js ***!
  \**************************************************************************/
/*! exports provided: AuthApiService, ITokenStore */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AuthApiService", function() { return AuthApiService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ITokenStore", function() { return ITokenStore; });
/* harmony import */ var _api_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api.service */ "./node_modules/@hypertype/infr/dist/esm/common/api.service.js");

function camelCase(value) {
    if (Array.isArray(value)) {
        return value.map(camelCase);
    }
    if (typeof value === "object" && value != null) {
        return Object.entries(value).reduce((obj, [key, value]) => {
            obj[key[0].toUpperCase() + key.substr(1)] = camelCase(value);
            return obj;
        }, {});
    }
    return value;
}
class AuthApiService extends _api_service__WEBPACK_IMPORTED_MODULE_0__["ApiService"] {
    constructor(http, ApiUrl, tokenStore) {
        super(http, ApiUrl);
        this.tokenStore = tokenStore;
    }
    request(method, url, body = null, options = {}) {
        return super.request(method, url, body, {
            ...options,
            headers: {
                ...(options.headers || {}),
                Authorization: `Bearer ${this.tokenStore.get()}`
            }
        }).pipe(
        // map(t => t && camelCase<T>(t))
        );
    }
}
class ITokenStore {
}


/***/ }),

/***/ "./node_modules/@hypertype/infr/dist/esm/common/base-web-socket.service.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@hypertype/infr/dist/esm/common/base-web-socket.service.js ***!
  \*********************************************************************************/
/*! exports provided: BaseWebSocketService, WebSocketHub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseWebSocketService", function() { return BaseWebSocketService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebSocketHub", function() { return WebSocketHub; });
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_hypertype_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _i_web_socket_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./i-web-socket.service */ "./node_modules/@hypertype/infr/dist/esm/common/i-web-socket.service.js");
/* harmony import */ var _signalr_contracts_ILogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./signalr/contracts/ILogger */ "./node_modules/@hypertype/infr/dist/esm/common/signalr/contracts/ILogger.js");
/* harmony import */ var _signalr_HubConnectionBuilder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./signalr/HubConnectionBuilder */ "./node_modules/@hypertype/infr/dist/esm/common/signalr/HubConnectionBuilder.js");




class BaseWebSocketService extends _i_web_socket_service__WEBPACK_IMPORTED_MODULE_1__["IWebSocketService"] {
    constructor(url = "http://localhost:8888/inventory", api, tokenStore) {
        super();
        this.url = url;
        this.api = api;
        this.tokenStore = tokenStore;
        this.connectionSubject$ = new _hypertype_core__WEBPACK_IMPORTED_MODULE_0__["ReplaySubject"](1);
        this.connection$ = this.connectionSubject$.asObservable().pipe(Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_0__["filter"])(_hypertype_core__WEBPACK_IMPORTED_MODULE_0__["Fn"].Ib));
        this.isInit = false;
    }
    Hub(hub) {
        if (!this.isInit)
            this.initConnection();
        return new WebSocketHub(this.connection$, hub);
    }
    send(method, ...params) {
        return this.connection$.pipe(Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_0__["first"])()).toPromise()
            .then(connection => connection.start().then(() => {
            return connection.invoke(method, ...params);
        }));
    }
    initConnection(tryCounter = 0) {
        const config = {
            ...this.getConfig(),
            httpClient: this.api,
            accessTokenFactory: () => {
                return this.tokenStore.get();
            }
        };
        const connection = new _signalr_HubConnectionBuilder__WEBPACK_IMPORTED_MODULE_3__["HubConnectionBuilder"]()
            .withUrl(this.url, config)
            .configureLogging({
            log: (type, message) => {
                if (type >= _signalr_contracts_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Error) {
                    connection.stop().catch();
                    // this.restartConnection(connection);
                }
            }
        })
            .build();
        connection.start().catch(e => {
            this.restartConnection(tryCounter + 1);
        });
        connection.onclose(e => {
            this.restartConnection();
        });
        this.connectionSubject$.next(connection);
        this.isInit = true;
    }
    restartConnection(tryCounter = 1) {
        this.connectionSubject$.next(null);
        console.warn('disconnected, try: ', tryCounter);
        setTimeout(() => {
            //   this.initConnection(tryCounter);
        }, tryCounter * 1000);
    }
}
class WebSocketHub {
    constructor(connection, hub) {
        this.connection = connection;
        this.messagesSubject = new _hypertype_core__WEBPACK_IMPORTED_MODULE_0__["ReplaySubject"]();
        this.messages$ = this.messagesSubject.asObservable().pipe(Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_0__["shareReplay"])(1));
        this.connection.subscribe(connection => connection.on(hub, (...params) => {
            this.messagesSubject.next(params);
        }));
    }
}


/***/ }),

/***/ "./node_modules/@hypertype/infr/dist/esm/common/i-web-socket.service.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@hypertype/infr/dist/esm/common/i-web-socket.service.js ***!
  \******************************************************************************/
/*! exports provided: IWebSocketService, WebSocketUrlInjectionToken */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IWebSocketService", function() { return IWebSocketService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebSocketUrlInjectionToken", function() { return WebSocketUrlInjectionToken; });
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_hypertype_core__WEBPACK_IMPORTED_MODULE_0__);

class IWebSocketService {
}
const WebSocketUrlInjectionToken = new _hypertype_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('WebSocketUrlInjectionToken');


/***/ }),

/***/ "./node_modules/@hypertype/infr/dist/esm/common/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@hypertype/infr/dist/esm/common/index.js ***!
  \***************************************************************/
/*! exports provided: BaseWebSocketService, InfrContainer, AuthContainer, ITokenStore, WebSocketUrlInjectionToken, ApiHttpClient, Logger, LoggerLevel, ApiUrlInjectionToken, ApiService, IRequestService, IWebSocketService, StateLogger, HttpTransportType, HttpClient, HttpResponse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InfrContainer", function() { return InfrContainer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AuthContainer", function() { return AuthContainer; });
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logger */ "./node_modules/@hypertype/infr/dist/esm/common/logger.js");
/* harmony import */ var _api_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./api.service */ "./node_modules/@hypertype/infr/dist/esm/common/api.service.js");
/* harmony import */ var _request_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./request.service */ "./node_modules/@hypertype/infr/dist/esm/common/request.service.js");
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_hypertype_core__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _i_web_socket_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./i-web-socket.service */ "./node_modules/@hypertype/infr/dist/esm/common/i-web-socket.service.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebSocketUrlInjectionToken", function() { return _i_web_socket_service__WEBPACK_IMPORTED_MODULE_4__["WebSocketUrlInjectionToken"]; });

/* harmony import */ var _auth_api_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./auth-api.service */ "./node_modules/@hypertype/infr/dist/esm/common/auth-api.service.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ITokenStore", function() { return _auth_api_service__WEBPACK_IMPORTED_MODULE_5__["ITokenStore"]; });

/* harmony import */ var _api_http_client__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./api-http.client */ "./node_modules/@hypertype/infr/dist/esm/common/api-http.client.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ApiHttpClient", function() { return _api_http_client__WEBPACK_IMPORTED_MODULE_6__["ApiHttpClient"]; });

/* harmony import */ var _base_web_socket_service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./base-web-socket.service */ "./node_modules/@hypertype/infr/dist/esm/common/base-web-socket.service.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BaseWebSocketService", function() { return _base_web_socket_service__WEBPACK_IMPORTED_MODULE_7__["BaseWebSocketService"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Logger", function() { return _logger__WEBPACK_IMPORTED_MODULE_0__["Logger"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LoggerLevel", function() { return _logger__WEBPACK_IMPORTED_MODULE_0__["LoggerLevel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ApiUrlInjectionToken", function() { return _api_service__WEBPACK_IMPORTED_MODULE_1__["ApiUrlInjectionToken"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ApiService", function() { return _api_service__WEBPACK_IMPORTED_MODULE_1__["ApiService"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IRequestService", function() { return _request_service__WEBPACK_IMPORTED_MODULE_2__["IRequestService"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IWebSocketService", function() { return _i_web_socket_service__WEBPACK_IMPORTED_MODULE_4__["IWebSocketService"]; });

/* harmony import */ var _state_logger__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./state.logger */ "./node_modules/@hypertype/infr/dist/esm/common/state.logger.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StateLogger", function() { return _state_logger__WEBPACK_IMPORTED_MODULE_8__["StateLogger"]; });

/* harmony import */ var _signalr__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./signalr */ "./node_modules/@hypertype/infr/dist/esm/common/signalr/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HttpTransportType", function() { return _signalr__WEBPACK_IMPORTED_MODULE_9__["HttpTransportType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HttpClient", function() { return _signalr__WEBPACK_IMPORTED_MODULE_9__["HttpClient"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HttpResponse", function() { return _signalr__WEBPACK_IMPORTED_MODULE_9__["HttpResponse"]; });














const InfrContainer = new _hypertype_core__WEBPACK_IMPORTED_MODULE_3__["Container"]();
InfrContainer.provide([
    _api_http_client__WEBPACK_IMPORTED_MODULE_6__["ApiHttpClient"],
    { provide: _logger__WEBPACK_IMPORTED_MODULE_0__["Logger"] },
    {
        provide: _auth_api_service__WEBPACK_IMPORTED_MODULE_5__["ITokenStore"], useValue: {
            get() {
                return null;
            }, set() {
            }
        }
    },
    { provide: _api_service__WEBPACK_IMPORTED_MODULE_1__["ApiService"], deps: [_request_service__WEBPACK_IMPORTED_MODULE_2__["IRequestService"], _api_service__WEBPACK_IMPORTED_MODULE_1__["ApiUrlInjectionToken"]] },
    { provide: _api_service__WEBPACK_IMPORTED_MODULE_1__["ApiUrlInjectionToken"], useValue: 'http://localhost/api' },
    { provide: _i_web_socket_service__WEBPACK_IMPORTED_MODULE_4__["WebSocketUrlInjectionToken"], useValue: 'http://localhost/inventory' },
]);
const AuthContainer = new _hypertype_core__WEBPACK_IMPORTED_MODULE_3__["Container"]();
AuthContainer.provide(InfrContainer);
AuthContainer.provide([
    { provide: _api_service__WEBPACK_IMPORTED_MODULE_1__["ApiService"], useClass: _auth_api_service__WEBPACK_IMPORTED_MODULE_5__["AuthApiService"], deps: [_request_service__WEBPACK_IMPORTED_MODULE_2__["IRequestService"], _api_service__WEBPACK_IMPORTED_MODULE_1__["ApiUrlInjectionToken"], _auth_api_service__WEBPACK_IMPORTED_MODULE_5__["ITokenStore"]] }
]);




/***/ }),

/***/ "./node_modules/@hypertype/infr/dist/esm/common/logger.js":
/*!****************************************************************!*\
  !*** ./node_modules/@hypertype/infr/dist/esm/common/logger.js ***!
  \****************************************************************/
/*! exports provided: Logger, LoggerLevel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Logger", function() { return Logger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoggerLevel", function() { return LoggerLevel; });
class Logger {
    send(data) {
    }
    sendMessage(data, level) {
        if (typeof data === 'string') {
            this.send({
                message: data,
                level: level
            });
        }
        else {
            this.send({
                ...data,
                level: level
            });
        }
    }
    error(data) {
        this.sendMessage(data, LoggerLevel.Error);
    }
    success(data) {
        this.sendMessage(data, LoggerLevel.Success);
    }
    info(data) {
        this.sendMessage(data, LoggerLevel.Info);
    }
    debug(data) {
        this.sendMessage(data, LoggerLevel.Debug);
    }
    warning(data) {
        this.sendMessage(data, LoggerLevel.Warning);
    }
    failure(data) {
        this.sendMessage(data, LoggerLevel.Failure);
    }
}
var LoggerLevel;
(function (LoggerLevel) {
    LoggerLevel[LoggerLevel["Info"] = -1] = "Info";
    LoggerLevel[LoggerLevel["Debug"] = 0] = "Debug";
    LoggerLevel[LoggerLevel["Warning"] = 1] = "Warning";
    LoggerLevel[LoggerLevel["Error"] = 2] = "Error";
    LoggerLevel[LoggerLevel["Failure"] = 3] = "Failure";
    LoggerLevel[LoggerLevel["Success"] = 4] = "Success";
})(LoggerLevel || (LoggerLevel = {}));


/***/ }),

/***/ "./node_modules/@hypertype/infr/dist/esm/common/request.service.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@hypertype/infr/dist/esm/common/request.service.js ***!
  \*************************************************************************/
/*! exports provided: IRequestService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IRequestService", function() { return IRequestService; });
class IRequestService {
}


/***/ }),

/***/ "./node_modules/@hypertype/infr/dist/esm/common/signalr/HandshakeProtocol.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@hypertype/infr/dist/esm/common/signalr/HandshakeProtocol.js ***!
  \***********************************************************************************/
/*! exports provided: HandshakeProtocol */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HandshakeProtocol", function() { return HandshakeProtocol; });
/* harmony import */ var _TextMessageFormat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TextMessageFormat */ "./node_modules/@hypertype/infr/dist/esm/common/signalr/TextMessageFormat.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ "./node_modules/@hypertype/infr/dist/esm/common/signalr/Utils.js");
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.


/** @private */
class HandshakeProtocol {
    // Handshake request is always JSON
    writeHandshakeRequest(handshakeRequest) {
        return _TextMessageFormat__WEBPACK_IMPORTED_MODULE_0__["TextMessageFormat"].write(JSON.stringify(handshakeRequest));
    }
    parseHandshakeResponse(data) {
        let responseMessage;
        let messageData;
        let remainingData;
        if (Object(_Utils__WEBPACK_IMPORTED_MODULE_1__["isArrayBuffer"])(data) || (typeof Buffer !== "undefined" && data instanceof Buffer)) {
            // Format is binary but still need to read JSON text from handshake response
            const binaryData = new Uint8Array(data);
            const separatorIndex = binaryData.indexOf(_TextMessageFormat__WEBPACK_IMPORTED_MODULE_0__["TextMessageFormat"].RecordSeparatorCode);
            if (separatorIndex === -1) {
                throw new Error("Message is incomplete.");
            }
            // content before separator is handshake response
            // optional content after is additional messages
            const responseLength = separatorIndex + 1;
            messageData = String.fromCharCode.apply(null, binaryData.slice(0, responseLength));
            remainingData = (binaryData.byteLength > responseLength) ? binaryData.slice(responseLength).buffer : null;
        }
        else {
            const textData = data;
            const separatorIndex = textData.indexOf(_TextMessageFormat__WEBPACK_IMPORTED_MODULE_0__["TextMessageFormat"].RecordSeparator);
            if (separatorIndex === -1) {
                throw new Error("Message is incomplete.");
            }
            // content before separator is handshake response
            // optional content after is additional messages
            const responseLength = separatorIndex + 1;
            messageData = textData.substring(0, responseLength);
            remainingData = (textData.length > responseLength) ? textData.substring(responseLength) : null;
        }
        // At this point we should have just the single handshake message
        const messages = _TextMessageFormat__WEBPACK_IMPORTED_MODULE_0__["TextMessageFormat"].parse(messageData);
        const response = JSON.parse(messages[0]);
        if (response.type) {
            throw new Error("Expected a handshake response from the server.");
        }
        responseMessage = response;
        // multiple messages could have arrived with handshake
        // return additional data to be parsed as usual, or null if all parsed
        return [remainingData, responseMessage];
    }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@hypertype/infr/dist/esm/common/signalr/HttpClient.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@hypertype/infr/dist/esm/common/signalr/HttpClient.js ***!
  \****************************************************************************/
/*! exports provided: HttpResponse, HttpClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HttpResponse", function() { return HttpResponse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HttpClient", function() { return HttpClient; });
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
/** Represents an HTTP response. */
class HttpResponse {
    constructor(statusCode, statusText, content) {
        this.statusCode = statusCode;
        this.statusText = statusText;
        this.content = content;
    }
}
/** Abstraction over an HTTP client.
 *
 * This class provides an abstraction over an HTTP client so that a different implementation can be provided on different platforms.
 */
class HttpClient {
    get(url, options) {
        return this.send({
            ...options,
            method: "GET",
            url,
        });
    }
    post(url, options) {
        return this.send({
            ...options,
            method: "POST",
            url,
        });
    }
    delete(url, options) {
        return this.send({
            ...options,
            method: "DELETE",
            url,
        });
    }
    /** Gets all cookies that apply to the specified URL.
     *
     * @param url The URL that the cookies are valid for.
     * @returns {string} A string containing all the key-value cookie pairs for the specified URL.
     */
    // @ts-ignore
    getCookieString(url) {
        return "";
    }
}


/***/ }),

/***/ "./node_modules/@hypertype/infr/dist/esm/common/signalr/HttpConnection.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@hypertype/infr/dist/esm/common/signalr/HttpConnection.js ***!
  \********************************************************************************/
/*! exports provided: HttpConnection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HttpConnection", function() { return HttpConnection; });
/* harmony import */ var _contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./contracts/ILogger */ "./node_modules/@hypertype/infr/dist/esm/common/signalr/contracts/ILogger.js");
/* harmony import */ var _contracts_ITransport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contracts/ITransport */ "./node_modules/@hypertype/infr/dist/esm/common/signalr/contracts/ITransport.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils */ "./node_modules/@hypertype/infr/dist/esm/common/signalr/Utils.js");
/* harmony import */ var _WebSocketTransport__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WebSocketTransport */ "./node_modules/@hypertype/infr/dist/esm/common/signalr/WebSocketTransport.js");
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.




const MAX_REDIRECTS = 100;
/** @private */
class HttpConnection {
    constructor(url, options = {}) {
        this.features = {};
        _Utils__WEBPACK_IMPORTED_MODULE_2__["Arg"].isRequired(url, "url");
        this.logger = Object(_Utils__WEBPACK_IMPORTED_MODULE_2__["createLogger"])(options.logger);
        this.baseUrl = this.resolveUrl(url);
        options = options || {};
        options.logMessageContent = options.logMessageContent || false;
        this.httpClient = options.httpClient;
        this.connectionState = 2 /* Disconnected */;
        this.options = options;
        this.onreceive = null;
        this.onclose = null;
    }
    start(transferFormat) {
        transferFormat = transferFormat || _contracts_ITransport__WEBPACK_IMPORTED_MODULE_1__["TransferFormat"].Binary;
        _Utils__WEBPACK_IMPORTED_MODULE_2__["Arg"].isIn(transferFormat, _contracts_ITransport__WEBPACK_IMPORTED_MODULE_1__["TransferFormat"], "transferFormat");
        this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Debug, `Starting connection with transfer format '${_contracts_ITransport__WEBPACK_IMPORTED_MODULE_1__["TransferFormat"][transferFormat]}'.`);
        if (this.connectionState !== 2 /* Disconnected */) {
            return Promise.reject(new Error("Cannot start a connection that is not in the 'Disconnected' state."));
        }
        this.connectionState = 0 /* Connecting */;
        this.startPromise = this.startInternal(transferFormat);
        return this.startPromise;
    }
    send(data) {
        if (this.connectionState !== 1 /* Connected */) {
            throw new Error("Cannot send data if the connection is not in the 'Connected' State.");
        }
        // Transport will not be null if state is connected
        return this.transport.send(data);
    }
    async stop(error) {
        this.connectionState = 2 /* Disconnected */;
        // Set error as soon as possible otherwise there is a race between
        // the transport closing and providing an error and the error from a close message
        // We would prefer the close message error.
        this.stopError = error;
        try {
            await this.startPromise;
        }
        catch (e) {
            // this exception is returned to the user as a rejected Promise from the start method
        }
        // The transport's onclose will trigger stopConnection which will run our onclose event.
        if (this.transport) {
            await this.transport.stop();
            this.transport = undefined;
        }
    }
    async startInternal(transferFormat) {
        // Store the original base url and the access token factory since they may change
        // as part of negotiating
        let url = this.baseUrl;
        this.accessTokenFactory = this.options.accessTokenFactory;
        try {
            if (this.options.skipNegotiation) {
                if (this.options.transport === _contracts_ITransport__WEBPACK_IMPORTED_MODULE_1__["HttpTransportType"].WebSockets) {
                    // No need to add a connection ID in this case
                    this.transport = this.constructTransport(_contracts_ITransport__WEBPACK_IMPORTED_MODULE_1__["HttpTransportType"].WebSockets);
                    // We should just call connect directly in this case.
                    // No fallback or negotiate in this case.
                    await this.transport.connect(url, transferFormat);
                }
                else {
                    throw Error("Negotiation can only be skipped when using the WebSocket transport directly.");
                }
            }
            else {
                let negotiateResponse = null;
                let redirects = 0;
                do {
                    negotiateResponse = await this.getNegotiationResponse(url);
                    // the user tries to stop the connection when it is being started
                    if (this.connectionState === 2 /* Disconnected */) {
                        return;
                    }
                    if (negotiateResponse.error) {
                        throw Error(negotiateResponse.error);
                    }
                    if (negotiateResponse.ProtocolVersion) {
                        throw Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.");
                    }
                    if (negotiateResponse.url) {
                        url = negotiateResponse.url;
                    }
                    if (negotiateResponse.accessToken) {
                        // Replace the current access token factory with one that uses
                        // the returned access token
                        const accessToken = negotiateResponse.accessToken;
                        this.accessTokenFactory = () => accessToken;
                    }
                    redirects++;
                } while (negotiateResponse.url && redirects < MAX_REDIRECTS);
                if (redirects === MAX_REDIRECTS && negotiateResponse.url) {
                    throw Error("Negotiate redirection limit exceeded.");
                }
                await this.createTransport(url, this.options.transport, negotiateResponse, transferFormat);
            }
            // if (this.transport instanceof LongPollingTransport) {
            //     this.features.inherentKeepAlive = true;
            // }
            this.transport.onreceive = this.onreceive;
            this.transport.onclose = (e) => this.stopConnection(e);
            // only change the state if we were connecting to not overwrite
            // the state if the connection is already marked as Disconnected
            this.changeState(0 /* Connecting */, 1 /* Connected */);
        }
        catch (e) {
            this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Error, "Failed to start the connection: " + e);
            this.connectionState = 2 /* Disconnected */;
            this.transport = undefined;
            throw e;
        }
    }
    async getNegotiationResponse(url) {
        let headers;
        if (this.accessTokenFactory) {
            const token = await this.accessTokenFactory();
            if (token) {
                headers = {
                    ["Authorization"]: `Bearer ${token}`,
                };
            }
        }
        const negotiateUrl = this.resolveNegotiateUrl(url);
        this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Debug, `Sending negotiation request: ${negotiateUrl}.`);
        try {
            const response = await this.httpClient.post(negotiateUrl, {
                content: "",
                headers,
            });
            if (response.statusCode !== 200) {
                throw Error(`Unexpected status code returned from negotiate ${response.statusCode}`);
            }
            return JSON.parse(response.content);
        }
        catch (e) {
            this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Error, "Failed to complete negotiation with the server: " + e);
            throw e;
        }
    }
    createConnectUrl(url, connectionId) {
        if (!connectionId) {
            return url;
        }
        return url + (url.indexOf("?") === -1 ? "?" : "&") + `id=${connectionId}`;
    }
    async createTransport(url, requestedTransport, negotiateResponse, requestedTransferFormat) {
        let connectUrl = this.createConnectUrl(url, negotiateResponse.connectionId);
        if (this.isITransport(requestedTransport)) {
            this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Debug, "Connection was provided an instance of ITransport, using that directly.");
            this.transport = requestedTransport;
            await this.transport.connect(connectUrl, requestedTransferFormat);
            // only change the state if we were connecting to not overwrite
            // the state if the connection is already marked as Disconnected
            this.changeState(0 /* Connecting */, 1 /* Connected */);
            return;
        }
        const transports = negotiateResponse.availableTransports || [];
        for (const endpoint of transports) {
            this.connectionState = 0 /* Connecting */;
            const transport = this.resolveTransport(endpoint, requestedTransport, requestedTransferFormat);
            if (typeof transport === "number") {
                this.transport = this.constructTransport(transport);
                if (!negotiateResponse.connectionId) {
                    negotiateResponse = await this.getNegotiationResponse(url);
                    connectUrl = this.createConnectUrl(url, negotiateResponse.connectionId);
                }
                try {
                    await this.transport.connect(connectUrl, requestedTransferFormat);
                    this.changeState(0 /* Connecting */, 1 /* Connected */);
                    return;
                }
                catch (ex) {
                    this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Error, `Failed to start the transport '${_contracts_ITransport__WEBPACK_IMPORTED_MODULE_1__["HttpTransportType"][transport]}': ${ex}`);
                    this.connectionState = 2 /* Disconnected */;
                    negotiateResponse.connectionId = undefined;
                }
            }
        }
        throw new Error("Unable to initialize any of the available transports.");
    }
    constructTransport(transport) {
        switch (transport) {
            case _contracts_ITransport__WEBPACK_IMPORTED_MODULE_1__["HttpTransportType"].WebSockets:
                if (!this.options.WebSocket) {
                    throw new Error("'WebSocket' is not supported in your environment.");
                }
                return new _WebSocketTransport__WEBPACK_IMPORTED_MODULE_3__["WebSocketTransport"](this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.WebSocket);
            //     case HttpTransportType.ServerSentEvents:
            //         if (!this.options.EventSource) {
            //             throw new Error("'EventSource' is not supported in your environment.");
            //         }
            //         return new ServerSentEventsTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.EventSource);
            //     case HttpTransportType.LongPolling:
            //         return new LongPollingTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false);
            //     default:
            //         throw new Error(`Unknown transport: ${transport}.`);
        }
    }
    resolveTransport(endpoint, requestedTransport, requestedTransferFormat) {
        const transport = _contracts_ITransport__WEBPACK_IMPORTED_MODULE_1__["HttpTransportType"][endpoint.transport];
        if (transport === null || transport === undefined) {
            this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Debug, `Skipping transport '${endpoint.transport}' because it is not supported by this client.`);
        }
        else {
            const transferFormats = endpoint.transferFormats.map((s) => _contracts_ITransport__WEBPACK_IMPORTED_MODULE_1__["TransferFormat"][s]);
            if (transportMatches(requestedTransport, transport)) {
                if (transferFormats.indexOf(requestedTransferFormat) >= 0) {
                    if ((transport === _contracts_ITransport__WEBPACK_IMPORTED_MODULE_1__["HttpTransportType"].WebSockets && !this.options.WebSocket) ||
                        (transport === _contracts_ITransport__WEBPACK_IMPORTED_MODULE_1__["HttpTransportType"].ServerSentEvents && !this.options.EventSource)) {
                        this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Debug, `Skipping transport '${_contracts_ITransport__WEBPACK_IMPORTED_MODULE_1__["HttpTransportType"][transport]}' because it is not supported in your environment.'`);
                    }
                    else {
                        this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Debug, `Selecting transport '${_contracts_ITransport__WEBPACK_IMPORTED_MODULE_1__["HttpTransportType"][transport]}'.`);
                        return transport;
                    }
                }
                else {
                    this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Debug, `Skipping transport '${_contracts_ITransport__WEBPACK_IMPORTED_MODULE_1__["HttpTransportType"][transport]}' because it does not support the requested transfer format '${_contracts_ITransport__WEBPACK_IMPORTED_MODULE_1__["TransferFormat"][requestedTransferFormat]}'.`);
                }
            }
            else {
                this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Debug, `Skipping transport '${_contracts_ITransport__WEBPACK_IMPORTED_MODULE_1__["HttpTransportType"][transport]}' because it was disabled by the client.`);
            }
        }
        return null;
    }
    isITransport(transport) {
        return transport && typeof (transport) === "object" && "connect" in transport;
    }
    changeState(from, to) {
        if (this.connectionState === from) {
            this.connectionState = to;
            return true;
        }
        return false;
    }
    stopConnection(error) {
        this.transport = undefined;
        // If we have a stopError, it takes precedence over the error from the transport
        error = this.stopError || error;
        if (error) {
            this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Error, `Connection disconnected with error '${error}'.`);
        }
        else {
            this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Information, "Connection disconnected.");
        }
        this.connectionState = 2 /* Disconnected */;
        if (this.onclose) {
            this.onclose(error);
        }
    }
    resolveUrl(url) {
        // startsWith is not supported in IE
        if (url.lastIndexOf("https://", 0) === 0 || url.lastIndexOf("http://", 0) === 0) {
            return url;
        }
        if (typeof window === "undefined" || !window || !window.document) {
            throw new Error(`Cannot resolve '${url}'.`);
        }
        // Setting the url to the href propery of an anchor tag handles normalization
        // for us. There are 3 main cases.
        // 1. Relative  path normalization e.g "b" -> "http://localhost:5000/a/b"
        // 2. Absolute path normalization e.g "/a/b" -> "http://localhost:5000/a/b"
        // 3. Networkpath reference normalization e.g "//localhost:5000/a/b" -> "http://localhost:5000/a/b"
        const aTag = window.document.createElement("a");
        aTag.href = url;
        this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Information, `Normalizing '${url}' to '${aTag.href}'.`);
        return aTag.href;
    }
    resolveNegotiateUrl(url) {
        const index = url.indexOf("?");
        let negotiateUrl = url.substring(0, index === -1 ? url.length : index);
        if (negotiateUrl[negotiateUrl.length - 1] !== "/") {
            negotiateUrl += "/";
        }
        negotiateUrl += "negotiate";
        negotiateUrl += index === -1 ? "" : url.substring(index);
        return negotiateUrl;
    }
}
function transportMatches(requestedTransport, actualTransport) {
    return !requestedTransport || ((actualTransport & requestedTransport) !== 0);
}


/***/ }),

/***/ "./node_modules/@hypertype/infr/dist/esm/common/signalr/HubConnection.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@hypertype/infr/dist/esm/common/signalr/HubConnection.js ***!
  \*******************************************************************************/
/*! exports provided: HubConnectionState, HubConnection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HubConnectionState", function() { return HubConnectionState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HubConnection", function() { return HubConnection; });
/* harmony import */ var _HandshakeProtocol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HandshakeProtocol */ "./node_modules/@hypertype/infr/dist/esm/common/signalr/HandshakeProtocol.js");
/* harmony import */ var _contracts_IHubProtocol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contracts/IHubProtocol */ "./node_modules/@hypertype/infr/dist/esm/common/signalr/contracts/IHubProtocol.js");
/* harmony import */ var _contracts_ILogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contracts/ILogger */ "./node_modules/@hypertype/infr/dist/esm/common/signalr/contracts/ILogger.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Utils */ "./node_modules/@hypertype/infr/dist/esm/common/signalr/Utils.js");
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.




const DEFAULT_TIMEOUT_IN_MS = 30 * 1000;
const DEFAULT_PING_INTERVAL_IN_MS = 15 * 1000;
/** Describes the current state of the {@link HubConnection} to the server. */
var HubConnectionState;
(function (HubConnectionState) {
    /** The hub connection is disconnected. */
    HubConnectionState[HubConnectionState["Disconnected"] = 0] = "Disconnected";
    /** The hub connection is connected. */
    HubConnectionState[HubConnectionState["Connected"] = 1] = "Connected";
})(HubConnectionState || (HubConnectionState = {}));
/** Represents a connection to a SignalR Hub. */
class HubConnection {
    constructor(connection, logger, protocol) {
        _Utils__WEBPACK_IMPORTED_MODULE_3__["Arg"].isRequired(connection, "connection");
        _Utils__WEBPACK_IMPORTED_MODULE_3__["Arg"].isRequired(logger, "logger");
        _Utils__WEBPACK_IMPORTED_MODULE_3__["Arg"].isRequired(protocol, "protocol");
        this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;
        this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS;
        this.logger = logger;
        this.protocol = protocol;
        this.connection = connection;
        this.handshakeProtocol = new _HandshakeProtocol__WEBPACK_IMPORTED_MODULE_0__["HandshakeProtocol"]();
        this.connection.onreceive = (data) => this.processIncomingData(data);
        this.connection.onclose = (error) => this.connectionClosed(error);
        this.callbacks = {};
        this.methods = {};
        this.closedCallbacks = [];
        this.id = 0;
        this.receivedHandshakeResponse = false;
        this.connectionState = HubConnectionState.Disconnected;
        this.cachedPingMessage = this.protocol.writeMessage({ type: _contracts_IHubProtocol__WEBPACK_IMPORTED_MODULE_1__["MessageType"].Ping });
    }
    /** @internal */
    // Using a public static factory method means we can have a private constructor and an _internal_
    // create method that can be used by HubConnectionBuilder. An "internal" constructor would just
    // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a
    // public parameter-less constructor.
    static create(connection, logger, protocol) {
        return new HubConnection(connection, logger, protocol);
    }
    /** Indicates the state of the {@link HubConnection} to the server. */
    get state() {
        return this.connectionState;
    }
    /** Starts the connection.
     *
     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.
     */
    async start() {
        const handshakeRequest = {
            protocol: this.protocol.name,
            version: this.protocol.version,
        };
        this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Debug, "Starting HubConnection.");
        this.receivedHandshakeResponse = false;
        // Set up the promise before any connection is started otherwise it could race with received messages
        const handshakePromise = new Promise((resolve, reject) => {
            this.handshakeResolver = resolve;
            this.handshakeRejecter = reject;
        });
        await this.connection.start(this.protocol.transferFormat);
        this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Debug, "Sending handshake request.");
        await this.sendMessage(this.handshakeProtocol.writeHandshakeRequest(handshakeRequest));
        this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Information, `Using HubProtocol '${this.protocol.name}'.`);
        // defensively cleanup timeout in case we receive a message from the server before we finish start
        this.cleanupTimeout();
        this.resetTimeoutPeriod();
        this.resetKeepAliveInterval();
        // Wait for the handshake to complete before marking connection as connected
        await handshakePromise;
        this.connectionState = HubConnectionState.Connected;
    }
    /** Stops the connection.
     *
     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.
     */
    stop() {
        this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Debug, "Stopping HubConnection.");
        this.cleanupTimeout();
        this.cleanupPingTimer();
        return this.connection.stop();
    }
    /** Invokes a streaming hub method on the server using the specified name and arguments.
     *
     * @typeparam T The type of the items returned by the server.
     * @param {string} methodName The name of the server method to invoke.
     * @param {any[]} args The arguments used to invoke the server method.
     * @returns {IStreamResult<T>} An object that yields results from the server as they are received.
     */
    stream(methodName, ...args) {
        const invocationDescriptor = this.createStreamInvocation(methodName, args);
        const subject = new _Utils__WEBPACK_IMPORTED_MODULE_3__["Subject"](() => {
            const cancelInvocation = this.createCancelInvocation(invocationDescriptor.invocationId);
            const cancelMessage = this.protocol.writeMessage(cancelInvocation);
            delete this.callbacks[invocationDescriptor.invocationId];
            return this.sendMessage(cancelMessage);
        });
        this.callbacks[invocationDescriptor.invocationId] = (invocationEvent, error) => {
            if (error) {
                subject.error(error);
                return;
            }
            else if (invocationEvent) {
                // invocationEvent will not be null when an error is not passed to the callback
                if (invocationEvent.type === _contracts_IHubProtocol__WEBPACK_IMPORTED_MODULE_1__["MessageType"].Completion) {
                    if (invocationEvent.error) {
                        subject.error(new Error(invocationEvent.error));
                    }
                    else {
                        subject.complete();
                    }
                }
                else {
                    subject.next((invocationEvent.item));
                }
            }
        };
        const message = this.protocol.writeMessage(invocationDescriptor);
        this.sendMessage(message)
            .catch((e) => {
            subject.error(e);
            delete this.callbacks[invocationDescriptor.invocationId];
        });
        return subject;
    }
    sendMessage(message) {
        this.resetKeepAliveInterval();
        return this.connection.send(message);
    }
    /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.
     *
     * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still
     * be processing the invocation.
     *
     * @param {string} methodName The name of the server method to invoke.
     * @param {any[]} args The arguments used to invoke the server method.
     * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.
     */
    send(methodName, ...args) {
        const invocationDescriptor = this.createInvocation(methodName, args, true);
        const message = this.protocol.writeMessage(invocationDescriptor);
        return this.sendMessage(message);
    }
    /** Invokes a hub method on the server using the specified name and arguments.
     *
     * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise
     * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of
     * resolving the Promise.
     *
     * @typeparam T The expected return type.
     * @param {string} methodName The name of the server method to invoke.
     * @param {any[]} args The arguments used to invoke the server method.
     * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.
     */
    invoke(methodName, ...args) {
        const invocationDescriptor = this.createInvocation(methodName, args, false);
        const p = new Promise((resolve, reject) => {
            // invocationId will always have a value for a non-blocking invocation
            this.callbacks[invocationDescriptor.invocationId] = (invocationEvent, error) => {
                if (error) {
                    reject(error);
                    return;
                }
                else if (invocationEvent) {
                    // invocationEvent will not be null when an error is not passed to the callback
                    if (invocationEvent.type === _contracts_IHubProtocol__WEBPACK_IMPORTED_MODULE_1__["MessageType"].Completion) {
                        if (invocationEvent.error) {
                            reject(new Error(invocationEvent.error));
                        }
                        else {
                            resolve(invocationEvent.result);
                        }
                    }
                    else {
                        reject(new Error(`Unexpected message type: ${invocationEvent.type}`));
                    }
                }
            };
            const message = this.protocol.writeMessage(invocationDescriptor);
            this.sendMessage(message)
                .catch((e) => {
                reject(e);
                // invocationId will always have a value for a non-blocking invocation
                delete this.callbacks[invocationDescriptor.invocationId];
            });
        });
        return p;
    }
    /** Registers a handler that will be invoked when the hub method with the specified method name is invoked.
     *
     * @param {string} methodName The name of the hub method to define.
     * @param {Function} newMethod The handler that will be raised when the hub method is invoked.
     */
    on(methodName, newMethod) {
        if (!methodName || !newMethod) {
            return;
        }
        methodName = methodName.toLowerCase();
        if (!this.methods[methodName]) {
            this.methods[methodName] = [];
        }
        // Preventing adding the same handler multiple times.
        if (this.methods[methodName].indexOf(newMethod) !== -1) {
            return;
        }
        this.methods[methodName].push(newMethod);
    }
    off(methodName, method) {
        if (!methodName) {
            return;
        }
        methodName = methodName.toLowerCase();
        const handlers = this.methods[methodName];
        if (!handlers) {
            return;
        }
        if (method) {
            const removeIdx = handlers.indexOf(method);
            if (removeIdx !== -1) {
                handlers.splice(removeIdx, 1);
                if (handlers.length === 0) {
                    delete this.methods[methodName];
                }
            }
        }
        else {
            delete this.methods[methodName];
        }
    }
    /** Registers a handler that will be invoked when the connection is closed.
     *
     * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).
     */
    onclose(callback) {
        if (callback) {
            this.closedCallbacks.push(callback);
        }
    }
    processIncomingData(data) {
        this.cleanupTimeout();
        if (!this.receivedHandshakeResponse) {
            data = this.processHandshakeResponse(data);
            this.receivedHandshakeResponse = true;
        }
        // Data may have all been read when processing handshake response
        if (data) {
            // Parse the messages
            const messages = this.protocol.parseMessages(data, this.logger);
            for (const message of messages) {
                switch (message.type) {
                    case _contracts_IHubProtocol__WEBPACK_IMPORTED_MODULE_1__["MessageType"].Invocation:
                        this.invokeClientMethod(message);
                        break;
                    case _contracts_IHubProtocol__WEBPACK_IMPORTED_MODULE_1__["MessageType"].StreamItem:
                    case _contracts_IHubProtocol__WEBPACK_IMPORTED_MODULE_1__["MessageType"].Completion:
                        const callback = this.callbacks[message.invocationId];
                        if (callback != null) {
                            if (message.type === _contracts_IHubProtocol__WEBPACK_IMPORTED_MODULE_1__["MessageType"].Completion) {
                                delete this.callbacks[message.invocationId];
                            }
                            callback(message);
                        }
                        break;
                    case _contracts_IHubProtocol__WEBPACK_IMPORTED_MODULE_1__["MessageType"].Ping:
                        // Don't care about pings
                        break;
                    case _contracts_IHubProtocol__WEBPACK_IMPORTED_MODULE_1__["MessageType"].Close:
                        this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Information, "Close message received from server.");
                        // We don't want to wait on the stop itself.
                        // tslint:disable-next-line:no-floating-promises
                        this.connection.stop(message.error ? new Error("Server returned an error on close: " + message.error) : undefined);
                        break;
                    default:
                        this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Warning, `Invalid message type: ${message.type}.`);
                        break;
                }
            }
        }
        this.resetTimeoutPeriod();
    }
    processHandshakeResponse(data) {
        let responseMessage;
        let remainingData;
        try {
            [remainingData, responseMessage] = this.handshakeProtocol.parseHandshakeResponse(data);
        }
        catch (e) {
            const message = "Error parsing handshake response: " + e;
            this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Error, message);
            const error = new Error(message);
            // We don't want to wait on the stop itself.
            // tslint:disable-next-line:no-floating-promises
            this.connection.stop(error);
            this.handshakeRejecter(error);
            throw error;
        }
        if (responseMessage.error) {
            const message = "Server returned handshake error: " + responseMessage.error;
            this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Error, message);
            this.handshakeRejecter(message);
            // We don't want to wait on the stop itself.
            // tslint:disable-next-line:no-floating-promises
            this.connection.stop(new Error(message));
            throw new Error(message);
        }
        else {
            this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Debug, "Server handshake complete.");
        }
        this.handshakeResolver();
        return remainingData;
    }
    resetKeepAliveInterval() {
        this.cleanupPingTimer();
        this.pingServerHandle = setTimeout(async () => {
            if (this.connectionState === HubConnectionState.Connected) {
                try {
                    await this.sendMessage(this.cachedPingMessage);
                }
                catch (_a) {
                    // We don't care about the error. It should be seen elsewhere in the client.
                    // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering
                    this.cleanupPingTimer();
                }
            }
        }, this.keepAliveIntervalInMilliseconds);
    }
    resetTimeoutPeriod() {
        if (!this.connection.features || !this.connection.features.inherentKeepAlive) {
            // Set the timeout timer
            this.timeoutHandle = setTimeout(() => this.serverTimeout(), this.serverTimeoutInMilliseconds);
        }
    }
    serverTimeout() {
        // The server hasn't talked to us in a while. It doesn't like us anymore ... :(
        // Terminate the connection, but we don't need to wait on the promise.
        // tslint:disable-next-line:no-floating-promises
        this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server."));
    }
    invokeClientMethod(invocationMessage) {
        const methods = this.methods[invocationMessage.target.toLowerCase()];
        if (methods) {
            methods.forEach((m) => m.apply(this, invocationMessage.arguments));
            if (invocationMessage.invocationId) {
                // This is not supported in v1. So we return an error to avoid blocking the server waiting for the response.
                const message = "Server requested a response, which is not supported in this version of the client.";
                this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Error, message);
                // We don't need to wait on this Promise.
                // tslint:disable-next-line:no-floating-promises
                this.connection.stop(new Error(message));
            }
        }
        else {
            this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_2__["LogLevel"].Warning, `No client method with the name '${invocationMessage.target}' found.`);
        }
    }
    connectionClosed(error) {
        const callbacks = this.callbacks;
        this.callbacks = {};
        this.connectionState = HubConnectionState.Disconnected;
        // if handshake is in progress start will be waiting for the handshake promise, so we complete it
        // if it has already completed this should just noop
        if (this.handshakeRejecter) {
            this.handshakeRejecter(error);
        }
        Object.keys(callbacks)
            .forEach((key) => {
            const callback = callbacks[key];
            callback(null, error ? error : new Error("Invocation canceled due to connection being closed."));
        });
        this.cleanupTimeout();
        this.cleanupPingTimer();
        this.closedCallbacks.forEach((c) => c.apply(this, [error]));
    }
    cleanupPingTimer() {
        if (this.pingServerHandle) {
            clearTimeout(this.pingServerHandle);
        }
    }
    cleanupTimeout() {
        if (this.timeoutHandle) {
            clearTimeout(this.timeoutHandle);
        }
    }
    createInvocation(methodName, args, nonblocking) {
        if (nonblocking) {
            return {
                arguments: args,
                target: methodName,
                type: _contracts_IHubProtocol__WEBPACK_IMPORTED_MODULE_1__["MessageType"].Invocation,
            };
        }
        else {
            const id = this.id;
            this.id++;
            return {
                arguments: args,
                invocationId: id.toString(),
                target: methodName,
                type: _contracts_IHubProtocol__WEBPACK_IMPORTED_MODULE_1__["MessageType"].Invocation,
            };
        }
    }
    createStreamInvocation(methodName, args) {
        const id = this.id;
        this.id++;
        return {
            arguments: args,
            invocationId: id.toString(),
            target: methodName,
            type: _contracts_IHubProtocol__WEBPACK_IMPORTED_MODULE_1__["MessageType"].StreamInvocation,
        };
    }
    createCancelInvocation(id) {
        return {
            invocationId: id,
            type: _contracts_IHubProtocol__WEBPACK_IMPORTED_MODULE_1__["MessageType"].CancelInvocation,
        };
    }
}


/***/ }),

/***/ "./node_modules/@hypertype/infr/dist/esm/common/signalr/HubConnectionBuilder.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@hypertype/infr/dist/esm/common/signalr/HubConnectionBuilder.js ***!
  \**************************************************************************************/
/*! exports provided: HubConnectionBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HubConnectionBuilder", function() { return HubConnectionBuilder; });
/* harmony import */ var _HttpConnection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HttpConnection */ "./node_modules/@hypertype/infr/dist/esm/common/signalr/HttpConnection.js");
/* harmony import */ var _HubConnection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HubConnection */ "./node_modules/@hypertype/infr/dist/esm/common/signalr/HubConnection.js");
/* harmony import */ var _JsonHubProtocol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./JsonHubProtocol */ "./node_modules/@hypertype/infr/dist/esm/common/signalr/JsonHubProtocol.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Utils */ "./node_modules/@hypertype/infr/dist/esm/common/signalr/Utils.js");
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.




/** A builder for configuring {@link @aspnet/signalr.HubConnection} instances. */
class HubConnectionBuilder {
    configureLogging(logging) {
        _Utils__WEBPACK_IMPORTED_MODULE_3__["Arg"].isRequired(logging, "logging");
        if (isLogger(logging)) {
            this.logger = logging;
        }
        else {
            this.logger = new _Utils__WEBPACK_IMPORTED_MODULE_3__["ConsoleLogger"](logging);
        }
        return this;
    }
    withUrl(url, transportTypeOrOptions) {
        _Utils__WEBPACK_IMPORTED_MODULE_3__["Arg"].isRequired(url, "url");
        this.url = url;
        // Flow-typing knows where it's at. Since HttpTransportType is a number and IHttpConnectionOptions is guaranteed
        // to be an object, we know (as does TypeScript) this comparison is all we need to figure out which overload was called.
        if (typeof transportTypeOrOptions === "object") {
            this.httpConnectionOptions = transportTypeOrOptions;
        }
        else {
            this.httpConnectionOptions = {
                transport: transportTypeOrOptions,
            };
        }
        return this;
    }
    /** Configures the {@link @aspnet/signalr.HubConnection} to use the specified Hub Protocol.
     *
     * @param {IHubProtocol} protocol The {@link @aspnet/signalr.IHubProtocol} implementation to use.
     */
    withHubProtocol(protocol) {
        _Utils__WEBPACK_IMPORTED_MODULE_3__["Arg"].isRequired(protocol, "protocol");
        this.protocol = protocol;
        return this;
    }
    /** Creates a {@link @aspnet/signalr.HubConnection} from the configuration options specified in this builder.
     *
     * @returns {HubConnection} The configured {@link @aspnet/signalr.HubConnection}.
     */
    build() {
        // If httpConnectionOptions has a logger, use it. Otherwise, override it with the one
        // provided to configureLogger
        const httpConnectionOptions = this.httpConnectionOptions || {};
        // If it's 'null', the user **explicitly** asked for null, don't mess with it.
        if (httpConnectionOptions.logger === undefined) {
            // If our logger is undefined or null, that's OK, the HttpConnection constructor will handle it.
            httpConnectionOptions.logger = this.logger;
        }
        // Now create the connection
        if (!this.url) {
            throw new Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection.");
        }
        const connection = new _HttpConnection__WEBPACK_IMPORTED_MODULE_0__["HttpConnection"](this.url, httpConnectionOptions);
        return _HubConnection__WEBPACK_IMPORTED_MODULE_1__["HubConnection"].create(connection, this.logger, this.protocol || new _JsonHubProtocol__WEBPACK_IMPORTED_MODULE_2__["JsonHubProtocol"]());
    }
}
function isLogger(logger) {
    return logger.log !== undefined;
}


/***/ }),

/***/ "./node_modules/@hypertype/infr/dist/esm/common/signalr/JsonHubProtocol.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@hypertype/infr/dist/esm/common/signalr/JsonHubProtocol.js ***!
  \*********************************************************************************/
/*! exports provided: JsonHubProtocol */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JsonHubProtocol", function() { return JsonHubProtocol; });
/* harmony import */ var _contracts_IHubProtocol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./contracts/IHubProtocol */ "./node_modules/@hypertype/infr/dist/esm/common/signalr/contracts/IHubProtocol.js");
/* harmony import */ var _contracts_ILogger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contracts/ILogger */ "./node_modules/@hypertype/infr/dist/esm/common/signalr/contracts/ILogger.js");
/* harmony import */ var _contracts_ITransport__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contracts/ITransport */ "./node_modules/@hypertype/infr/dist/esm/common/signalr/contracts/ITransport.js");
/* harmony import */ var _TextMessageFormat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TextMessageFormat */ "./node_modules/@hypertype/infr/dist/esm/common/signalr/TextMessageFormat.js");
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.




const JSON_HUB_PROTOCOL_NAME = "json";
/** Implements the JSON Hub Protocol. */
class JsonHubProtocol {
    constructor() {
        /** @inheritDoc */
        this.name = JSON_HUB_PROTOCOL_NAME;
        /** @inheritDoc */
        this.version = 1;
        /** @inheritDoc */
        this.transferFormat = _contracts_ITransport__WEBPACK_IMPORTED_MODULE_2__["TransferFormat"].Text;
    }
    /** Creates an array of {@link @aspnet/signalr.HubMessage} objects from the specified serialized representation.
     *
     * @param {string} input A string containing the serialized representation.
     * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.
     */
    parseMessages(input, logger) {
        // The interface does allow "ArrayBuffer" to be passed in, but this implementation does not. So let's throw a useful error.
        if (typeof input !== "string") {
            throw new Error("Invalid input for JSON hub protocol. Expected a string.");
        }
        if (!input) {
            return [];
        }
        // Parse the messages
        const messages = _TextMessageFormat__WEBPACK_IMPORTED_MODULE_3__["TextMessageFormat"].parse(input);
        const hubMessages = [];
        for (const message of messages) {
            const parsedMessage = JSON.parse(message);
            if (typeof parsedMessage.type !== "number") {
                throw new Error("Invalid payload.");
            }
            switch (parsedMessage.type) {
                case _contracts_IHubProtocol__WEBPACK_IMPORTED_MODULE_0__["MessageType"].Invocation:
                    this.isInvocationMessage(parsedMessage);
                    break;
                case _contracts_IHubProtocol__WEBPACK_IMPORTED_MODULE_0__["MessageType"].StreamItem:
                    this.isStreamItemMessage(parsedMessage);
                    break;
                case _contracts_IHubProtocol__WEBPACK_IMPORTED_MODULE_0__["MessageType"].Completion:
                    this.isCompletionMessage(parsedMessage);
                    break;
                case _contracts_IHubProtocol__WEBPACK_IMPORTED_MODULE_0__["MessageType"].Ping:
                    // Single value, no need to validate
                    break;
                case _contracts_IHubProtocol__WEBPACK_IMPORTED_MODULE_0__["MessageType"].Close:
                    // All optional values, no need to validate
                    break;
                default:
                    // Future protocol changes can add message types, old clients can ignore them
                    logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_1__["LogLevel"].Information, "Unknown message type '" + parsedMessage.type + "' ignored.");
                    continue;
            }
            hubMessages.push(parsedMessage);
        }
        return hubMessages;
    }
    /** Writes the specified {@link @aspnet/signalr.HubMessage} to a string and returns it.
     *
     * @param {HubMessage} message The message to write.
     * @returns {string} A string containing the serialized representation of the message.
     */
    writeMessage(message) {
        return _TextMessageFormat__WEBPACK_IMPORTED_MODULE_3__["TextMessageFormat"].write(JSON.stringify(message));
    }
    isInvocationMessage(message) {
        this.assertNotEmptyString(message.target, "Invalid payload for Invocation message.");
        if (message.invocationId !== undefined) {
            this.assertNotEmptyString(message.invocationId, "Invalid payload for Invocation message.");
        }
    }
    isStreamItemMessage(message) {
        this.assertNotEmptyString(message.invocationId, "Invalid payload for StreamItem message.");
        if (message.item === undefined) {
            throw new Error("Invalid payload for StreamItem message.");
        }
    }
    isCompletionMessage(message) {
        if (message.result && message.error) {
            throw new Error("Invalid payload for Completion message.");
        }
        if (!message.result && message.error) {
            this.assertNotEmptyString(message.error, "Invalid payload for Completion message.");
        }
        this.assertNotEmptyString(message.invocationId, "Invalid payload for Completion message.");
    }
    assertNotEmptyString(value, errorMessage) {
        if (typeof value !== "string" || value === "") {
            throw new Error(errorMessage);
        }
    }
}


/***/ }),

/***/ "./node_modules/@hypertype/infr/dist/esm/common/signalr/TextMessageFormat.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@hypertype/infr/dist/esm/common/signalr/TextMessageFormat.js ***!
  \***********************************************************************************/
/*! exports provided: TextMessageFormat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextMessageFormat", function() { return TextMessageFormat; });
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
// Not exported from index
/** @private */
class TextMessageFormat {
    static write(output) {
        return `${output}${TextMessageFormat.RecordSeparator}`;
    }
    static parse(input) {
        if (input[input.length - 1] !== TextMessageFormat.RecordSeparator) {
            throw new Error("Message is incomplete.");
        }
        const messages = input.split(TextMessageFormat.RecordSeparator);
        messages.pop();
        return messages;
    }
}
TextMessageFormat.RecordSeparatorCode = 0x1e;
TextMessageFormat.RecordSeparator = String.fromCharCode(TextMessageFormat.RecordSeparatorCode);


/***/ }),

/***/ "./node_modules/@hypertype/infr/dist/esm/common/signalr/Utils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@hypertype/infr/dist/esm/common/signalr/Utils.js ***!
  \***********************************************************************/
/*! exports provided: Arg, getDataDetail, formatArrayBuffer, isArrayBuffer, sendMessage, createLogger, Subject, SubjectSubscription, ConsoleLogger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Arg", function() { return Arg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDataDetail", function() { return getDataDetail; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatArrayBuffer", function() { return formatArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArrayBuffer", function() { return isArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sendMessage", function() { return sendMessage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createLogger", function() { return createLogger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Subject", function() { return Subject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubjectSubscription", function() { return SubjectSubscription; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConsoleLogger", function() { return ConsoleLogger; });
/* harmony import */ var _contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./contracts/ILogger */ "./node_modules/@hypertype/infr/dist/esm/common/signalr/contracts/ILogger.js");
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

/** @private */
class Arg {
    static isRequired(val, name) {
        if (val === null || val === undefined) {
            throw new Error(`The '${name}' argument is required.`);
        }
    }
    static isIn(val, values, name) {
        // TypeScript enums have keys for **both** the name and the value of each enum member on the type itself.
        if (!(val in values)) {
            throw new Error(`Unknown ${name} value: ${val}.`);
        }
    }
}
/** @private */
function getDataDetail(data, includeContent) {
    let detail = "";
    if (isArrayBuffer(data)) {
        detail = `Binary data of length ${data.byteLength}`;
        if (includeContent) {
            detail += `. Content: '${formatArrayBuffer(data)}'`;
        }
    }
    else if (typeof data === "string") {
        detail = `String data of length ${data.length}`;
        if (includeContent) {
            detail += `. Content: '${data}'`;
        }
    }
    return detail;
}
/** @private */
function formatArrayBuffer(data) {
    const view = new Uint8Array(data);
    // Uint8Array.map only supports returning another Uint8Array?
    let str = "";
    view.forEach((num) => {
        const pad = num < 16 ? "0" : "";
        str += `0x${pad}${num.toString(16)} `;
    });
    // Trim of trailing space.
    return str.substr(0, str.length - 1);
}
// Also in signalr-protocol-msgpack/Utils.ts
/** @private */
function isArrayBuffer(val) {
    return val && typeof ArrayBuffer !== "undefined" &&
        (val instanceof ArrayBuffer ||
            // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof
            (val.constructor && val.constructor.name === "ArrayBuffer"));
}
/** @private */
async function sendMessage(logger, transportName, httpClient, url, accessTokenFactory, content, logMessageContent) {
    let headers;
    if (accessTokenFactory) {
        const token = await accessTokenFactory();
        if (token) {
            headers = {
                ["Authorization"]: `Bearer ${token}`,
            };
        }
    }
    logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Trace, `(${transportName} transport) sending data. ${getDataDetail(content, logMessageContent)}.`);
    const responseType = isArrayBuffer(content) ? "arraybuffer" : "text";
    const response = await httpClient.post(url, {
        content,
        headers,
        responseType,
    });
    logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Trace, `(${transportName} transport) request complete. Response status: ${response.statusCode}.`);
}
/** @private */
function createLogger(logger) {
    if (logger === undefined) {
        return new ConsoleLogger(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Information);
    }
    if (logger.log) {
        return logger;
    }
    return new ConsoleLogger(logger);
}
/** @private */
class Subject {
    constructor(cancelCallback) {
        this.observers = [];
        this.cancelCallback = cancelCallback;
    }
    next(item) {
        for (const observer of this.observers) {
            observer.next(item);
        }
    }
    error(err) {
        for (const observer of this.observers) {
            if (observer.error) {
                observer.error(err);
            }
        }
    }
    complete() {
        for (const observer of this.observers) {
            if (observer.complete) {
                observer.complete();
            }
        }
    }
    subscribe(observer) {
        this.observers.push(observer);
        return new SubjectSubscription(this, observer);
    }
}
/** @private */
class SubjectSubscription {
    constructor(subject, observer) {
        this.subject = subject;
        this.observer = observer;
    }
    dispose() {
        const index = this.subject.observers.indexOf(this.observer);
        if (index > -1) {
            this.subject.observers.splice(index, 1);
        }
        if (this.subject.observers.length === 0) {
            this.subject.cancelCallback().catch((_) => { });
        }
    }
}
/** @private */
class ConsoleLogger {
    constructor(minimumLogLevel) {
        this.minimumLogLevel = minimumLogLevel;
    }
    log(logLevel, message) {
        if (logLevel >= this.minimumLogLevel) {
            switch (logLevel) {
                case _contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Critical:
                case _contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Error:
                    console.error(`[${new Date().toISOString()}] ${_contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"][logLevel]}: ${message}`);
                    break;
                case _contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Warning:
                    console.warn(`[${new Date().toISOString()}] ${_contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"][logLevel]}: ${message}`);
                    break;
                case _contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Information:
                    console.info(`[${new Date().toISOString()}] ${_contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"][logLevel]}: ${message}`);
                    break;
                default:
                    // console.debug only goes to attached debuggers in Node, so we use console.log for Trace and Debug
                    console.log(`[${new Date().toISOString()}] ${_contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"][logLevel]}: ${message}`);
                    break;
            }
        }
    }
}


/***/ }),

/***/ "./node_modules/@hypertype/infr/dist/esm/common/signalr/WebSocketTransport.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@hypertype/infr/dist/esm/common/signalr/WebSocketTransport.js ***!
  \************************************************************************************/
/*! exports provided: WebSocketTransport */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebSocketTransport", function() { return WebSocketTransport; });
/* harmony import */ var _contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./contracts/ILogger */ "./node_modules/@hypertype/infr/dist/esm/common/signalr/contracts/ILogger.js");
/* harmony import */ var _contracts_ITransport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contracts/ITransport */ "./node_modules/@hypertype/infr/dist/esm/common/signalr/contracts/ITransport.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils */ "./node_modules/@hypertype/infr/dist/esm/common/signalr/Utils.js");
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.



/** @private */
class WebSocketTransport {
    constructor(httpClient, accessTokenFactory, logger, logMessageContent, webSocketConstructor) {
        this.logger = logger;
        this.accessTokenFactory = accessTokenFactory;
        this.logMessageContent = logMessageContent;
        this.webSocketConstructor = webSocketConstructor;
        this.httpClient = httpClient;
        this.onreceive = null;
        this.onclose = null;
    }
    async connect(url, transferFormat) {
        _Utils__WEBPACK_IMPORTED_MODULE_2__["Arg"].isRequired(url, "url");
        _Utils__WEBPACK_IMPORTED_MODULE_2__["Arg"].isRequired(transferFormat, "transferFormat");
        _Utils__WEBPACK_IMPORTED_MODULE_2__["Arg"].isIn(transferFormat, _contracts_ITransport__WEBPACK_IMPORTED_MODULE_1__["TransferFormat"], "transferFormat");
        this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Trace, "(WebSockets transport) Connecting.");
        if (this.accessTokenFactory) {
            const token = await this.accessTokenFactory();
            if (token) {
                url += (url.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(token)}`;
            }
        }
        return new Promise((resolve, reject) => {
            url = url.replace(/^http/, "ws");
            let webSocket;
            const cookies = this.httpClient.getCookieString(url);
            if (typeof window === "undefined" && cookies) {
                // Only pass cookies when in non-browser environments
                webSocket = new this.webSocketConstructor(url, undefined, {
                    headers: {
                        Authorization: 'Bearer',
                        Cookie: `${cookies}`,
                    },
                });
            }
            if (!webSocket) {
                // Chrome is not happy with passing 'undefined' as protocol
                webSocket = new this.webSocketConstructor(url);
            }
            if (transferFormat === _contracts_ITransport__WEBPACK_IMPORTED_MODULE_1__["TransferFormat"].Binary) {
                webSocket.binaryType = "arraybuffer";
            }
            // tslint:disable-next-line:variable-name
            webSocket.onopen = (_event) => {
                this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Information, `WebSocket connected to ${url}.`);
                this.webSocket = webSocket;
                resolve();
            };
            webSocket.onerror = (event) => {
                let error = null;
                // ErrorEvent is a browser only type we need to check if the type exists before using it
                if (typeof ErrorEvent !== "undefined" && event instanceof ErrorEvent) {
                    error = event.error;
                }
                reject(error);
            };
            webSocket.onmessage = (message) => {
                this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Trace, `(WebSockets transport) data received. ${Object(_Utils__WEBPACK_IMPORTED_MODULE_2__["getDataDetail"])(message.data, this.logMessageContent)}.`);
                if (this.onreceive) {
                    this.onreceive(message.data);
                }
            };
            webSocket.onclose = (event) => this.close(event);
        });
    }
    send(data) {
        if (this.webSocket && this.webSocket.readyState === this.webSocketConstructor.OPEN) {
            this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Trace, `(WebSockets transport) sending data. ${Object(_Utils__WEBPACK_IMPORTED_MODULE_2__["getDataDetail"])(data, this.logMessageContent)}.`);
            this.webSocket.send(data);
            return Promise.resolve();
        }
        return Promise.reject("WebSocket is not in the OPEN state");
    }
    stop() {
        if (this.webSocket) {
            // Clear websocket handlers because we are considering the socket closed now
            this.webSocket.onclose = () => { };
            this.webSocket.onmessage = () => { };
            this.webSocket.onerror = () => { };
            this.webSocket.close();
            this.webSocket = undefined;
            // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning
            // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects
            this.close(undefined);
        }
        return Promise.resolve();
    }
    close(event) {
        // webSocket will be null if the transport did not start successfully
        this.logger.log(_contracts_ILogger__WEBPACK_IMPORTED_MODULE_0__["LogLevel"].Trace, "(WebSockets transport) socket closed.");
        if (this.onclose) {
            if (event && (event.wasClean === false || event.code !== 1000)) {
                this.onclose(new Error(`WebSocket closed with status code: ${event.code} (${event.reason}).`));
            }
            else {
                this.onclose();
            }
        }
    }
}


/***/ }),

/***/ "./node_modules/@hypertype/infr/dist/esm/common/signalr/contracts/IHubProtocol.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@hypertype/infr/dist/esm/common/signalr/contracts/IHubProtocol.js ***!
  \****************************************************************************************/
/*! exports provided: MessageType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MessageType", function() { return MessageType; });
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
/** Defines the type of a Hub Message. */
var MessageType;
(function (MessageType) {
    /** Indicates the message is an Invocation message and implements the {@link @aspnet/signalr.InvocationMessage} interface. */
    MessageType[MessageType["Invocation"] = 1] = "Invocation";
    /** Indicates the message is a StreamItem message and implements the {@link @aspnet/signalr.StreamItemMessage} interface. */
    MessageType[MessageType["StreamItem"] = 2] = "StreamItem";
    /** Indicates the message is a Completion message and implements the {@link @aspnet/signalr.CompletionMessage} interface. */
    MessageType[MessageType["Completion"] = 3] = "Completion";
    /** Indicates the message is a Stream Invocation message and implements the {@link @aspnet/signalr.StreamInvocationMessage} interface. */
    MessageType[MessageType["StreamInvocation"] = 4] = "StreamInvocation";
    /** Indicates the message is a Cancel Invocation message and implements the {@link @aspnet/signalr.CancelInvocationMessage} interface. */
    MessageType[MessageType["CancelInvocation"] = 5] = "CancelInvocation";
    /** Indicates the message is a Ping message and implements the {@link @aspnet/signalr.PingMessage} interface. */
    MessageType[MessageType["Ping"] = 6] = "Ping";
    /** Indicates the message is a Close message and implements the {@link @aspnet/signalr.CloseMessage} interface. */
    MessageType[MessageType["Close"] = 7] = "Close";
})(MessageType || (MessageType = {}));


/***/ }),

/***/ "./node_modules/@hypertype/infr/dist/esm/common/signalr/contracts/ILogger.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@hypertype/infr/dist/esm/common/signalr/contracts/ILogger.js ***!
  \***********************************************************************************/
/*! exports provided: LogLevel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LogLevel", function() { return LogLevel; });
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
// These values are designed to match the ASP.NET Log Levels since that's the pattern we're emulating here.
/** Indicates the severity of a log message.
 *
 * Log Levels are ordered in increasing severity. So `Debug` is more severe than `Trace`, etc.
 */
var LogLevel;
(function (LogLevel) {
    /** Log level for very low severity diagnostic messages. */
    LogLevel[LogLevel["Trace"] = 0] = "Trace";
    /** Log level for low severity diagnostic messages. */
    LogLevel[LogLevel["Debug"] = 1] = "Debug";
    /** Log level for informational diagnostic messages. */
    LogLevel[LogLevel["Information"] = 2] = "Information";
    /** Log level for diagnostic messages that indicate a non-fatal problem. */
    LogLevel[LogLevel["Warning"] = 3] = "Warning";
    /** Log level for diagnostic messages that indicate a failure in the current operation. */
    LogLevel[LogLevel["Error"] = 4] = "Error";
    /** Log level for diagnostic messages that indicate a failure that will terminate the entire application. */
    LogLevel[LogLevel["Critical"] = 5] = "Critical";
    /** The highest possible log level. Used when configuring logging to indicate that no log messages should be emitted. */
    LogLevel[LogLevel["None"] = 6] = "None";
})(LogLevel || (LogLevel = {}));


/***/ }),

/***/ "./node_modules/@hypertype/infr/dist/esm/common/signalr/contracts/ITransport.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@hypertype/infr/dist/esm/common/signalr/contracts/ITransport.js ***!
  \**************************************************************************************/
/*! exports provided: HttpTransportType, TransferFormat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HttpTransportType", function() { return HttpTransportType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TransferFormat", function() { return TransferFormat; });
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
// This will be treated as a bit flag in the future, so we keep it using power-of-two values.
/** Specifies a specific HTTP transport type. */
var HttpTransportType;
(function (HttpTransportType) {
    /** Specifies no transport preference. */
    HttpTransportType[HttpTransportType["None"] = 0] = "None";
    /** Specifies the WebSockets transport. */
    HttpTransportType[HttpTransportType["WebSockets"] = 1] = "WebSockets";
    /** Specifies the Server-Sent Events transport. */
    HttpTransportType[HttpTransportType["ServerSentEvents"] = 2] = "ServerSentEvents";
    /** Specifies the Long Polling transport. */
    HttpTransportType[HttpTransportType["LongPolling"] = 4] = "LongPolling";
})(HttpTransportType || (HttpTransportType = {}));
/** Specifies the transfer format for a connection. */
var TransferFormat;
(function (TransferFormat) {
    /** Specifies that only text data will be transmitted over the connection. */
    TransferFormat[TransferFormat["Text"] = 1] = "Text";
    /** Specifies that binary data will be transmitted over the connection. */
    TransferFormat[TransferFormat["Binary"] = 2] = "Binary";
})(TransferFormat || (TransferFormat = {}));


/***/ }),

/***/ "./node_modules/@hypertype/infr/dist/esm/common/signalr/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@hypertype/infr/dist/esm/common/signalr/index.js ***!
  \***********************************************************************/
/*! exports provided: HttpTransportType, HttpClient, HttpResponse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _HttpClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HttpClient */ "./node_modules/@hypertype/infr/dist/esm/common/signalr/HttpClient.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HttpClient", function() { return _HttpClient__WEBPACK_IMPORTED_MODULE_0__["HttpClient"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HttpResponse", function() { return _HttpClient__WEBPACK_IMPORTED_MODULE_0__["HttpResponse"]; });

/* harmony import */ var _contracts_ITransport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contracts/ITransport */ "./node_modules/@hypertype/infr/dist/esm/common/signalr/contracts/ITransport.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HttpTransportType", function() { return _contracts_ITransport__WEBPACK_IMPORTED_MODULE_1__["HttpTransportType"]; });






/***/ }),

/***/ "./node_modules/@hypertype/infr/dist/esm/common/state.logger.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@hypertype/infr/dist/esm/common/state.logger.js ***!
  \**********************************************************************/
/*! exports provided: StateLogger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StateLogger", function() { return StateLogger; });
class StateLogger {
    send({ type, payload }, state) {
    }
}


/***/ }),

/***/ "./node_modules/@hypertype/ui/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@hypertype/ui/dist/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory(__webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js"));
	else { var i, a; }
})(global, function(__WEBPACK_EXTERNAL_MODULE__hypertype_core__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./dist/esm/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./dist/esm/helpers/events.js":
/*!************************************!*\
  !*** ./dist/esm/helpers/events.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class ValueEvent extends Event {
    constructor(type, value) {
        super(type, { bubbles: false, cancelable: false });
        this.value = value;
    }
}
exports.ValueEvent = ValueEvent;


/***/ }),

/***/ "./dist/esm/index.js":
/*!***************************!*\
  !*** ./dist/esm/index.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const ui_1 = __webpack_require__(/*! ./src/ui */ "./dist/esm/src/ui.js");
const hyperhtml_element_1 = __webpack_require__(/*! ./src/hyperhtml.element */ "./dist/esm/src/hyperhtml.element.js");
__export(__webpack_require__(/*! ./src/component */ "./dist/esm/src/component.js"));
__export(__webpack_require__(/*! ./src/hyper.component */ "./dist/esm/src/hyper.component.js"));
exports.init = ui_1.UI.init;
__export(__webpack_require__(/*! ./src/helpers */ "./dist/esm/src/helpers.js"));
__export(__webpack_require__(/*! ./helpers/events */ "./dist/esm/helpers/events.js"));
exports.wire = hyperhtml_element_1.HyperHTMLElement.wire;
exports.bind = hyperhtml_element_1.HyperHTMLElement.bind;


/***/ }),

/***/ "./dist/esm/src/component.js":
/*!***********************************!*\
  !*** ./dist/esm/src/component.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const hyperhtml_element_1 = __webpack_require__(/*! ./hyperhtml.element */ "./dist/esm/src/hyperhtml.element.js");
const core_1 = __webpack_require__(/*! @hypertype/core */ "@hypertype/core");
const ui_1 = __webpack_require__(/*! ./ui */ "./dist/esm/src/ui.js");
const import_styles_1 = __webpack_require__(/*! ./import-styles */ "./dist/esm/src/import-styles.js");
const definitions = [];
function defineComponents() {
    while (definitions.length) {
        definitions.pop()();
    }
}
exports.defineComponents = defineComponents;
exports.propertySymbol = Symbol('property');
exports.property = () => (target, key, properties) => {
    const attr = key.substring(0, key.length - 1).replace(/[A-Z]/g, ch => `-${ch}`).toLowerCase();
    const getSubject = instance => instance[key + 'Subject$'] || (instance[key + 'Subject$'] = new core_1.ReplaySubject(1));
    if (!target.constructor[exports.propertySymbol]) {
        target.constructor[exports.propertySymbol] = {};
    }
    target.constructor[exports.propertySymbol][attr] = instance => {
        const subject = getSubject(instance);
        return {
            get() {
                return instance[attr];
            },
            set(value) {
                instance[attr] = value;
                subject.next(value);
            },
            enumerable: true
        };
    };
    if (delete this[key]) {
        Object.defineProperty(target, key, {
            get() {
                return getSubject(this).asObservable();
            }
        });
    }
};
function Component(info) {
    return (target) => {
        let Id = 0;
        import_styles_1.importStyle(info.style, target.name);
        class ProxyHTML extends hyperhtml_element_1.HyperHTMLElement {
            constructor() {
                super();
                this._id = Id++;
                this.eventHandlers = {};
                this.getEventHandler = type => mapping => {
                    const key = `${type}.${mapping}`;
                    if (this.eventHandlers[key])
                        return this.eventHandlers[key];
                    return (this.eventHandlers[key] = event => {
                        event.preventDefault();
                        const directHandler = this.component.Events && this.component.Events[type];
                        if (directHandler)
                            directHandler(mapping(event));
                        this.component._eventsSubject$.next({
                            args: mapping(event),
                            type: type
                        });
                        return false;
                    });
                };
                if (target[exports.propertySymbol]) {
                    for (let key in target[exports.propertySymbol]) {
                        this[key] = null;
                    }
                }
            }
            renderState(state) {
                info.template.call(this, this.html, state, this.handlerProxy);
                this.component.Render$.next();
            }
            created() {
                // const dependencies = Reflector.paramTypes(target).map(type => Container.get(type));
                this.component = ui_1.UI.container.get(target); //new target(...dependencies);
                if (target[exports.propertySymbol]) {
                    for (let key in target[exports.propertySymbol]) {
                        const desrc = target[exports.propertySymbol][key](this.component);
                        desrc.set(this[key]);
                        delete this[key];
                        Object.defineProperty(this, key, desrc);
                    }
                }
                this.html = this.html.bind(this);
                // this.component.element = this;
                // this.component.element = this;
                this.component['id'] = this._id;
                this.handlerProxy = new Proxy({}, {
                    get: (target, key) => {
                        return this.getEventHandler(key);
                    }
                });
                // @ts-ignore
                this.component._elementSubject$.next(this);
                const children = [].slice.call(this.children);
                if (children.length)
                    this.component._injectedContent$.next(children);
                this.component._injectedContent$.complete();
                // this.component.created();
            }
            connectedCallback() {
                this.component.State$.pipe(core_1.takeUntil(this.component._disconnect$.asObservable())).subscribe(state => {
                    this.renderState(state);
                });
                this.component.Actions$.pipe(core_1.takeUntil(this.component._disconnect$.asObservable())).subscribe();
            }
            attributeChangedCallback(name, prev, curr) {
                if (this.component[exports.propertySymbol] && this.component[exports.propertySymbol][name]) {
                    this.component[exports.propertySymbol][name].set(curr);
                }
                this.component._attributesSubject$.next({ name, value: curr });
            }
            disconnectedCallback() {
                this.component._disconnect$.next();
            }
        }
        ProxyHTML.observedAttributes = info.observedAttributes || [];
        ProxyHTML.booleanAttributes = info.booleanAttributes || [];
        ;
        if (ui_1.UI.container) {
            ProxyHTML.define(info.name);
        }
        else {
            definitions.push(() => ProxyHTML.define(info.name));
        }
    };
}
exports.Component = Component;


/***/ }),

/***/ "./dist/esm/src/helpers.js":
/*!*********************************!*\
  !*** ./dist/esm/src/helpers.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function foreach(items, action) {
    if (!items)
        return '';
    return items.map(action);
}
exports.foreach = foreach;


/***/ }),

/***/ "./dist/esm/src/hyper.component.js":
/*!*****************************************!*\
  !*** ./dist/esm/src/hyper.component.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = __webpack_require__(/*! @hypertype/core */ "@hypertype/core");
class HyperComponent {
    constructor() {
        this.State$ = core_1.of(null);
        this.Actions$ = core_1.NEVER;
        this._attributesSubject$ = new core_1.ReplaySubject();
        this._eventsSubject$ = new core_1.ReplaySubject();
        this._elementSubject$ = new core_1.ReplaySubject();
        this._disconnect$ = new core_1.Subject();
        this.Element$ = this._elementSubject$.asObservable().pipe(core_1.filter(x => !!x));
        this.Events$ = this._eventsSubject$.asObservable();
        this.Attributes$ = this._attributesSubject$.asObservable().pipe(core_1.scan((acc, val) => ({ ...acc, [val.name]: val.value }), {}), core_1.startWith({}));
        this.ClientRect$ = this.Element$.pipe(core_1.switchMap(el => new core_1.Observable(subscr => {
            // @ts-ignore
            const observer = new ResizeObserver(entries => {
                subscr.next(el.getBoundingClientRect());
            });
            observer.observe(el);
            this._disconnect$.asObservable().subscribe(() => observer.disconnect());
            return () => {
                observer.disconnect();
            };
        })), core_1.filter(rect => rect.width > 0 && rect.height > 0), core_1.shareReplay(1));
        this.Render$ = new core_1.ReplaySubject();
        this._injectedContent$ = new core_1.ReplaySubject();
        this.InjectedContent$ = this._injectedContent$.asObservable();
    }
    select(selector) {
        return this.Render$.asObservable().pipe(core_1.withLatestFrom(this.Element$), core_1.map(([_, element]) => element.querySelector(selector)));
    }
}
exports.HyperComponent = HyperComponent;


/***/ }),

/***/ "./dist/esm/src/hyperhtml.element.js":
/*!*******************************************!*\
  !*** ./dist/esm/src/hyperhtml.element.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*! (C) 2017-2018 Andrea Giammarchi - ISC Style License */
const { Component, bind, define, hyper, wire } = __webpack_require__(/*! hyperhtml */ "./node_modules/hyperhtml/cjs/index.js");
// utils to deal with custom elements builtin extends
const ATTRIBUTE_CHANGED_CALLBACK = 'attributeChangedCallback';
const O = Object;
const classes = [];
const defineProperty = O.defineProperty;
const getOwnPropertyDescriptor = O.getOwnPropertyDescriptor;
const getOwnPropertyNames = O.getOwnPropertyNames;
const getOwnPropertySymbols = O.getOwnPropertySymbols || (() => []);
const getPrototypeOf = O.getPrototypeOf || (o => o.__proto__);
const ownKeys = typeof Reflect === 'object' && Reflect.ownKeys ||
    (o => getOwnPropertyNames(o).concat(getOwnPropertySymbols(o)));
const setPrototypeOf = O.setPrototypeOf ||
    ((o, p) => (o.__proto__ = p, o));
const camel = name => name.replace(/-([a-z])/g, ($0, $1) => $1.toUpperCase());
const { attachShadow } = HTMLElement.prototype;
const sr = new WeakMap;
class HyperHTMLElement extends HTMLElement {
    created() {
    }
    connectedCallback() {
    }
    // define a custom-element in the CustomElementsRegistry
    // class MyEl extends HyperHTMLElement {}
    // MyEl.define('my-el');
    static define(name, options) {
        const Class = this;
        const proto = Class.prototype;
        const onChanged = proto[ATTRIBUTE_CHANGED_CALLBACK];
        const hasChange = !!onChanged;
        // Class.booleanAttributes
        // -----------------------------------------------
        // attributes defined as boolean will have
        // an either available or not available attribute
        // regardless of the value.
        // All falsy values, or "false", mean attribute removed
        // while truthy values will be set as is.
        // Boolean attributes are also automatically observed.
        const booleanAttributes = Class.booleanAttributes || [];
        booleanAttributes.forEach(name => {
            if (!(name in proto))
                defineProperty(proto, camel(name), {
                    configurable: true,
                    get() {
                        return this.hasAttribute(name);
                    },
                    set(value) {
                        if (!value || value === 'false')
                            this.removeAttribute(name);
                        else
                            this.setAttribute(name, value);
                    }
                });
        });
        // Class.observedAttributes
        // -------------------------------------------------------
        // HyperHTMLElement will directly reflect get/setAttribute
        // operation once these attributes are used, example:
        // el.observed = 123;
        // will automatically do
        // el.setAttribute('observed', 123);
        // triggering also the attributeChangedCallback
        const observedAttributes = Class.observedAttributes || [];
        observedAttributes.forEach(name => {
            // it is possible to redefine the behavior at any time
            // simply overwriting get prop() and set prop(value)
            if (!(name in proto))
                defineProperty(proto, camel(name), {
                    configurable: true,
                    get() {
                        return this.getAttribute(name);
                    },
                    set(value) {
                        if (value == null)
                            this.removeAttribute(name);
                        else
                            this.setAttribute(name, value);
                    }
                });
        });
        // if these are defined, overwrite the observedAttributes getter
        // to include also booleanAttributes
        const attributes = booleanAttributes.concat(observedAttributes);
        if (attributes.length)
            defineProperty(Class, 'observedAttributes', {
                get() { return attributes; }
            });
        // created() {}
        // ---------------------------------
        // an initializer method that grants
        // the node is fully known to the browser.
        // It is ensured to run either after DOMContentLoaded,
        // or once there is a next sibling (stream-friendly) so that
        // you have full access to element attributes and/or childNodes.
        const created = proto.created || function () {
            this.render();
        };
        // used to ensure create() is called once and once only
        defineProperty(proto, '_init$', {
            configurable: true,
            writable: true,
            value: true
        });
        defineProperty(proto, ATTRIBUTE_CHANGED_CALLBACK, {
            configurable: true,
            value: function aCC(name, prev, curr) {
                if (this._init$) {
                    checkReady.call(this, created);
                    if (this._init$)
                        return this._init$$.push(aCC.bind(this, name, prev, curr));
                }
                // ensure setting same value twice
                // won't trigger twice attributeChangedCallback
                if (hasChange && prev !== curr) {
                    onChanged.apply(this, arguments);
                }
            }
        });
        const onConnected = proto.connectedCallback;
        const hasConnect = !!onConnected;
        defineProperty(proto, 'connectedCallback', {
            configurable: true,
            value: function cC() {
                if (this._init$) {
                    checkReady.call(this, created);
                    if (this._init$)
                        return this._init$$.push(cC.bind(this));
                }
                if (hasConnect) {
                    onConnected.apply(this, arguments);
                }
            }
        });
        // define lazily all handlers
        // class { handleClick() { ... }
        // render() { `<a onclick=${this.handleClick}>` } }
        getOwnPropertyNames(proto).forEach(key => {
            if (/^handle[A-Z]/.test(key)) {
                const _key$ = '_' + key + '$';
                const method = proto[key];
                defineProperty(proto, key, {
                    configurable: true,
                    get() {
                        return this[_key$] ||
                            (this[_key$] = method.bind(this));
                    }
                });
            }
        });
        // whenever you want to directly use the component itself
        // as EventListener, you can pass it directly.
        // https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38
        //  class Reactive extends HyperHTMLElement {
        //    oninput(e) { console.log(this, 'changed', e.target.value); }
        //    render() { this.html`<input oninput="${this}">`; }
        //  }
        if (!('handleEvent' in proto)) {
            defineProperty(proto, 'handleEvent', {
                configurable: true,
                value(event) {
                    this[(event.currentTarget.dataset || {}).call ||
                        ('on' + event.type)](event);
                }
            });
        }
        if (options && options.extends) {
            const Native = document.createElement(options.extends).constructor;
            const Intermediate = class extends Native {
            };
            const Super = getPrototypeOf(Class);
            ownKeys(Super)
                .filter(key => [
                'length', 'name', 'arguments', 'caller', 'prototype'
            ].indexOf(key) < 0)
                .forEach(key => defineProperty(Intermediate, key, getOwnPropertyDescriptor(Super, key)));
            ownKeys(Super.prototype)
                .forEach(key => defineProperty(Intermediate.prototype, key, getOwnPropertyDescriptor(Super.prototype, key)));
            setPrototypeOf(Class, Intermediate);
            setPrototypeOf(proto, Intermediate.prototype);
            customElements.define(name, Class, options);
        }
        else {
            customElements.define(name, Class);
        }
        classes.push(Class);
        return Class;
    }
    // weakly relate the shadowRoot for refs usage
    attachShadow() {
        const shadowRoot = attachShadow.apply(this, arguments);
        sr.set(this, shadowRoot);
        return shadowRoot;
    }
    // returns elements by ref
    get refs() {
        const value = {};
        if ('_html$' in this) {
            const all = (sr.get(this) || this).querySelectorAll('[ref]');
            for (let { length } = all, i = 0; i < length; i++) {
                const node = all[i];
                value[node.getAttribute('ref')] = node;
            }
            Object.defineProperty(this, 'refs', { value });
            return value;
        }
        return value;
    }
    // lazily bind once hyperHTML logic
    // to either the shadowRoot, if present and open,
    // the _shadowRoot property, if set due closed shadow root,
    // or the custom-element itself if no Shadow DOM is used.
    get html() {
        return this._html$ || (this.html = bind(
        // in a way or another, bind to the right node
        // backward compatible, first two could probably go already
        this.shadowRoot || this._shadowRoot || sr.get(this) || this));
    }
    // it can be set too if necessary, it won't invoke render()
    set html(value) {
        defineProperty(this, '_html$', { configurable: true, value: value });
    }
    // overwrite this method with your own render
    render() { }
    // ---------------------//
    // Basic State Handling //
    // ---------------------//
    // define the default state object
    // you could use observed properties too
    get defaultState() { return {}; }
    // the state with a default
    get state() {
        return this._state$ || (this.state = this.defaultState);
    }
    // it can be set too if necessary, it won't invoke render()
    set state(value) {
        defineProperty(this, '_state$', { configurable: true, value: value });
    }
    // currently a state is a shallow copy, like in Preact or other libraries.
    // after the state is updated, the render() method will be invoked.
    //  do not ever call this.setState() inside this.render()
    setState(state, render) {
        const target = this.state;
        const source = typeof state === 'function' ? state.call(this, target) : state;
        for (const key in source)
            target[key] = source[key];
        if (render !== false)
            this.render();
        return this;
    }
}
exports.HyperHTMLElement = HyperHTMLElement;
;
// exposing hyperHTML utilities
HyperHTMLElement.Component = Component;
HyperHTMLElement.bind = bind;
HyperHTMLElement.intent = define;
HyperHTMLElement.wire = wire;
HyperHTMLElement.hyper = hyper;
try {
    if (Symbol.hasInstance)
        classes.push(defineProperty(HyperHTMLElement, Symbol.hasInstance, {
            enumerable: false,
            configurable: true,
            value(instance) {
                return classes.some(isPrototypeOf, getPrototypeOf(instance));
            }
        }));
}
catch (meh) { }
Object.defineProperty(exports, '__esModule', { value: true }).default = HyperHTMLElement;
// ------------------------------//
// DOMContentLoaded VS created() //
// ------------------------------//
const dom = {
    type: 'DOMContentLoaded',
    handleEvent() {
        if (dom.ready()) {
            document.removeEventListener(dom.type, dom, false);
            dom.list.splice(0).forEach(invoke);
        }
        else
            setTimeout(dom.handleEvent);
    },
    ready() {
        return document.readyState === 'complete';
    },
    list: []
};
if (!dom.ready()) {
    document.addEventListener(dom.type, dom, false);
}
function checkReady(created) {
    if (dom.ready() || isReady.call(this, created)) {
        if (this._init$) {
            const list = this._init$$;
            if (list)
                delete this._init$$;
            created.call(defineProperty(this, '_init$', { value: false }));
            if (list)
                list.forEach(invoke);
        }
    }
    else {
        if (!this.hasOwnProperty('_init$$'))
            defineProperty(this, '_init$$', { configurable: true, value: [] });
        dom.list.push(checkReady.bind(this, created));
    }
}
function invoke(fn) {
    fn();
}
function isPrototypeOf(Class) {
    return this === Class.prototype;
}
function isReady(created) {
    let el = this;
    do {
        if (el.nextSibling)
            return true;
    } while (el = el.parentNode);
    setTimeout(checkReady.bind(this, created));
    return false;
}


/***/ }),

/***/ "./dist/esm/src/import-styles.js":
/*!***************************************!*\
  !*** ./dist/esm/src/import-styles.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function importStyle(text, label = '') {
    const style = document.createElement('style');
    style.textContent = text;
    if (label) {
        style.setAttribute('target', label);
    }
    document.head.appendChild(style);
}
exports.importStyle = importStyle;


/***/ }),

/***/ "./dist/esm/src/ui.js":
/*!****************************!*\
  !*** ./dist/esm/src/ui.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const component_1 = __webpack_require__(/*! ./component */ "./dist/esm/src/component.js");
class UI {
    static init(container) {
        UI.container = container;
        component_1.defineComponents();
    }
}
exports.UI = UI;
;


/***/ }),

/***/ "./node_modules/@ungap/create-content/cjs/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@ungap/create-content/cjs/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*! (c) Andrea Giammarchi - ISC */
var createContent = (function (document) {'use strict';
  var FRAGMENT = 'fragment';
  var TEMPLATE = 'template';
  var HAS_CONTENT = 'content' in create(TEMPLATE);

  var createHTML = HAS_CONTENT ?
    function (html) {
      var template = create(TEMPLATE);
      template.innerHTML = html;
      return template.content;
    } :
    function (html) {
      var content = create(FRAGMENT);
      var template = create(TEMPLATE);
      var childNodes = null;
      if (/^[^\S]*?<(col(?:group)?|t(?:head|body|foot|r|d|h))/i.test(html)) {
        var selector = RegExp.$1;
        template.innerHTML = '<table>' + html + '</table>';
        childNodes = template.querySelectorAll(selector);
      } else {
        template.innerHTML = html;
        childNodes = template.childNodes;
      }
      append(content, childNodes);
      return content;
    };

  return function createContent(markup, type) {
    return (type === 'svg' ? createSVG : createHTML)(markup);
  };

  function append(root, childNodes) {
    var length = childNodes.length;
    while (length--)
      root.appendChild(childNodes[0]);
  }

  function create(element) {
    return element === FRAGMENT ?
      document.createDocumentFragment() :
      document.createElementNS('http://www.w3.org/1999/xhtml', element);
  }

  // it could use createElementNS when hasNode is there
  // but this fallback is equally fast and easier to maintain
  // it is also battle tested already in all IE
  function createSVG(svg) {
    var content = create(FRAGMENT);
    var template = create('div');
    template.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg">' + svg + '</svg>';
    append(content, template.firstChild.childNodes);
    return content;
  }

}(document));
module.exports = createContent;


/***/ }),

/***/ "./node_modules/@ungap/custom-event/cjs/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@ungap/custom-event/cjs/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*! (c) Andrea Giammarchi - ISC */
var self = this || /* istanbul ignore next */ {};
self.CustomEvent = typeof CustomEvent === 'function' ?
  CustomEvent :
  (function (__p__) {
    CustomEvent[__p__] = new CustomEvent('').constructor[__p__];
    return CustomEvent;
    function CustomEvent(type, init) {
      if (!init) init = {};
      var e = document.createEvent('CustomEvent');
      e.initCustomEvent(type, !!init.bubbles, !!init.cancelable, init.detail);
      return e;
    }
  }('prototype'));
module.exports = self.CustomEvent;


/***/ }),

/***/ "./node_modules/@ungap/essential-map/cjs/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@ungap/essential-map/cjs/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*! (c) Andrea Giammarchi - ISC */
var self = this || /* istanbul ignore next */ {};
try { self.Map = Map; }
catch (Map) {
  self.Map = function Map() {
    var i = 0;
    var k = [];
    var v = [];
    return {
      delete: function (key) {
        var had = contains(key);
        if (had) {
          k.splice(i, 1);
          v.splice(i, 1);
        }
        return had;
      },
      forEach: function forEach(callback, context) {
        k.forEach(
          function (key, i)  {
            callback.call(context, v[i], key, this);
          },
          this
        );
      },
      get: function get(key) {
        return contains(key) ? v[i] : void 0;
      },
      has: function has(key) {
        return contains(key);
      },
      set: function set(key, value) {
        v[contains(key) ? i : (k.push(key) - 1)] = value;
        return this;
      }
    };
    function contains(v) {
      i = k.indexOf(v);
      return -1 < i;
    }
  };
}
module.exports = self.Map;


/***/ }),

/***/ "./node_modules/@ungap/essential-weakset/cjs/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@ungap/essential-weakset/cjs/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*! (c) Andrea Giammarchi - ISC */
var self = this || /* istanbul ignore next */ {};
try { self.WeakSet = WeakSet; }
catch (WeakSet) {
  (function (id, dP) {
    var proto = WeakSet.prototype;
    proto.add = function (object) {
      if (!this.has(object))
        dP(object, this._, {value: true, configurable: true});
      return this;
    };
    proto.has = function (object) {
      return this.hasOwnProperty.call(object, this._);
    };
    proto.delete = function (object) {
      return this.has(object) && delete object[this._];
    };
    self.WeakSet = WeakSet;
    function WeakSet() {'use strict';
      dP(this, '_', {value: '_@ungap/weakmap' + id++});
    }
  }(Math.random(), Object.defineProperty));
}
module.exports = self.WeakSet;


/***/ }),

/***/ "./node_modules/@ungap/import-node/cjs/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@ungap/import-node/cjs/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*! (c) Andrea Giammarchi - ISC */
var importNode = (function (
  document,
  appendChild,
  cloneNode,
  createTextNode,
  importNode
) {
  var native = importNode in document;
  // IE 11 has problems with cloning templates:
  // it "forgets" empty childNodes. This feature-detects that.
  var fragment = document.createDocumentFragment();
  fragment[appendChild](document[createTextNode]('g'));
  fragment[appendChild](document[createTextNode](''));
  var content = native ?
    document[importNode](fragment, true) :
    fragment[cloneNode](true);
  return content.childNodes.length < 2 ?
    function importNode(node, deep) {
      var clone = node[cloneNode]();
      for (var
        childNodes = node.childNodes || [],
        length = childNodes.length,
        i = 0; deep && i < length; i++
      ) {
        clone[appendChild](importNode(childNodes[i], deep));
      }
      return clone;
    } :
    (native ?
      document[importNode] :
      function (node, deep) {
        return node[cloneNode](!!deep);
      }
    );
}(
  document,
  'appendChild',
  'cloneNode',
  'createTextNode',
  'importNode'
));
module.exports = importNode;


/***/ }),

/***/ "./node_modules/@ungap/is-array/cjs/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@ungap/is-array/cjs/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var isArray = Array.isArray || (function (toString) {
  var $ = toString.call([]);
  return function isArray(object) {
    return toString.call(object) === $;
  };
}({}.toString));
module.exports = isArray;


/***/ }),

/***/ "./node_modules/@ungap/template-literal/cjs/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@ungap/template-literal/cjs/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const WeakMap = (__webpack_require__(/*! @ungap/weakmap */ "./node_modules/@ungap/weakmap/cjs/index.js"));

var isNoOp = typeof document !== 'object';

var templateLiteral = function (tl) {
  var RAW = 'raw';
  var isBroken = function (UA) {
    return /(Firefox|Safari)\/(\d+)/.test(UA) &&
          !/(Chrom[eium]+|Android)\/(\d+)/.test(UA);
  };
  var broken = isBroken((document.defaultView.navigator || {}).userAgent);
  var FTS = !(RAW in tl) ||
            tl.propertyIsEnumerable(RAW) ||
            !Object.isFrozen(tl[RAW]);
  if (broken || FTS) {
    var forever = {};
    var foreverCache = function (tl) {
      for (var key = '.', i = 0; i < tl.length; i++)
        key += tl[i].length + '.' + tl[i];
      return forever[key] || (forever[key] = tl);
    };
    // Fallback TypeScript shenanigans
    if (FTS)
      templateLiteral = foreverCache;
    // try fast path for other browsers:
    // store the template as WeakMap key
    // and forever cache it only when it's not there.
    // this way performance is still optimal,
    // penalized only when there are GC issues
    else {
      var wm = new WeakMap;
      var set = function (tl, unique) {
        wm.set(tl, unique);
        return unique;
      };
      templateLiteral = function (tl) {
        return wm.get(tl) || set(tl, foreverCache(tl));
      };
    }
  } else {
    isNoOp = true;
  }
  return TL(tl);
};

module.exports = TL;

function TL(tl) {
  return isNoOp ? tl : templateLiteral(tl);
}


/***/ }),

/***/ "./node_modules/@ungap/template-tag-arguments/cjs/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ungap/template-tag-arguments/cjs/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const unique = (__webpack_require__(/*! @ungap/template-literal */ "./node_modules/@ungap/template-literal/cjs/index.js"));

Object.defineProperty(exports, '__esModule', {value: true}).default = function (template) {
  var length = arguments.length;
  var args = [unique(template)];
  var i = 1;
  while (i < length)
    args.push(arguments[i++]);
  return args;
};


/***/ }),

/***/ "./node_modules/@ungap/trim/cjs/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@ungap/trim/cjs/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var trim = ''.trim || function () {
  return String(this).replace(/^\s+|\s+/g, '');
};
module.exports = trim;


/***/ }),

/***/ "./node_modules/@ungap/weakmap/cjs/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@ungap/weakmap/cjs/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*! (c) Andrea Giammarchi - ISC */
var self = this || /* istanbul ignore next */ {};
try { self.WeakMap = WeakMap; }
catch (WeakMap) {
  // this could be better but 90% of the time
  // it's everything developers need as fallback
  self.WeakMap = (function (id, Object) {'use strict';
    var dP = Object.defineProperty;
    var hOP = Object.hasOwnProperty;
    var proto = WeakMap.prototype;
    proto.delete = function (key) {
      return this.has(key) && delete key[this._];
    };
    proto.get = function (key) {
      return this.has(key) ? key[this._] : void 0;
    };
    proto.has = function (key) {
      return hOP.call(key, this._);
    };
    proto.set = function (key, value) {
      dP(key, this._, {configurable: true, value: value});
      return this;
    };
    return WeakMap;
    function WeakMap(iterable) {
      dP(this, '_', {value: '_@ungap/weakmap' + id++});
      if (iterable)
        iterable.forEach(add, this);
    }
    function add(pair) {
      this.set(pair[0], pair[1]);
    }
  }(Math.random(), Object));
}
module.exports = self.WeakMap;


/***/ }),

/***/ "./node_modules/disconnected/cjs/index.js":
/*!************************************************!*\
  !*** ./node_modules/disconnected/cjs/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*! (c) Andrea Giammarchi */
function disconnected(poly) {'use strict';
  var Event = poly.Event;
  var WeakSet = poly.WeakSet;
  var notObserving = true;
  var observer = null;
  return function observe(node) {
    if (notObserving) {
      notObserving = !notObserving;
      observer = new WeakSet;
      startObserving(node.ownerDocument);
    }
    observer.add(node);
    return node;
  };
  function startObserving(document) {
    var connected = new WeakSet;
    var disconnected = new WeakSet;
    try {
      (new MutationObserver(changes)).observe(
        document,
        {subtree: true, childList: true}
      );
    }
    catch(o_O) {
      var timer = 0;
      var records = [];
      var reschedule = function (record) {
        records.push(record);
        clearTimeout(timer);
        timer = setTimeout(
          function () {
            changes(records.splice(timer = 0, records.length));
          },
          0
        );
      };
      document.addEventListener(
        'DOMNodeRemoved',
        function (event) {
          reschedule({addedNodes: [], removedNodes: [event.target]});
        },
        true
      );
      document.addEventListener(
        'DOMNodeInserted',
        function (event) {
          reschedule({addedNodes: [event.target], removedNodes: []});
        },
        true
      );
    }
    function changes(records) {
      for (var
        record,
        length = records.length,
        i = 0; i < length; i++
      ) {
        record = records[i];
        dispatchAll(record.removedNodes, 'disconnected', disconnected, connected);
        dispatchAll(record.addedNodes, 'connected', connected, disconnected);
      }
    }
    function dispatchAll(nodes, type, wsin, wsout) {
      for (var
        node,
        event = new Event(type),
        length = nodes.length,
        i = 0; i < length;
        (node = nodes[i++]).nodeType === 1 &&
        dispatchTarget(node, event, type, wsin, wsout)
      );
    }
    function dispatchTarget(node, event, type, wsin, wsout) {
      if (observer.has(node) && !wsin.has(node)) {
        wsout.delete(node);
        wsin.add(node);
        node.dispatchEvent(event);
        /*
        // The event is not bubbling (perf reason: should it?),
        // hence there's no way to know if
        // stop/Immediate/Propagation() was called.
        // Should DOM Level 0 work at all?
        // I say it's a YAGNI case for the time being,
        // and easy to implement in user-land.
        if (!event.cancelBubble) {
          var fn = node['on' + type];
          if (fn)
            fn.call(node, event);
        }
        */
      }
      for (var
        // apparently is node.children || IE11 ... ^_^;;
        // https://github.com/WebReflection/disconnected/issues/1
        children = node.children || [],
        length = children.length,
        i = 0; i < length;
        dispatchTarget(children[i++], event, type, wsin, wsout)
      );
    }
  }
}
module.exports = disconnected;


/***/ }),

/***/ "./node_modules/domconstants/cjs/index.js":
/*!************************************************!*\
  !*** ./node_modules/domconstants/cjs/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*! (c) Andrea Giammarchi - ISC */

// Custom
var UID = '-' + Math.random().toFixed(6) + '%';
//                           Edge issue!

var UID_IE = false;

try {
  if (!(function (template, content, tabindex) {
    return content in template && (
      (template.innerHTML = '<p ' + tabindex + '="' + UID + '"></p>'),
      template[content].childNodes[0].getAttribute(tabindex) == UID
    );
  }(document.createElement('template'), 'content', 'tabindex'))) {
    UID = '_dt: ' + UID.slice(1, -1) + ';';
    UID_IE = true;
  }
} catch(meh) {}

var UIDC = '<!--' + UID + '-->';

// DOM
var COMMENT_NODE = 8;
var DOCUMENT_FRAGMENT_NODE = 11;
var ELEMENT_NODE = 1;
var TEXT_NODE = 3;

var SHOULD_USE_TEXT_CONTENT = /^(?:style|textarea)$/i;
var VOID_ELEMENTS = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;

exports.UID = UID;
exports.UIDC = UIDC;
exports.UID_IE = UID_IE;
exports.COMMENT_NODE = COMMENT_NODE;
exports.DOCUMENT_FRAGMENT_NODE = DOCUMENT_FRAGMENT_NODE;
exports.ELEMENT_NODE = ELEMENT_NODE;
exports.TEXT_NODE = TEXT_NODE;
exports.SHOULD_USE_TEXT_CONTENT = SHOULD_USE_TEXT_CONTENT;
exports.VOID_ELEMENTS = VOID_ELEMENTS;


/***/ }),

/***/ "./node_modules/domdiff/cjs/index.js":
/*!*******************************************!*\
  !*** ./node_modules/domdiff/cjs/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*! (c) 2018 Andrea Giammarchi (ISC) */

const {
  eqeq, identity, indexOf, isReversed, next, append, remove, smartDiff
} = __webpack_require__(/*! ./utils.js */ "./node_modules/domdiff/cjs/utils.js");

const domdiff = (
  parentNode,     // where changes happen
  currentNodes,   // Array of current items/nodes
  futureNodes,    // Array of future items/nodes
  options         // optional object with one of the following properties
                  //  before: domNode
                  //  compare(generic, generic) => true if same generic
                  //  node(generic) => Node
) => {
  if (!options)
    options = {};

  const compare = options.compare || eqeq;
  const get = options.node || identity;
  const before = options.before == null ? null : get(options.before, 0);

  const currentLength = currentNodes.length;
  let currentEnd = currentLength;
  let currentStart = 0;

  let futureEnd = futureNodes.length;
  let futureStart = 0;

  // common prefix
  while (
    currentStart < currentEnd &&
    futureStart < futureEnd &&
    compare(currentNodes[currentStart], futureNodes[futureStart])
  ) {
    currentStart++;
    futureStart++;
  }

  // common suffix
  while (
    currentStart < currentEnd &&
    futureStart < futureEnd &&
    compare(currentNodes[currentEnd - 1], futureNodes[futureEnd - 1])
  ) {
    currentEnd--;
    futureEnd--;
  }

  const currentSame = currentStart === currentEnd;
  const futureSame = futureStart === futureEnd;

  // same list
  if (currentSame && futureSame)
    return futureNodes;

  // only stuff to add
  if (currentSame && futureStart < futureEnd) {
    append(
      get,
      parentNode,
      futureNodes,
      futureStart,
      futureEnd,
      next(get, currentNodes, currentStart, currentLength, before)
    );
    return futureNodes;
  }

  // only stuff to remove
  if (futureSame && currentStart < currentEnd) {
    remove(
      get,
      parentNode,
      currentNodes,
      currentStart,
      currentEnd
    );
    return futureNodes;
  }

  const currentChanges = currentEnd - currentStart;
  const futureChanges = futureEnd - futureStart;
  let i = -1;

  // 2 simple indels: the shortest sequence is a subsequence of the longest
  if (currentChanges < futureChanges) {
    i = indexOf(
      futureNodes,
      futureStart,
      futureEnd,
      currentNodes,
      currentStart,
      currentEnd,
      compare
    );
    // inner diff
    if (-1 < i) {
      append(
        get,
        parentNode,
        futureNodes,
        futureStart,
        i,
        get(currentNodes[currentStart], 0)
      );
      append(
        get,
        parentNode,
        futureNodes,
        i + currentChanges,
        futureEnd,
        next(get, currentNodes, currentEnd, currentLength, before)
      );
      return futureNodes;
    }
  }
  /* istanbul ignore else */
  else if (futureChanges < currentChanges) {
    i = indexOf(
      currentNodes,
      currentStart,
      currentEnd,
      futureNodes,
      futureStart,
      futureEnd,
      compare
    );
    // outer diff
    if (-1 < i) {
      remove(
        get,
        parentNode,
        currentNodes,
        currentStart,
        i
      );
      remove(
        get,
        parentNode,
        currentNodes,
        i + futureChanges,
        currentEnd
      );
      return futureNodes;
    }
  }

  // common case with one replacement for many nodes
  // or many nodes replaced for a single one
  /* istanbul ignore else */
  if ((currentChanges < 2 || futureChanges < 2)) {
    append(
      get,
      parentNode,
      futureNodes,
      futureStart,
      futureEnd,
      get(currentNodes[currentStart], 0)
    );
    remove(
      get,
      parentNode,
      currentNodes,
      currentStart,
      currentEnd
    );
    return futureNodes;
  }

  // the half match diff part has been skipped in petit-dom
  // https://github.com/yelouafi/petit-dom/blob/bd6f5c919b5ae5297be01612c524c40be45f14a7/src/vdom.js#L391-L397
  // accordingly, I think it's safe to skip in here too
  // if one day it'll come out like the speediest thing ever to do
  // then I might add it in here too

  // Extra: before going too fancy, what about reversed lists ?
  //        This should bail out pretty quickly if that's not the case.
  if (
    currentChanges === futureChanges &&
    isReversed(
      futureNodes,
      futureEnd,
      currentNodes,
      currentStart,
      currentEnd,
      compare
    )
  ) {
    append(
      get,
      parentNode,
      futureNodes,
      futureStart,
      futureEnd,
      next(get, currentNodes, currentEnd, currentLength, before)
    );
    return futureNodes;
  }

  // last resort through a smart diff
  smartDiff(
    get,
    parentNode,
    futureNodes,
    futureStart,
    futureEnd,
    futureChanges,
    currentNodes,
    currentStart,
    currentEnd,
    currentChanges,
    currentLength,
    compare,
    before
  );

  return futureNodes;
};

Object.defineProperty(exports, '__esModule', {value: true}).default = domdiff;


/***/ }),

/***/ "./node_modules/domdiff/cjs/utils.js":
/*!*******************************************!*\
  !*** ./node_modules/domdiff/cjs/utils.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const Map = (__webpack_require__(/*! @ungap/essential-map */ "./node_modules/@ungap/essential-map/cjs/index.js"));

const {indexOf: iOF} = [];
const append = (get, parent, children, start, end, before) => {
  const isSelect = 'selectedIndex' in parent;
  let noSelection = isSelect;
  while (start < end) {
    const child = get(children[start], 1);
    parent.insertBefore(child, before);
    if (isSelect && noSelection && child.selected) {
      noSelection = !noSelection;
      let {selectedIndex} = parent;
      parent.selectedIndex = selectedIndex < 0 ?
        start :
        iOF.call(parent.querySelectorAll('option'), child);
    }
    start++;
  }
};
exports.append = append;

const eqeq = (a, b) => a == b;
exports.eqeq = eqeq;

const identity = O => O;
exports.identity = identity;

const indexOf = (
  moreNodes,
  moreStart,
  moreEnd,
  lessNodes,
  lessStart,
  lessEnd,
  compare
) => {
  const length = lessEnd - lessStart;
  /* istanbul ignore if */
  if (length < 1)
    return -1;
  while ((moreEnd - moreStart) >= length) {
    let m = moreStart;
    let l = lessStart;
    while (
      m < moreEnd &&
      l < lessEnd &&
      compare(moreNodes[m], lessNodes[l])
    ) {
      m++;
      l++;
    }
    if (l === lessEnd)
      return moreStart;
    moreStart = m + 1;
  }
  return -1;
};
exports.indexOf = indexOf;

const isReversed = (
  futureNodes,
  futureEnd,
  currentNodes,
  currentStart,
  currentEnd,
  compare
) => {
  while (
    currentStart < currentEnd &&
    compare(
      currentNodes[currentStart],
      futureNodes[futureEnd - 1]
    )) {
      currentStart++;
      futureEnd--;
    };
  return futureEnd === 0;
};
exports.isReversed = isReversed;

const next = (get, list, i, length, before) => i < length ?
              get(list[i], 0) :
              (0 < i ?
                get(list[i - 1], -0).nextSibling :
                before);
exports.next = next;

const remove = (get, parent, children, start, end) => {
  while (start < end)
    removeChild(get(children[start++], -1), parent);
};
exports.remove = remove;

// - - - - - - - - - - - - - - - - - - -
// diff related constants and utilities
// - - - - - - - - - - - - - - - - - - -

const DELETION = -1;
const INSERTION = 1;
const SKIP = 0;
const SKIP_OND = 50;

const HS = (
  futureNodes,
  futureStart,
  futureEnd,
  futureChanges,
  currentNodes,
  currentStart,
  currentEnd,
  currentChanges
) => {

  let k = 0;
  /* istanbul ignore next */
  let minLen = futureChanges < currentChanges ? futureChanges : currentChanges;
  const link = Array(minLen++);
  const tresh = Array(minLen);
  tresh[0] = -1;

  for (let i = 1; i < minLen; i++)
    tresh[i] = currentEnd;

  const keymap = new Map;
  for (let i = currentStart; i < currentEnd; i++)
    keymap.set(currentNodes[i], i);

  for (let i = futureStart; i < futureEnd; i++) {
    const idxInOld = keymap.get(futureNodes[i]);
    if (idxInOld != null) {
      k = findK(tresh, minLen, idxInOld);
      /* istanbul ignore else */
      if (-1 < k) {
        tresh[k] = idxInOld;
        link[k] = {
          newi: i,
          oldi: idxInOld,
          prev: link[k - 1]
        };
      }
    }
  }

  k = --minLen;
  --currentEnd;
  while (tresh[k] > currentEnd) --k;

  minLen = currentChanges + futureChanges - k;
  const diff = Array(minLen);
  let ptr = link[k];
  --futureEnd;
  while (ptr) {
    const {newi, oldi} = ptr;
    while (futureEnd > newi) {
      diff[--minLen] = INSERTION;
      --futureEnd;
    }
    while (currentEnd > oldi) {
      diff[--minLen] = DELETION;
      --currentEnd;
    }
    diff[--minLen] = SKIP;
    --futureEnd;
    --currentEnd;
    ptr = ptr.prev;
  }
  while (futureEnd >= futureStart) {
    diff[--minLen] = INSERTION;
    --futureEnd;
  }
  while (currentEnd >= currentStart) {
    diff[--minLen] = DELETION;
    --currentEnd;
  }
  return diff;
};

// this is pretty much the same petit-dom code without the delete map part
// https://github.com/yelouafi/petit-dom/blob/bd6f5c919b5ae5297be01612c524c40be45f14a7/src/vdom.js#L556-L561
const OND = (
  futureNodes,
  futureStart,
  rows,
  currentNodes,
  currentStart,
  cols,
  compare
) => {
  const length = rows + cols;
  const v = [];
  let d, k, r, c, pv, cv, pd;
  outer: for (d = 0; d <= length; d++) {
    /* istanbul ignore if */
    if (d > SKIP_OND)
      return null;
    pd = d - 1;
    /* istanbul ignore next */
    pv = d ? v[d - 1] : [0, 0];
    cv = v[d] = [];
    for (k = -d; k <= d; k += 2) {
      if (k === -d || (k !== d && pv[pd + k - 1] < pv[pd + k + 1])) {
        c = pv[pd + k + 1];
      } else {
        c = pv[pd + k - 1] + 1;
      }
      r = c - k;
      while (
        c < cols &&
        r < rows &&
        compare(
          currentNodes[currentStart + c],
          futureNodes[futureStart + r]
        )
      ) {
        c++;
        r++;
      }
      if (c === cols && r === rows) {
        break outer;
      }
      cv[d + k] = c;
    }
  }

  const diff = Array(d / 2 + length / 2);
  let diffIdx = diff.length - 1;
  for (d = v.length - 1; d >= 0; d--) {
    while (
      c > 0 &&
      r > 0 &&
      compare(
        currentNodes[currentStart + c - 1],
        futureNodes[futureStart + r - 1]
      )
    ) {
      // diagonal edge = equality
      diff[diffIdx--] = SKIP;
      c--;
      r--;
    }
    if (!d)
      break;
    pd = d - 1;
    /* istanbul ignore next */
    pv = d ? v[d - 1] : [0, 0];
    k = c - r;
    if (k === -d || (k !== d && pv[pd + k - 1] < pv[pd + k + 1])) {
      // vertical edge = insertion
      r--;
      diff[diffIdx--] = INSERTION;
    } else {
      // horizontal edge = deletion
      c--;
      diff[diffIdx--] = DELETION;
    }
  }
  return diff;
};

const applyDiff = (
  diff,
  get,
  parentNode,
  futureNodes,
  futureStart,
  currentNodes,
  currentStart,
  currentLength,
  before
) => {
  const live = new Map;
  const length = diff.length;
  let currentIndex = currentStart;
  let i = 0;
  while (i < length) {
    switch (diff[i++]) {
      case SKIP:
        futureStart++;
        currentIndex++;
        break;
      case INSERTION:
        // TODO: bulk appends for sequential nodes
        live.set(futureNodes[futureStart], 1);
        append(
          get,
          parentNode,
          futureNodes,
          futureStart++,
          futureStart,
          currentIndex < currentLength ?
            get(currentNodes[currentIndex], 0) :
            before
        );
        break;
      case DELETION:
        currentIndex++;
        break;
    }
  }
  i = 0;
  while (i < length) {
    switch (diff[i++]) {
      case SKIP:
        currentStart++;
        break;
      case DELETION:
        // TODO: bulk removes for sequential nodes
        if (live.has(currentNodes[currentStart]))
          currentStart++;
        else
          remove(
            get,
            parentNode,
            currentNodes,
            currentStart++,
            currentStart
          );
        break;
    }
  }
};

const findK = (ktr, length, j) => {
  let lo = 1;
  let hi = length;
  while (lo < hi) {
    const mid = ((lo + hi) / 2) >>> 0;
    if (j < ktr[mid])
      hi = mid;
    else
      lo = mid + 1;
  }
  return lo;
}

const smartDiff = (
  get,
  parentNode,
  futureNodes,
  futureStart,
  futureEnd,
  futureChanges,
  currentNodes,
  currentStart,
  currentEnd,
  currentChanges,
  currentLength,
  compare,
  before
) => {
  applyDiff(
    OND(
      futureNodes,
      futureStart,
      futureChanges,
      currentNodes,
      currentStart,
      currentChanges,
      compare
    ) ||
    HS(
      futureNodes,
      futureStart,
      futureEnd,
      futureChanges,
      currentNodes,
      currentStart,
      currentEnd,
      currentChanges
    ),
    get,
    parentNode,
    futureNodes,
    futureStart,
    currentNodes,
    currentStart,
    currentLength,
    before
  );
};
exports.smartDiff = smartDiff;

let removeChild = (child, parentNode) => {
  /* istanbul ignore if */
  // if ('remove' in child) {
  //   removeChild = child => {
  //     child.remove();
  //   };
  // }
  // else {
    removeChild = (child, parentNode) => {
      /* istanbul ignore else */
      if (child.parentNode === parentNode)
        parentNode.removeChild(child);
    };
  // }
  removeChild(child, parentNode);
};


/***/ }),

/***/ "./node_modules/domsanitizer/cjs/index.js":
/*!************************************************!*\
  !*** ./node_modules/domsanitizer/cjs/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*! (c) Andrea Giammarchi - ISC */

const {UID, UIDC, VOID_ELEMENTS} = __webpack_require__(/*! domconstants */ "./node_modules/domconstants/cjs/index.js");

Object.defineProperty(exports, '__esModule', {value: true}).default = function (template) {
  return template.join(UIDC)
          .replace(selfClosing, fullClosing)
          .replace(attrSeeker, attrReplacer);
}

var spaces = ' \\f\\n\\r\\t';
var almostEverything = '[^' + spaces + '\\/>"\'=]+';
var attrName = '[' + spaces + ']+' + almostEverything;
var tagName = '<([A-Za-z]+[A-Za-z0-9:._-]*)((?:';
var attrPartials = '(?:\\s*=\\s*(?:\'[^\']*?\'|"[^"]*?"|<[^>]*?>|' + almostEverything.replace('\\/', '') + '))?)';

var attrSeeker = new RegExp(tagName + attrName + attrPartials + '+)([' + spaces + ']*/?>)', 'g');
var selfClosing = new RegExp(tagName + attrName + attrPartials + '*)([' + spaces + ']*/>)', 'g');
var findAttributes = new RegExp('(' + attrName + '\\s*=\\s*)([\'"]?)' + UIDC + '\\2', 'gi');

function attrReplacer($0, $1, $2, $3) {
  return '<' + $1 + $2.replace(findAttributes, replaceAttributes) + $3;
}

function replaceAttributes($0, $1, $2) {
  return $1 + ($2 || '"') + UID + ($2 || '"');
}

function fullClosing($0, $1, $2) {
  return VOID_ELEMENTS.test($1) ? $0 : ('<' + $1 + $2 + '></' + $1 + '>');
}


/***/ }),

/***/ "./node_modules/domtagger/cjs/index.js":
/*!*********************************************!*\
  !*** ./node_modules/domtagger/cjs/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// globals
const WeakMap = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! @ungap/weakmap */ "./node_modules/@ungap/weakmap/cjs/index.js"));

// utils
const createContent = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! @ungap/create-content */ "./node_modules/@ungap/create-content/cjs/index.js"));
const importNode = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! @ungap/import-node */ "./node_modules/@ungap/import-node/cjs/index.js"));
const trim = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! @ungap/trim */ "./node_modules/@ungap/trim/cjs/index.js"));
const sanitize = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! domsanitizer */ "./node_modules/domsanitizer/cjs/index.js"));

// local
const {find, parse} = __webpack_require__(/*! ./walker.js */ "./node_modules/domtagger/cjs/walker.js");

// the domtagger 
Object.defineProperty(exports, '__esModule', {value: true}).default = domtagger;

var parsed = new WeakMap;
var referenced = new WeakMap;

function createInfo(options, template) {
  var markup = (options.convert || sanitize)(template);
  var transform = options.transform;
  if (transform)
    markup = transform(markup);
  var content = createContent(markup, options.type);
  cleanContent(content);
  var holes = [];
  parse(content, holes, template.slice(0), []);
  var info = {
    content: content,
    updates: function (content) {
      var updates = [];
      var len = holes.length;
      var i = 0;
      var off = 0;
      while (i < len) {
        var info = holes[i++];
        var node = find(content, info.path);
        switch (info.type) {
          case 'any':
            updates.push({fn: options.any(node, []), sparse: false});
            break;
          case 'attr':
            var sparse = info.sparse;
            var fn = options.attribute(node, info.name, info.node);
            if (sparse === null)
              updates.push({fn: fn, sparse: false});
            else {
              off += sparse.length - 2;
              updates.push({fn: fn, sparse: true, values: sparse});
            }
            break;
          case 'text':
            updates.push({fn: options.text(node), sparse: false});
            node.textContent = '';
            break;
        }
      }
      len += off;
      return function () {
        var length = arguments.length;
        if (len !== (length - 1)) {
          throw new Error(
            (length - 1) + ' values instead of ' + len + '\n' +
            template.join('${value}')
          );
        }
        var i = 1;
        var off = 1;
        while (i < length) {
          var update = updates[i - off];
          if (update.sparse) {
            var values = update.values;
            var value = values[0];
            var j = 1;
            var l = values.length;
            off += l - 2;
            while (j < l)
              value += arguments[i++] + values[j++];
            update.fn(value);
          }
          else
            update.fn(arguments[i++]);
        }
        return content;
      };
    }
  };
  parsed.set(template, info);
  return info;
}

function createDetails(options, template) {
  var info = parsed.get(template) || createInfo(options, template);
  var content = importNode.call(document, info.content, true);
  var details = {
    content: content,
    template: template,
    updates: info.updates(content)
  };
  referenced.set(options, details);
  return details;
}

function domtagger(options) {
  return function (template) {
    var details = referenced.get(options);
    if (details == null || details.template !== template)
      details = createDetails(options, template);
    details.updates.apply(null, arguments);
    return details.content;
  };
}

function cleanContent(fragment) {
  var childNodes = fragment.childNodes;
  var i = childNodes.length;
  while (i--) {
    var child = childNodes[i];
    if (
      child.nodeType !== 1 &&
      trim.call(child.textContent).length === 0
    ) {
      fragment.removeChild(child);
    }
  }
}


/***/ }),

/***/ "./node_modules/domtagger/cjs/walker.js":
/*!**********************************************!*\
  !*** ./node_modules/domtagger/cjs/walker.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const Map = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! @ungap/essential-map */ "./node_modules/@ungap/essential-map/cjs/index.js"));
const trim = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! @ungap/trim */ "./node_modules/@ungap/trim/cjs/index.js"));

const {
  UID, UIDC, UID_IE, COMMENT_NODE, ELEMENT_NODE, SHOULD_USE_TEXT_CONTENT, TEXT_NODE
} = __webpack_require__(/*! domconstants */ "./node_modules/domconstants/cjs/index.js");

exports.find = find;
exports.parse = parse;

function find(node, path) {
  var length = path.length;
  var i = 0;
  while (i < length)
    node = node.childNodes[path[i++]];
  return node;
}

function parse(node, holes, parts, path) {
  var childNodes = node.childNodes;
  var length = childNodes.length;
  var i = 0;
  while (i < length) {
    var child = childNodes[i];
    switch (child.nodeType) {
      case ELEMENT_NODE:
        var childPath = path.concat(i);
        parseAttributes(child, holes, parts, childPath);
        parse(child, holes, parts, childPath);
        break;
      case COMMENT_NODE:
        var textContent = child.textContent;
        if (textContent === UID) {
          parts.shift();
          holes.push(
            // basicHTML or other non standard engines
            // might end up having comments in nodes
            // where they shouldn't, hence this check.
            SHOULD_USE_TEXT_CONTENT.test(node.nodeName) ?
              Text(node, path) :
              Any(child, path.concat(i))
          );
        } else {
          switch (textContent.slice(0, 2)) {
            case '/*':
              if (textContent.slice(-2) !== '*/')
                break;
            case '\uD83D\uDC7B': // ghost
              node.removeChild(child);
              i--;
              length--;
          }
        }
        break;
      case TEXT_NODE:
        // the following ignore is actually covered by browsers
        // only basicHTML ends up on previous COMMENT_NODE case
        // instead of TEXT_NODE because it knows nothing about
        // special style or textarea behavior
        /* istanbul ignore if */
        if (
          SHOULD_USE_TEXT_CONTENT.test(node.nodeName) &&
          trim.call(child.textContent) === UIDC
        ) {
          parts.shift();
          holes.push(Text(node, path));
        }
        break;
    }
    i++;
  }
}

function parseAttributes(node, holes, parts, path) {
  var cache = new Map;
  var attributes = node.attributes;
  var remove = [];
  var array = remove.slice.call(attributes, 0);
  var length = array.length;
  var i = 0;
  while (i < length) {
    var attribute = array[i++];
    var direct = attribute.value === UID;
    var sparse;
    if (direct || 1 < (sparse = attribute.value.split(UIDC)).length) {
      var name = attribute.name;
      // the following ignore is covered by IE
      // and the IE9 double viewBox test
      /* istanbul ignore else */
      if (!cache.has(name)) {
        var realName = parts.shift().replace(
          direct ?
            /^(?:|[\S\s]*?\s)(\S+?)\s*=\s*('|")?$/ :
            // TODO: while working on yet another IE/Edge bug I've realized
            //        the current not direct logic easily breaks there
            //        because the `name` might not be the real needed one.
            //        Use a better RegExp to find last attribute instead
            //        of trusting `name` is what we are looking for.
            //        Thanks IE/Edge, I hate you both.
            new RegExp(
              '^(?:|[\\S\\s]*?\\s)(' + name + ')\\s*=\\s*(\'|")',
              'i'
            ),
            '$1'
        );
        var value = attributes[realName] ||
                      // the following ignore is covered by browsers
                      // while basicHTML is already case-sensitive
                      /* istanbul ignore next */
                      attributes[realName.toLowerCase()];
        cache.set(name, value);
        if (direct)
          holes.push(Attr(value, path, realName, null));
        else {
          var skip = sparse.length - 2;
          while (skip--)
            parts.shift();
          holes.push(Attr(value, path, realName, sparse));
        }
      }
      remove.push(attribute);
    }
  }
  length = remove.length;
  i = 0;

  /* istanbul ignore next */
  var cleanValue = 0 < length && UID_IE && !('ownerSVGElement' in node);
  while (i < length) {
    // Edge HTML bug #16878726
    var attr = remove[i++];
    // IE/Edge bug lighterhtml#63 - clean the value or it'll persist
    /* istanbul ignore next */
    if (cleanValue)
      attr.value = '';
    // IE/Edge bug lighterhtml#64 - don't use removeAttributeNode
    node.removeAttribute(attr.name);
  }

  // This is a very specific Firefox/Safari issue
  // but since it should be a not so common pattern,
  // it's probably worth patching regardless.
  // Basically, scripts created through strings are death.
  // You need to create fresh new scripts instead.
  // TODO: is there any other node that needs such nonsense?
  var nodeName = node.nodeName;
  if (/^script$/i.test(nodeName)) {
    // this used to be like that
    // var script = createElement(node, nodeName);
    // then Edge arrived and decided that scripts created
    // through template documents aren't worth executing
    // so it became this ... hopefully it won't hurt in the wild
    var script = document.createElement(nodeName);
    length = attributes.length;
    i = 0;
    while (i < length)
      script.setAttributeNode(attributes[i++].cloneNode(true));
    script.textContent = node.textContent;
    node.parentNode.replaceChild(script, node);
  }
}

function Any(node, path) {
  return {
    type: 'any',
    node: node,
    path: path
  };
}

function Attr(node, path, name, sparse) {
  return {
    type: 'attr',
    node: node,
    path: path,
    name: name,
    sparse: sparse
  };
}

function Text(node, path) {
  return {
    type: 'text',
    node: node,
    path: path
  };
}


/***/ }),

/***/ "./node_modules/hyperhtml-style/cjs/index.js":
/*!***************************************************!*\
  !*** ./node_modules/hyperhtml-style/cjs/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*! (c) Andrea Giammarchi - ISC */
var hyperStyle = (function (){'use strict';
  // from https://github.com/developit/preact/blob/33fc697ac11762a1cb6e71e9847670d047af7ce5/src/varants.js
  var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
  var hyphen = /([^A-Z])([A-Z]+)/g;
  return function hyperStyle(node, original) {
    return 'ownerSVGElement' in node ? svg(node, original) : update(node.style, false);
  };
  function ized($0, $1, $2) {
    return $1 + '-' + $2.toLowerCase();
  }
  function svg(node, original) {
    var style;
    if (original)
      style = original.cloneNode(true);
    else {
      node.setAttribute('style', '--hyper:style;');
      style = node.getAttributeNode('style');
    }
    style.value = '';
    node.setAttributeNode(style);
    return update(style, true);
  }
  function toStyle(object) {
    var key, css = [];
    for (key in object)
      css.push(key.replace(hyphen, ized), ':', object[key], ';');
    return css.join('');
  }
  function update(style, isSVG) {
    var oldType, oldValue;
    return function (newValue) {
      var info, key, styleValue, value;
      switch (typeof newValue) {
        case 'object':
          if (newValue) {
            if (oldType === 'object') {
              if (!isSVG) {
                if (oldValue !== newValue) {
                  for (key in oldValue) {
                    if (!(key in newValue)) {
                      style[key] = '';
                    }
                  }
                }
              }
            } else {
              if (isSVG)
                style.value = '';
              else
                style.cssText = '';
            }
            info = isSVG ? {} : style;
            for (key in newValue) {
              value = newValue[key];
              styleValue = typeof value === 'number' &&
                                  !IS_NON_DIMENSIONAL.test(key) ?
                                  (value + 'px') : value;
              if (!isSVG && /^--/.test(key))
                info.setProperty(key, styleValue);
              else
                info[key] = styleValue;
            }
            oldType = 'object';
            if (isSVG)
              style.value = toStyle((oldValue = info));
            else
              oldValue = newValue;
            break;
          }
        default:
          if (oldValue != newValue) {
            oldType = 'string';
            oldValue = newValue;
            if (isSVG)
              style.value = newValue || '';
            else
              style.cssText = newValue || '';
          }
          break;
      }
    };
  }
}());
module.exports = hyperStyle;


/***/ }),

/***/ "./node_modules/hyperhtml-wire/cjs/index.js":
/*!**************************************************!*\
  !*** ./node_modules/hyperhtml-wire/cjs/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*! (c) Andrea Giammarchi - ISC */
var Wire = (function (slice, proto) {

  proto = Wire.prototype;

  proto.ELEMENT_NODE = 1;
  proto.nodeType = 111;

  proto.remove = function (keepFirst) {
    var childNodes = this.childNodes;
    var first = this.firstChild;
    var last = this.lastChild;
    this._ = null;
    if (keepFirst && childNodes.length === 2) {
      last.parentNode.removeChild(last);
    } else {
      var range = this.ownerDocument.createRange();
      range.setStartBefore(keepFirst ? childNodes[1] : first);
      range.setEndAfter(last);
      range.deleteContents();
    }
    return first;
  };

  proto.valueOf = function (forceAppend) {
    var fragment = this._;
    var noFragment = fragment == null;
    if (noFragment)
      fragment = (this._ = this.ownerDocument.createDocumentFragment());
    if (noFragment || forceAppend) {
      for (var n = this.childNodes, i = 0, l = n.length; i < l; i++)
        fragment.appendChild(n[i]);
    }
    return fragment;
  };

  return Wire;

  function Wire(childNodes) {
    var nodes = (this.childNodes = slice.call(childNodes, 0));
    this.firstChild = nodes[0];
    this.lastChild = nodes[nodes.length - 1];
    this.ownerDocument = nodes[0].ownerDocument;
    this._ = null;
  }

}([].slice));
module.exports = Wire;


/***/ }),

/***/ "./node_modules/hyperhtml/cjs/classes/Component.js":
/*!*********************************************************!*\
  !*** ./node_modules/hyperhtml/cjs/classes/Component.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const CustomEvent = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! @ungap/custom-event */ "./node_modules/@ungap/custom-event/cjs/index.js"));
const Map = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! @ungap/essential-map */ "./node_modules/@ungap/essential-map/cjs/index.js"));
const WeakMap = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! @ungap/weakmap */ "./node_modules/@ungap/weakmap/cjs/index.js"));

// hyperHTML.Component is a very basic class
// able to create Custom Elements like components
// including the ability to listen to connect/disconnect
// events via onconnect/ondisconnect attributes
// Components can be created imperatively or declaratively.
// The main difference is that declared components
// will not automatically render on setState(...)
// to simplify state handling on render.
function Component() {
  return this; // this is needed in Edge !!!
}
Object.defineProperty(exports, '__esModule', {value: true}).default = Component

// Component is lazily setup because it needs
// wire mechanism as lazy content
function setup(content) {
  // there are various weakly referenced variables in here
  // and mostly are to use Component.for(...) static method.
  const children = new WeakMap;
  const create = Object.create;
  const createEntry = (wm, id, component) => {
    wm.set(id, component);
    return component;
  };
  const get = (Class, info, context, id) => {
    const relation = info.get(Class) || relate(Class, info);
    switch (typeof id) {
      case 'object':
      case 'function':
        const wm = relation.w || (relation.w = new WeakMap);
        return wm.get(id) || createEntry(wm, id, new Class(context));
      default:
        const sm = relation.p || (relation.p = create(null));
        return sm[id] || (sm[id] = new Class(context));
    }
  };
  const relate = (Class, info) => {
    const relation = {w: null, p: null};
    info.set(Class, relation);
    return relation;
  };
  const set = context => {
    const info = new Map;
    children.set(context, info);
    return info;
  };
  // The Component Class
  Object.defineProperties(
    Component,
    {
      // Component.for(context[, id]) is a convenient way
      // to automatically relate data/context to children components
      // If not created yet, the new Component(context) is weakly stored
      // and after that same instance would always be returned.
      for: {
        configurable: true,
        value(context, id) {
          return get(
            this,
            children.get(context) || set(context),
            context,
            id == null ?
              'default' : id
          );
        }
      }
    }
  );
  Object.defineProperties(
    Component.prototype,
    {
      // all events are handled with the component as context
      handleEvent: {value(e) {
        const ct = e.currentTarget;
        this[
          ('getAttribute' in ct && ct.getAttribute('data-call')) ||
          ('on' + e.type)
        ](e);
      }},
      // components will lazily define html or svg properties
      // as soon as these are invoked within the .render() method
      // Such render() method is not provided by the base class
      // but it must be available through the Component extend.
      // Declared components could implement a
      // render(props) method too and use props as needed.
      html: lazyGetter('html', content),
      svg: lazyGetter('svg', content),
      // the state is a very basic/simple mechanism inspired by Preact
      state: lazyGetter('state', function () { return this.defaultState; }),
      // it is possible to define a default state that'd be always an object otherwise
      defaultState: {get() { return {}; }},
      // dispatch a bubbling, cancelable, custom event
      // through the first known/available node
      dispatch: {value(type, detail) {
        const {_wire$} = this;
        if (_wire$) {
          const event = new CustomEvent(type, {
            bubbles: true,
            cancelable: true,
            detail
          });
          event.component = this;
          return (_wire$.dispatchEvent ?
                    _wire$ :
                    _wire$.firstChild
                  ).dispatchEvent(event);
        }
        return false;
      }},
      // setting some property state through a new object
      // or a callback, triggers also automatically a render
      // unless explicitly specified to not do so (render === false)
      setState: {value(state, render) {
        const target = this.state;
        const source = typeof state === 'function' ? state.call(this, target) : state;
        for (const key in source) target[key] = source[key];
        if (render !== false)
          this.render();
        return this;
      }}
    }
  );
}
exports.setup = setup

// instead of a secret key I could've used a WeakMap
// However, attaching a property directly will result
// into better performance with thousands of components
// hanging around, and less memory pressure caused by the WeakMap
const lazyGetter = (type, fn) => {
  const secret = '_' + type + '$';
  return {
    get() {
      return this[secret] || setValue(this, secret, fn.call(this, type));
    },
    set(value) {
      setValue(this, secret, value);
    }
  };
};

// shortcut to set value on get or set(value)
const setValue = (self, secret, value) =>
  Object.defineProperty(self, secret, {
    configurable: true,
    value: typeof value === 'function' ?
      function () {
        return (self._wire$ = value.apply(this, arguments));
      } :
      value
  })[secret]
;

Object.defineProperties(
  Component.prototype,
  {
    // used to distinguish better than instanceof
    ELEMENT_NODE: {value: 1},
    nodeType: {value: -1}
  }
);


/***/ }),

/***/ "./node_modules/hyperhtml/cjs/hyper/render.js":
/*!****************************************************!*\
  !*** ./node_modules/hyperhtml/cjs/hyper/render.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const WeakMap = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! @ungap/weakmap */ "./node_modules/@ungap/weakmap/cjs/index.js"));
const tta = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! @ungap/template-tag-arguments */ "./node_modules/@ungap/template-tag-arguments/cjs/index.js"));

const {OWNER_SVG_ELEMENT} = __webpack_require__(/*! ../shared/constants.js */ "./node_modules/hyperhtml/cjs/shared/constants.js");
const {Tagger} = __webpack_require__(/*! ../objects/Updates.js */ "./node_modules/hyperhtml/cjs/objects/Updates.js");

// a weak collection of contexts that
// are already known to hyperHTML
const bewitched = new WeakMap;

// better known as hyper.bind(node), the render is
// the main tag function in charge of fully upgrading
// or simply updating, contexts used as hyperHTML targets.
// The `this` context is either a regular DOM node or a fragment.
function render() {
  const wicked = bewitched.get(this);
  const args = tta.apply(null, arguments);
  if (wicked && wicked.template === args[0]) {
    wicked.tagger.apply(null, args);
  } else {
    upgrade.apply(this, args);
  }
  return this;
}

// an upgrade is in charge of collecting template info,
// parse it once, if unknown, to map all interpolations
// as single DOM callbacks, relate such template
// to the current context, and render it after cleaning the context up
function upgrade(template) {
  const type = OWNER_SVG_ELEMENT in this ? 'svg' : 'html';
  const tagger = new Tagger(type);
  bewitched.set(this, {tagger, template: template});
  this.textContent = '';
  this.appendChild(tagger.apply(null, arguments));
}

Object.defineProperty(exports, '__esModule', {value: true}).default = render;


/***/ }),

/***/ "./node_modules/hyperhtml/cjs/hyper/wire.js":
/*!**************************************************!*\
  !*** ./node_modules/hyperhtml/cjs/hyper/wire.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const WeakMap = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! @ungap/weakmap */ "./node_modules/@ungap/weakmap/cjs/index.js"));
const tta = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! @ungap/template-tag-arguments */ "./node_modules/@ungap/template-tag-arguments/cjs/index.js"));

const Wire = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! hyperhtml-wire */ "./node_modules/hyperhtml-wire/cjs/index.js"));

const {Tagger} = __webpack_require__(/*! ../objects/Updates.js */ "./node_modules/hyperhtml/cjs/objects/Updates.js");

// all wires used per each context
const wires = new WeakMap;

// A wire is a callback used as tag function
// to lazily relate a generic object to a template literal.
// hyper.wire(user)`<div id=user>${user.name}</div>`; => the div#user
// This provides the ability to have a unique DOM structure
// related to a unique JS object through a reusable template literal.
// A wire can specify a type, as svg or html, and also an id
// via html:id or :id convention. Such :id allows same JS objects
// to be associated to different DOM structures accordingly with
// the used template literal without losing previously rendered parts.
const wire = (obj, type) => obj == null ?
  content(type || 'html') :
  weakly(obj, type || 'html');

// A wire content is a virtual reference to one or more nodes.
// It's represented by either a DOM node, or an Array.
// In both cases, the wire content role is to simply update
// all nodes through the list of related callbacks.
// In few words, a wire content is like an invisible parent node
// in charge of updating its content like a bound element would do.
const content = type => {
  let wire, tagger, template;
  return function () {
    const args = tta.apply(null, arguments);
    if (template !== args[0]) {
      template = args[0];
      tagger = new Tagger(type);
      wire = wireContent(tagger.apply(tagger, args));
    } else {
      tagger.apply(tagger, args);
    }
    return wire;
  };
};

// wires are weakly created through objects.
// Each object can have multiple wires associated
// and this is thanks to the type + :id feature.
const weakly = (obj, type) => {
  const i = type.indexOf(':');
  let wire = wires.get(obj);
  let id = type;
  if (-1 < i) {
    id = type.slice(i + 1);
    type = type.slice(0, i) || 'html';
  }
  if (!wire)
    wires.set(obj, wire = {});
  return wire[id] || (wire[id] = content(type));
};

// A document fragment loses its nodes 
// as soon as it is appended into another node.
// This has the undesired effect of losing wired content
// on a second render call, because (by then) the fragment would be empty:
// no longer providing access to those sub-nodes that ultimately need to
// stay associated with the original interpolation.
// To prevent hyperHTML from forgetting about a fragment's sub-nodes,
// fragments are instead returned as an Array of nodes or, if there's only one entry,
// as a single referenced node which, unlike fragments, will indeed persist
// wire content throughout multiple renderings.
// The initial fragment, at this point, would be used as unique reference to this
// array of nodes or to this single referenced node.
const wireContent = node => {
  const childNodes = node.childNodes;
  const {length} = childNodes;
  return length === 1 ?
    childNodes[0] :
    (length ? new Wire(childNodes) : node);
};

exports.content = content;
exports.weakly = weakly;
Object.defineProperty(exports, '__esModule', {value: true}).default = wire;


/***/ }),

/***/ "./node_modules/hyperhtml/cjs/index.js":
/*!*********************************************!*\
  !*** ./node_modules/hyperhtml/cjs/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*! (c) Andrea Giammarchi (ISC) */
const WeakMap = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! @ungap/weakmap */ "./node_modules/@ungap/weakmap/cjs/index.js"));
const WeakSet = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! @ungap/essential-weakset */ "./node_modules/@ungap/essential-weakset/cjs/index.js"));

const diff = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! domdiff */ "./node_modules/domdiff/cjs/index.js"));
const Component = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! ./classes/Component.js */ "./node_modules/hyperhtml/cjs/classes/Component.js"));
const {setup} = __webpack_require__(/*! ./classes/Component.js */ "./node_modules/hyperhtml/cjs/classes/Component.js");
const Intent = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! ./objects/Intent.js */ "./node_modules/hyperhtml/cjs/objects/Intent.js"));
const {observe, Tagger} = __webpack_require__(/*! ./objects/Updates.js */ "./node_modules/hyperhtml/cjs/objects/Updates.js");
const wire = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! ./hyper/wire.js */ "./node_modules/hyperhtml/cjs/hyper/wire.js"));
const {content, weakly} = __webpack_require__(/*! ./hyper/wire.js */ "./node_modules/hyperhtml/cjs/hyper/wire.js");
const render = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! ./hyper/render.js */ "./node_modules/hyperhtml/cjs/hyper/render.js"));

// all functions are self bound to the right context
// you can do the following
// const {bind, wire} = hyperHTML;
// and use them right away: bind(node)`hello!`;
const bind = context => render.bind(context);
const define = Intent.define;
const tagger = Tagger.prototype;

hyper.Component = Component;
hyper.bind = bind;
hyper.define = define;
hyper.diff = diff;
hyper.hyper = hyper;
hyper.observe = observe;
hyper.tagger = tagger;
hyper.wire = wire;

// exported as shared utils
// for projects based on hyperHTML
// that don't necessarily need upfront polyfills
// i.e. those still targeting IE
hyper._ = {
  WeakMap,
  WeakSet
};

// the wire content is the lazy defined
// html or svg property of each hyper.Component
setup(content);

// everything is exported directly or through the
// hyperHTML callback, when used as top level script
exports.Component = Component;
exports.bind = bind;
exports.define = define;
exports.diff = diff;
exports.hyper = hyper;
exports.observe = observe;
exports.tagger = tagger;
exports.wire = wire;

// by default, hyperHTML is a smart function
// that "magically" understands what's the best
// thing to do with passed arguments
function hyper(HTML) {
  return arguments.length < 2 ?
    (HTML == null ?
      content('html') :
      (typeof HTML === 'string' ?
        hyper.wire(null, HTML) :
        ('raw' in HTML ?
          content('html')(HTML) :
          ('nodeType' in HTML ?
            hyper.bind(HTML) :
            weakly(HTML, 'html')
          )
        )
      )) :
    ('raw' in HTML ?
      content('html') : hyper.wire
    ).apply(null, arguments);
}
Object.defineProperty(exports, '__esModule', {value: true}).default = hyper


/***/ }),

/***/ "./node_modules/hyperhtml/cjs/objects/Intent.js":
/*!******************************************************!*\
  !*** ./node_modules/hyperhtml/cjs/objects/Intent.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const attributes = {};
const intents = {};
const keys = [];
const hasOwnProperty = intents.hasOwnProperty;

let length = 0;

Object.defineProperty(exports, '__esModule', {value: true}).default = {

  // used to invoke right away hyper:attributes
  attributes,

  // hyperHTML.define('intent', (object, update) => {...})
  // can be used to define a third parts update mechanism
  // when every other known mechanism failed.
  // hyper.define('user', info => info.name);
  // hyper(node)`<p>${{user}}</p>`;
  define: (intent, callback) => {
    if (intent.indexOf('-') < 0) {
      if (!(intent in intents)) {
        length = keys.push(intent);
      }
      intents[intent] = callback;
    } else {
      attributes[intent] = callback;
    }
  },

  // this method is used internally as last resort
  // to retrieve a value out of an object
  invoke: (object, callback) => {
    for (let i = 0; i < length; i++) {
      let key = keys[i];
      if (hasOwnProperty.call(object, key)) {
        return intents[key](object[key], callback);
      }
    }
  }
};


/***/ }),

/***/ "./node_modules/hyperhtml/cjs/objects/Updates.js":
/*!*******************************************************!*\
  !*** ./node_modules/hyperhtml/cjs/objects/Updates.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const CustomEvent = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! @ungap/custom-event */ "./node_modules/@ungap/custom-event/cjs/index.js"));
const WeakSet = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! @ungap/essential-weakset */ "./node_modules/@ungap/essential-weakset/cjs/index.js"));
const isArray = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! @ungap/is-array */ "./node_modules/@ungap/is-array/cjs/index.js"));
const createContent = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! @ungap/create-content */ "./node_modules/@ungap/create-content/cjs/index.js"));

const disconnected = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! disconnected */ "./node_modules/disconnected/cjs/index.js"));
const domdiff = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! domdiff */ "./node_modules/domdiff/cjs/index.js"));
const domtagger = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! domtagger */ "./node_modules/domtagger/cjs/index.js"));
const hyperStyle = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! hyperhtml-style */ "./node_modules/hyperhtml-style/cjs/index.js"));
const Wire = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! hyperhtml-wire */ "./node_modules/hyperhtml-wire/cjs/index.js"));

const {
  CONNECTED, DISCONNECTED, DOCUMENT_FRAGMENT_NODE, OWNER_SVG_ELEMENT
} = __webpack_require__(/*! ../shared/constants.js */ "./node_modules/hyperhtml/cjs/shared/constants.js");

const Component = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! ../classes/Component.js */ "./node_modules/hyperhtml/cjs/classes/Component.js"));
const Intent = (m => m.__esModule ? /* istanbul ignore next */ m.default : /* istanbul ignore next */ m)(__webpack_require__(/*! ./Intent.js */ "./node_modules/hyperhtml/cjs/objects/Intent.js"));

const componentType = Component.prototype.nodeType;
const wireType = Wire.prototype.nodeType;

const observe = disconnected({Event: CustomEvent, WeakSet});

exports.Tagger = Tagger;
exports.observe = observe;

// returns an intent to explicitly inject content as html
const asHTML = html => ({html});

// returns nodes from wires and components
const asNode = (item, i) => {
  switch (item.nodeType) {
    case wireType:
      // in the Wire case, the content can be
      // removed, post-pended, inserted, or pre-pended and
      // all these cases are handled by domdiff already
      /* istanbul ignore next */
      return (1 / i) < 0 ?
        (i ? item.remove(true) : item.lastChild) :
        (i ? item.valueOf(true) : item.firstChild);
    case componentType:
      return asNode(item.render(), i);
    default:
      return item;
  }
}

// returns true if domdiff can handle the value
const canDiff = value => 'ELEMENT_NODE' in value;

// when a Promise is used as interpolation value
// its result must be parsed once resolved.
// This callback is in charge of understanding what to do
// with a returned value once the promise is resolved.
const invokeAtDistance = (value, callback) => {
  callback(value.placeholder);
  if ('text' in value) {
    Promise.resolve(value.text).then(String).then(callback);
  } else if ('any' in value) {
    Promise.resolve(value.any).then(callback);
  } else if ('html' in value) {
    Promise.resolve(value.html).then(asHTML).then(callback);
  } else {
    Promise.resolve(Intent.invoke(value, callback)).then(callback);
  }
};

// quick and dirty way to check for Promise/ish values
const isPromise_ish = value => value != null && 'then' in value;

// list of attributes that should not be directly assigned
const readOnly = /^(?:form|list)$/i;

// reused every slice time
const slice = [].slice;

// simplifies text node creation
const text = (node, text) => node.ownerDocument.createTextNode(text);

function Tagger(type) {
  this.type = type;
  return domtagger(this);
}

Tagger.prototype = {

  // there are four kind of attributes, and related behavior:
  //  * events, with a name starting with `on`, to add/remove event listeners
  //  * special, with a name present in their inherited prototype, accessed directly
  //  * regular, accessed through get/setAttribute standard DOM methods
  //  * style, the only regular attribute that also accepts an object as value
  //    so that you can style=${{width: 120}}. In this case, the behavior has been
  //    fully inspired by Preact library and its simplicity.
  attribute(node, name, original) {
    const isSVG = OWNER_SVG_ELEMENT in node;
    let oldValue;
    // if the attribute is the style one
    // handle it differently from others
    if (name === 'style')
      return hyperStyle(node, original, isSVG);
    // the name is an event one,
    // add/remove event listeners accordingly
    else if (/^on/.test(name)) {
      let type = name.slice(2);
      if (type === CONNECTED || type === DISCONNECTED) {
        observe(node);
      }
      else if (name.toLowerCase()
        in node) {
        type = type.toLowerCase();
      }
      return newValue => {
        if (oldValue !== newValue) {
          if (oldValue)
            node.removeEventListener(type, oldValue, false);
          oldValue = newValue;
          if (newValue)
            node.addEventListener(type, newValue, false);
        }
      };
    }
    // the attribute is special ('value' in input)
    // and it's not SVG *or* the name is exactly data,
    // in this case assign the value directly
    else if (
      name === 'data' ||
      (!isSVG && name in node && !readOnly.test(name))
    ) {
      return newValue => {
        if (oldValue !== newValue) {
          oldValue = newValue;
          if (node[name] !== newValue && newValue == null) {
            // cleanup on null to avoid silly IE/Edge bug
            node[name] = '';
            node.removeAttribute(name);
          }
          else
            node[name] = newValue;
        }
      };
    }
    else if (name in Intent.attributes) {
      oldValue;
      return any => {
        const newValue = Intent.attributes[name](node, any);
        if (oldValue !== newValue) {
          oldValue = newValue;
          if (newValue == null)
            node.removeAttribute(name);
          else
            node.setAttribute(name, newValue);
        }
      };
    }
    // in every other case, use the attribute node as it is
    // update only the value, set it as node only when/if needed
    else {
      let owner = false;
      const attribute = original.cloneNode(true);
      return newValue => {
        if (oldValue !== newValue) {
          oldValue = newValue;
          if (attribute.value !== newValue) {
            if (newValue == null) {
              if (owner) {
                owner = false;
                node.removeAttributeNode(attribute);
              }
              attribute.value = newValue;
            } else {
              attribute.value = newValue;
              if (!owner) {
                owner = true;
                node.setAttributeNode(attribute);
              }
            }
          }
        }
      };
    }
  },

  // in a hyper(node)`<div>${content}</div>` case
  // everything could happen:
  //  * it's a JS primitive, stored as text
  //  * it's null or undefined, the node should be cleaned
  //  * it's a component, update the content by rendering it
  //  * it's a promise, update the content once resolved
  //  * it's an explicit intent, perform the desired operation
  //  * it's an Array, resolve all values if Promises and/or
  //    update the node with the resulting list of content
  any(node, childNodes) {
    const diffOptions = {node: asNode, before: node};
    const nodeType = OWNER_SVG_ELEMENT in node ? /* istanbul ignore next */ 'svg' : 'html';
    let fastPath = false;
    let oldValue;
    const anyContent = value => {
      switch (typeof value) {
        case 'string':
        case 'number':
        case 'boolean':
          if (fastPath) {
            if (oldValue !== value) {
              oldValue = value;
              childNodes[0].textContent = value;
            }
          } else {
            fastPath = true;
            oldValue = value;
            childNodes = domdiff(
              node.parentNode,
              childNodes,
              [text(node, value)],
              diffOptions
            );
          }
          break;
        case 'function':
          anyContent(value(node));
          break;
        case 'object':
        case 'undefined':
          if (value == null) {
            fastPath = false;
            childNodes = domdiff(
              node.parentNode,
              childNodes,
              [],
              diffOptions
            );
            break;
          }
        default:
          fastPath = false;
          oldValue = value;
          if (isArray(value)) {
            if (value.length === 0) {
              if (childNodes.length) {
                childNodes = domdiff(
                  node.parentNode,
                  childNodes,
                  [],
                  diffOptions
                );
              }
            } else {
              switch (typeof value[0]) {
                case 'string':
                case 'number':
                case 'boolean':
                  anyContent({html: value});
                  break;
                case 'object':
                  if (isArray(value[0])) {
                    value = value.concat.apply([], value);
                  }
                  if (isPromise_ish(value[0])) {
                    Promise.all(value).then(anyContent);
                    break;
                  }
                default:
                  childNodes = domdiff(
                    node.parentNode,
                    childNodes,
                    value,
                    diffOptions
                  );
                  break;
              }
            }
          } else if (canDiff(value)) {
            childNodes = domdiff(
              node.parentNode,
              childNodes,
              value.nodeType === DOCUMENT_FRAGMENT_NODE ?
                slice.call(value.childNodes) :
                [value],
              diffOptions
            );
          } else if (isPromise_ish(value)) {
            value.then(anyContent);
          } else if ('placeholder' in value) {
            invokeAtDistance(value, anyContent);
          } else if ('text' in value) {
            anyContent(String(value.text));
          } else if ('any' in value) {
            anyContent(value.any);
          } else if ('html' in value) {
            childNodes = domdiff(
              node.parentNode,
              childNodes,
              slice.call(
                createContent(
                  [].concat(value.html).join(''),
                  nodeType
                ).childNodes
              ),
              diffOptions
            );
          } else if ('length' in value) {
            anyContent(slice.call(value));
          } else {
            anyContent(Intent.invoke(value, anyContent));
          }
          break;
      }
    };
    return anyContent;
  },

  // style or textareas don't accept HTML as content
  // it's pointless to transform or analyze anything
  // different from text there but it's worth checking
  // for possible defined intents.
  text(node) {
    let oldValue;
    const textContent = value => {
      if (oldValue !== value) {
        oldValue = value;
        const type = typeof value;
        if (type === 'object' && value) {
          if (isPromise_ish(value)) {
            value.then(textContent);
          } else if ('placeholder' in value) {
            invokeAtDistance(value, textContent);
          } else if ('text' in value) {
            textContent(String(value.text));
          } else if ('any' in value) {
            textContent(value.any);
          } else if ('html' in value) {
            textContent([].concat(value.html).join(''));
          } else if ('length' in value) {
            textContent(slice.call(value).join(''));
          } else {
            textContent(Intent.invoke(value, textContent));
          }
        } else if (type === 'function') {
          textContent(value(node));
        } else {
          node.textContent = value == null ? '' : value;
        }
      }
    };
    return textContent;
  }
};


/***/ }),

/***/ "./node_modules/hyperhtml/cjs/shared/constants.js":
/*!********************************************************!*\
  !*** ./node_modules/hyperhtml/cjs/shared/constants.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Node.CONSTANTS
// 'cause some engine has no global Node defined
// (i.e. Node, NativeScript, basicHTML ... )
const ELEMENT_NODE = 1;
exports.ELEMENT_NODE = ELEMENT_NODE;
const DOCUMENT_FRAGMENT_NODE = 11;
exports.DOCUMENT_FRAGMENT_NODE = DOCUMENT_FRAGMENT_NODE;

// SVG related constants
const OWNER_SVG_ELEMENT = 'ownerSVGElement';
exports.OWNER_SVG_ELEMENT = OWNER_SVG_ELEMENT;

// Custom Elements / MutationObserver constants
const CONNECTED = 'connected';
exports.CONNECTED = CONNECTED;
const DISCONNECTED = 'dis' + CONNECTED;
exports.DISCONNECTED = DISCONNECTED;


/***/ }),

/***/ "@hypertype/core":
/*!**********************************!*\
  !*** external "@hypertype/core" ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__hypertype_core__;

/***/ })

/******/ });
});
//# sourceMappingURL=index.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/crc-32/crc32.js":
/*!**************************************!*\
  !*** ./node_modules/crc-32/crc32.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
/* vim: set ts=2: */
/*exported CRC32 */
var CRC32;
(function (factory) {
	/*jshint ignore:start */
	/*eslint-disable */
	if(typeof DO_NOT_EXPORT_CRC === 'undefined') {
		if(true) {
			factory(exports);
		} else {}
	} else {
		factory(CRC32 = {});
	}
	/*eslint-enable */
	/*jshint ignore:end */
}(function(CRC32) {
CRC32.version = '1.2.0';
/* see perf/crc32table.js */
/*global Int32Array */
function signed_crc_table() {
	var c = 0, table = new Array(256);

	for(var n =0; n != 256; ++n){
		c = n;
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		table[n] = c;
	}

	return typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;
}

var T = signed_crc_table();
function crc32_bstr(bstr, seed) {
	var C = seed ^ -1, L = bstr.length - 1;
	for(var i = 0; i < L;) {
		C = (C>>>8) ^ T[(C^bstr.charCodeAt(i++))&0xFF];
		C = (C>>>8) ^ T[(C^bstr.charCodeAt(i++))&0xFF];
	}
	if(i === L) C = (C>>>8) ^ T[(C ^ bstr.charCodeAt(i))&0xFF];
	return C ^ -1;
}

function crc32_buf(buf, seed) {
	if(buf.length > 10000) return crc32_buf_8(buf, seed);
	var C = seed ^ -1, L = buf.length - 3;
	for(var i = 0; i < L;) {
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
	}
	while(i < L+3) C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
	return C ^ -1;
}

function crc32_buf_8(buf, seed) {
	var C = seed ^ -1, L = buf.length - 7;
	for(var i = 0; i < L;) {
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
	}
	while(i < L+7) C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
	return C ^ -1;
}

function crc32_str(str, seed) {
	var C = seed ^ -1;
	for(var i = 0, L=str.length, c, d; i < L;) {
		c = str.charCodeAt(i++);
		if(c < 0x80) {
			C = (C>>>8) ^ T[(C ^ c)&0xFF];
		} else if(c < 0x800) {
			C = (C>>>8) ^ T[(C ^ (192|((c>>6)&31)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|(c&63)))&0xFF];
		} else if(c >= 0xD800 && c < 0xE000) {
			c = (c&1023)+64; d = str.charCodeAt(i++)&1023;
			C = (C>>>8) ^ T[(C ^ (240|((c>>8)&7)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|((c>>2)&63)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|((d>>6)&15)|((c&3)<<4)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|(d&63)))&0xFF];
		} else {
			C = (C>>>8) ^ T[(C ^ (224|((c>>12)&15)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|((c>>6)&63)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|(c&63)))&0xFF];
		}
	}
	return C ^ -1;
}
CRC32.table = T;
// $FlowIgnore
CRC32.bstr = crc32_bstr;
// $FlowIgnore
CRC32.buf = crc32_buf;
// $FlowIgnore
CRC32.str = crc32_str;
}));


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], "{").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    for (var i = 0; i < this.length; i++) {
      // eslint-disable-next-line prefer-destructuring
      var id = this[i][0];

      if (id != null) {
        alreadyImportedModules[id] = true;
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = modules[_i]; // skip already imported module
      // this implementation is not 100% perfect for weird media query combinations
      // when a module is imported multiple times with different media queries.
      // I hope this will never occur (Hey this way we have smaller bundles)

      if (item[0] == null || !alreadyImportedModules[item[0]]) {
        if (mediaQuery && !item[2]) {
          item[2] = mediaQuery;
        } else if (mediaQuery) {
          item[2] = "(".concat(item[2], ") and (").concat(mediaQuery, ")");
        }

        list.push(item);
      }
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot).concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/luxon/build/node/luxon.js":
/*!************************************************!*\
  !*** ./node_modules/luxon/build/node/luxon.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

// these aren't really private, but nor are they really useful to document

/**
 * @private
 */
class LuxonError extends Error {}
/**
 * @private
 */


class InvalidDateTimeError extends LuxonError {
  constructor(reason) {
    super(`Invalid DateTime: ${reason.toMessage()}`);
  }

}
/**
 * @private
 */

class InvalidIntervalError extends LuxonError {
  constructor(reason) {
    super(`Invalid Interval: ${reason.toMessage()}`);
  }

}
/**
 * @private
 */

class InvalidDurationError extends LuxonError {
  constructor(reason) {
    super(`Invalid Duration: ${reason.toMessage()}`);
  }

}
/**
 * @private
 */

class ConflictingSpecificationError extends LuxonError {}
/**
 * @private
 */

class InvalidUnitError extends LuxonError {
  constructor(unit) {
    super(`Invalid unit ${unit}`);
  }

}
/**
 * @private
 */

class InvalidArgumentError extends LuxonError {}
/**
 * @private
 */

class ZoneIsAbstractError extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }

}

/*
  This is just a junk drawer, containing anything used across multiple classes.
  Because Luxon is small(ish), this should stay small and we won't worry about splitting
  it up into, say, parsingUtil.js and basicUtil.js and so on. But they are divided up by feature area.
*/
/**
 * @private
 */
// TYPES

function isUndefined(o) {
  return typeof o === "undefined";
}
function isNumber(o) {
  return typeof o === "number";
}
function isInteger(o) {
  return typeof o === "number" && o % 1 === 0;
}
function isString(o) {
  return typeof o === "string";
}
function isDate(o) {
  return Object.prototype.toString.call(o) === "[object Date]";
} // CAPABILITIES

function hasIntl() {
  try {
    return typeof Intl !== "undefined" && Intl.DateTimeFormat;
  } catch (e) {
    return false;
  }
}
function hasFormatToParts() {
  return !isUndefined(Intl.DateTimeFormat.prototype.formatToParts);
}
function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e) {
    return false;
  }
} // OBJECTS AND ARRAYS

function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr, by, compare) {
  if (arr.length === 0) {
    return undefined;
  }

  return arr.reduce((best, next) => {
    const pair = [by(next), next];

    if (!best) {
      return pair;
    } else if (compare(best[0], pair[0]) === best[0]) {
      return best;
    } else {
      return pair;
    }
  }, null)[1];
}
function pick(obj, keys) {
  return keys.reduce((a, k) => {
    a[k] = obj[k];
    return a;
  }, {});
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
} // NUMBERS AND STRINGS

function integerBetween(thing, bottom, top) {
  return isInteger(thing) && thing >= bottom && thing <= top;
} // x % n but takes the sign of n instead of x

function floorMod(x, n) {
  return x - n * Math.floor(x / n);
}
function padStart(input, n = 2) {
  if (input.toString().length < n) {
    return ("0".repeat(n) + input).slice(-n);
  } else {
    return input.toString();
  }
}
function parseInteger(string) {
  if (isUndefined(string) || string === null || string === "") {
    return undefined;
  } else {
    return parseInt(string, 10);
  }
}
function parseMillis(fraction) {
  // Return undefined (instead of 0) in these cases, where fraction is not set
  if (isUndefined(fraction) || fraction === null || fraction === "") {
    return undefined;
  } else {
    const f = parseFloat("0." + fraction) * 1000;
    return Math.floor(f);
  }
}
function roundTo(number, digits, towardZero = false) {
  const factor = Math.pow(10, digits),
        rounder = towardZero ? Math.trunc : Math.round;
  return rounder(number * factor) / factor;
} // DATE BASICS

function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function daysInMonth(year, month) {
  const modMonth = floorMod(month - 1, 12) + 1,
        modYear = year + (month - modMonth) / 12;

  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
} // covert a calendar object to a local timestamp (epoch, but with the offset baked in)

function objToLocalTS(obj) {
  let d = Date.UTC(obj.year, obj.month - 1, obj.day, obj.hour, obj.minute, obj.second, obj.millisecond); // for legacy reasons, years between 0 and 99 are interpreted as 19XX; revert that

  if (obj.year < 100 && obj.year >= 0) {
    d = new Date(d);
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }

  return +d;
}
function weeksInWeekYear(weekYear) {
  const p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7,
        last = weekYear - 1,
        p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
  return p1 === 4 || p2 === 3 ? 53 : 52;
}
function untruncateYear(year) {
  if (year > 99) {
    return year;
  } else return year > 60 ? 1900 + year : 2000 + year;
} // PARSING

function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
  const date = new Date(ts),
        intlOpts = {
    hour12: false,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };

  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }

  const modified = Object.assign({
    timeZoneName: offsetFormat
  }, intlOpts),
        intl = hasIntl();

  if (intl && hasFormatToParts()) {
    const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find(m => m.type.toLowerCase() === "timezonename");
    return parsed ? parsed.value : null;
  } else if (intl) {
    // this probably doesn't work for all locales
    const without = new Intl.DateTimeFormat(locale, intlOpts).format(date),
          included = new Intl.DateTimeFormat(locale, modified).format(date),
          diffed = included.substring(without.length),
          trimmed = diffed.replace(/^[, \u200e]+/, "");
    return trimmed;
  } else {
    return null;
  }
} // signedOffset('-5', '30') -> -330

function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10); // don't || this because we want to preserve -0

  if (Number.isNaN(offHour)) {
    offHour = 0;
  }

  const offMin = parseInt(offMinuteStr, 10) || 0,
        offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
} // COERCION

function asNumber(value) {
  const numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue)) throw new InvalidArgumentError(`Invalid unit value ${value}`);
  return numericValue;
}

function normalizeObject(obj, normalizer, nonUnitKeys) {
  const normalized = {};

  for (const u in obj) {
    if (hasOwnProperty(obj, u)) {
      if (nonUnitKeys.indexOf(u) >= 0) continue;
      const v = obj[u];
      if (v === undefined || v === null) continue;
      normalized[normalizer(u)] = asNumber(v);
    }
  }

  return normalized;
}
function formatOffset(offset, format) {
  const hours = Math.trunc(offset / 60),
        minutes = Math.abs(offset % 60),
        sign = hours >= 0 && !Object.is(hours, -0) ? "+" : "-",
        base = `${sign}${Math.abs(hours)}`;

  switch (format) {
    case "short":
      return `${sign}${padStart(Math.abs(hours), 2)}:${padStart(minutes, 2)}`;

    case "narrow":
      return minutes > 0 ? `${base}:${minutes}` : base;

    case "techie":
      return `${sign}${padStart(Math.abs(hours), 2)}${padStart(minutes, 2)}`;

    default:
      throw new RangeError(`Value format ${format} is out of range for property format`);
  }
}
function timeObject(obj) {
  return pick(obj, ["hour", "minute", "second", "millisecond"]);
}
const ianaRegex = /[A-Za-z_+-]{1,256}(:?\/[A-Za-z_+-]{1,256}(\/[A-Za-z_+-]{1,256})?)?/;

/**
 * @private
 */
const n = "numeric",
      s = "short",
      l = "long",
      d2 = "2-digit";
const DATE_SHORT = {
  year: n,
  month: n,
  day: n
};
const DATE_MED = {
  year: n,
  month: s,
  day: n
};
const DATE_FULL = {
  year: n,
  month: l,
  day: n
};
const DATE_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l
};
const TIME_SIMPLE = {
  hour: n,
  minute: d2
};
const TIME_WITH_SECONDS = {
  hour: n,
  minute: d2,
  second: d2
};
const TIME_WITH_SHORT_OFFSET = {
  hour: n,
  minute: d2,
  second: d2,
  timeZoneName: s
};
const TIME_WITH_LONG_OFFSET = {
  hour: n,
  minute: d2,
  second: d2,
  timeZoneName: l
};
const TIME_24_SIMPLE = {
  hour: n,
  minute: d2,
  hour12: false
};
/**
 * {@link toLocaleString}; format like '09:30:23', always 24-hour.
 */

const TIME_24_WITH_SECONDS = {
  hour: n,
  minute: d2,
  second: d2,
  hour12: false
};
/**
 * {@link toLocaleString}; format like '09:30:23 EDT', always 24-hour.
 */

const TIME_24_WITH_SHORT_OFFSET = {
  hour: n,
  minute: d2,
  second: d2,
  hour12: false,
  timeZoneName: s
};
/**
 * {@link toLocaleString}; format like '09:30:23 Eastern Daylight Time', always 24-hour.
 */

const TIME_24_WITH_LONG_OFFSET = {
  hour: n,
  minute: d2,
  second: d2,
  hour12: false,
  timeZoneName: l
};
/**
 * {@link toLocaleString}; format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
 */

const DATETIME_SHORT = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: d2
};
/**
 * {@link toLocaleString}; format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
 */

const DATETIME_SHORT_WITH_SECONDS = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: d2,
  second: d2
};
const DATETIME_MED = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: d2
};
const DATETIME_MED_WITH_SECONDS = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: d2,
  second: d2
};
const DATETIME_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s,
  hour: n,
  minute: d2
};
const DATETIME_FULL = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: d2,
  timeZoneName: s
};
const DATETIME_FULL_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: d2,
  second: d2,
  timeZoneName: s
};
const DATETIME_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: d2,
  timeZoneName: l
};
const DATETIME_HUGE_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: d2,
  second: d2,
  timeZoneName: l
};

function stringify(obj) {
  return JSON.stringify(obj, Object.keys(obj).sort());
}
/**
 * @private
 */


const monthsLong = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
const monthsShort = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
const monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(length) {
  switch (length) {
    case "narrow":
      return monthsNarrow;

    case "short":
      return monthsShort;

    case "long":
      return monthsLong;

    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];

    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];

    default:
      return null;
  }
}
const weekdaysLong = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
const weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
const weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(length) {
  switch (length) {
    case "narrow":
      return weekdaysNarrow;

    case "short":
      return weekdaysShort;

    case "long":
      return weekdaysLong;

    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];

    default:
      return null;
  }
}
const meridiems = ["AM", "PM"];
const erasLong = ["Before Christ", "Anno Domini"];
const erasShort = ["BC", "AD"];
const erasNarrow = ["B", "A"];
function eras(length) {
  switch (length) {
    case "narrow":
      return erasNarrow;

    case "short":
      return erasShort;

    case "long":
      return erasLong;

    default:
      return null;
  }
}
function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(dt, length) {
  return weekdays(length)[dt.weekday - 1];
}
function monthForDateTime(dt, length) {
  return months(length)[dt.month - 1];
}
function eraForDateTime(dt, length) {
  return eras(length)[dt.year < 0 ? 0 : 1];
}
function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
  const units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  };
  const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;

  if (numeric === "auto" && lastable) {
    const isDay = unit === "days";

    switch (count) {
      case 1:
        return isDay ? "tomorrow" : `next ${units[unit][0]}`;

      case -1:
        return isDay ? "yesterday" : `last ${units[unit][0]}`;

      case 0:
        return isDay ? "today" : `this ${units[unit][0]}`;

      default: // fall through

    }
  }

  const isInPast = Object.is(count, -0) || count < 0,
        fmtValue = Math.abs(count),
        singular = fmtValue === 1,
        lilUnits = units[unit],
        fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
}
function formatString(knownFormat) {
  // these all have the offsets removed because we don't have access to them
  // without all the intl stuff this is backfilling
  const filtered = pick(knownFormat, ["weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "hour12"]),
        key = stringify(filtered),
        dateTimeHuge = "EEEE, LLLL d, yyyy, h:mm a";

  switch (key) {
    case stringify(DATE_SHORT):
      return "M/d/yyyy";

    case stringify(DATE_MED):
      return "LLL d, yyyy";

    case stringify(DATE_FULL):
      return "LLLL d, yyyy";

    case stringify(DATE_HUGE):
      return "EEEE, LLLL d, yyyy";

    case stringify(TIME_SIMPLE):
      return "h:mm a";

    case stringify(TIME_WITH_SECONDS):
      return "h:mm:ss a";

    case stringify(TIME_WITH_SHORT_OFFSET):
      return "h:mm a";

    case stringify(TIME_WITH_LONG_OFFSET):
      return "h:mm a";

    case stringify(TIME_24_SIMPLE):
      return "HH:mm";

    case stringify(TIME_24_WITH_SECONDS):
      return "HH:mm:ss";

    case stringify(TIME_24_WITH_SHORT_OFFSET):
      return "HH:mm";

    case stringify(TIME_24_WITH_LONG_OFFSET):
      return "HH:mm";

    case stringify(DATETIME_SHORT):
      return "M/d/yyyy, h:mm a";

    case stringify(DATETIME_MED):
      return "LLL d, yyyy, h:mm a";

    case stringify(DATETIME_FULL):
      return "LLLL d, yyyy, h:mm a";

    case stringify(DATETIME_HUGE):
      return dateTimeHuge;

    case stringify(DATETIME_SHORT_WITH_SECONDS):
      return "M/d/yyyy, h:mm:ss a";

    case stringify(DATETIME_MED_WITH_SECONDS):
      return "LLL d, yyyy, h:mm:ss a";

    case stringify(DATETIME_MED_WITH_WEEKDAY):
      return "EEE, d LLL yyyy, h:mm a";

    case stringify(DATETIME_FULL_WITH_SECONDS):
      return "LLLL d, yyyy, h:mm:ss a";

    case stringify(DATETIME_HUGE_WITH_SECONDS):
      return "EEEE, LLLL d, yyyy, h:mm:ss a";

    default:
      return dateTimeHuge;
  }
}

/* eslint no-unused-vars: "off" */
/**
 * @interface
 */

class Zone {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new ZoneIsAbstractError();
  }
  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */


  get name() {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */


  get universal() {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */


  offsetName(ts, opts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */


  formatOffset(ts, format) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */


  offset(ts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */


  equals(otherZone) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */


  get isValid() {
    throw new ZoneIsAbstractError();
  }

}

let singleton = null;
/**
 * Represents the local zone for this Javascript environment.
 * @implements {Zone}
 */

class LocalZone extends Zone {
  /**
   * Get a singleton instance of the local zone
   * @return {LocalZone}
   */
  static get instance() {
    if (singleton === null) {
      singleton = new LocalZone();
    }

    return singleton;
  }
  /** @override **/


  get type() {
    return "local";
  }
  /** @override **/


  get name() {
    if (hasIntl()) {
      return new Intl.DateTimeFormat().resolvedOptions().timeZone;
    } else return "local";
  }
  /** @override **/


  get universal() {
    return false;
  }
  /** @override **/


  offsetName(ts, {
    format,
    locale
  }) {
    return parseZoneInfo(ts, format, locale);
  }
  /** @override **/


  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  /** @override **/


  offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }
  /** @override **/


  equals(otherZone) {
    return otherZone.type === "local";
  }
  /** @override **/


  get isValid() {
    return true;
  }

}

const matchingRegex = RegExp(`^${ianaRegex.source}$`);
let dtfCache = {};

function makeDTF(zone) {
  if (!dtfCache[zone]) {
    dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
  }

  return dtfCache[zone];
}

const typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  hour: 3,
  minute: 4,
  second: 5
};

function hackyOffset(dtf, date) {
  const formatted = dtf.format(date).replace(/\u200E/g, ""),
        parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted),
        [, fMonth, fDay, fYear, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fHour, fMinute, fSecond];
}

function partsOffset(dtf, date) {
  const formatted = dtf.formatToParts(date),
        filled = [];

  for (let i = 0; i < formatted.length; i++) {
    const {
      type,
      value
    } = formatted[i],
          pos = typeToPos[type];

    if (!isUndefined(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }

  return filled;
}

let ianaZoneCache = {};
/**
 * A zone identified by an IANA identifier, like America/New_York
 * @implements {Zone}
 */

class IANAZone extends Zone {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(name) {
    if (!ianaZoneCache[name]) {
      ianaZoneCache[name] = new IANAZone(name);
    }

    return ianaZoneCache[name];
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */


  static resetCache() {
    ianaZoneCache = {};
    dtfCache = {};
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Fantasia/Castle") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @return {boolean}
   */


  static isValidSpecifier(s) {
    return !!(s && s.match(matchingRegex));
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */


  static isValidZone(zone) {
    try {
      new Intl.DateTimeFormat("en-US", {
        timeZone: zone
      }).format();
      return true;
    } catch (e) {
      return false;
    }
  } // Etc/GMT+8 -> -480

  /** @ignore */


  static parseGMTOffset(specifier) {
    if (specifier) {
      const match = specifier.match(/^Etc\/GMT([+-]\d{1,2})$/i);

      if (match) {
        return -60 * parseInt(match[1]);
      }
    }

    return null;
  }

  constructor(name) {
    super();
    /** @private **/

    this.zoneName = name;
    /** @private **/

    this.valid = IANAZone.isValidZone(name);
  }
  /** @override **/


  get type() {
    return "iana";
  }
  /** @override **/


  get name() {
    return this.zoneName;
  }
  /** @override **/


  get universal() {
    return false;
  }
  /** @override **/


  offsetName(ts, {
    format,
    locale
  }) {
    return parseZoneInfo(ts, format, locale, this.name);
  }
  /** @override **/


  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  /** @override **/


  offset(ts) {
    const date = new Date(ts),
          dtf = makeDTF(this.name),
          [year, month, day, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
    const asUTC = objToLocalTS({
      year,
      month,
      day,
      hour,
      minute,
      second,
      millisecond: 0
    });
    let asTS = date.valueOf();
    asTS -= asTS % 1000;
    return (asUTC - asTS) / (60 * 1000);
  }
  /** @override **/


  equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }
  /** @override **/


  get isValid() {
    return this.valid;
  }

}

let singleton$1 = null;
/**
 * A zone with a fixed offset (i.e. no DST)
 * @implements {Zone}
 */

class FixedOffsetZone extends Zone {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    if (singleton$1 === null) {
      singleton$1 = new FixedOffsetZone(0);
    }

    return singleton$1;
  }
  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */


  static instance(offset) {
    return offset === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */


  static parseSpecifier(s) {
    if (s) {
      const r = s.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);

      if (r) {
        return new FixedOffsetZone(signedOffset(r[1], r[2]));
      }
    }

    return null;
  }

  constructor(offset) {
    super();
    /** @private **/

    this.fixed = offset;
  }
  /** @override **/


  get type() {
    return "fixed";
  }
  /** @override **/


  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
  }
  /** @override **/


  offsetName() {
    return this.name;
  }
  /** @override **/


  formatOffset(ts, format) {
    return formatOffset(this.fixed, format);
  }
  /** @override **/


  get universal() {
    return true;
  }
  /** @override **/


  offset() {
    return this.fixed;
  }
  /** @override **/


  equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }
  /** @override **/


  get isValid() {
    return true;
  }

}

/**
 * A zone that failed to parse. You should never need to instantiate this.
 * @implements {Zone}
 */

class InvalidZone extends Zone {
  constructor(zoneName) {
    super();
    /**  @private */

    this.zoneName = zoneName;
  }
  /** @override **/


  get type() {
    return "invalid";
  }
  /** @override **/


  get name() {
    return this.zoneName;
  }
  /** @override **/


  get universal() {
    return false;
  }
  /** @override **/


  offsetName() {
    return null;
  }
  /** @override **/


  formatOffset() {
    return "";
  }
  /** @override **/


  offset() {
    return NaN;
  }
  /** @override **/


  equals() {
    return false;
  }
  /** @override **/


  get isValid() {
    return false;
  }

}

/**
 * @private
 */
function normalizeZone(input, defaultZone) {
  let offset;

  if (isUndefined(input) || input === null) {
    return defaultZone;
  } else if (input instanceof Zone) {
    return input;
  } else if (isString(input)) {
    const lowered = input.toLowerCase();
    if (lowered === "local") return defaultZone;else if (lowered === "utc" || lowered === "gmt") return FixedOffsetZone.utcInstance;else if ((offset = IANAZone.parseGMTOffset(input)) != null) {
      // handle Etc/GMT-4, which V8 chokes on
      return FixedOffsetZone.instance(offset);
    } else if (IANAZone.isValidSpecifier(lowered)) return IANAZone.create(input);else return FixedOffsetZone.parseSpecifier(lowered) || new InvalidZone(input);
  } else if (isNumber(input)) {
    return FixedOffsetZone.instance(input);
  } else if (typeof input === "object" && input.offset && typeof input.offset === "number") {
    // This is dumb, but the instanceof check above doesn't seem to really work
    // so we're duck checking it
    return input;
  } else {
    return new InvalidZone(input);
  }
}

let now = () => Date.now(),
    defaultZone = null,
    // not setting this directly to LocalZone.instance bc loading order issues
defaultLocale = null,
    defaultNumberingSystem = null,
    defaultOutputCalendar = null,
    throwOnInvalid = false;
/**
 * Settings contains static getters and setters that control Luxon's overall behavior. Luxon is a simple library with few options, but the ones it does have live here.
 */


class Settings {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return now;
  }
  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */


  static set now(n) {
    now = n;
  }
  /**
   * Get the default time zone to create DateTimes in.
   * @type {string}
   */


  static get defaultZoneName() {
    return Settings.defaultZone.name;
  }
  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * @type {string}
   */


  static set defaultZoneName(z) {
    if (!z) {
      defaultZone = null;
    } else {
      defaultZone = normalizeZone(z);
    }
  }
  /**
   * Get the default time zone object to create DateTimes in. Does not affect existing instances.
   * @type {Zone}
   */


  static get defaultZone() {
    return defaultZone || LocalZone.instance;
  }
  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */


  static get defaultLocale() {
    return defaultLocale;
  }
  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */


  static set defaultLocale(locale) {
    defaultLocale = locale;
  }
  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */


  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }
  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */


  static set defaultNumberingSystem(numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  }
  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */


  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }
  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */


  static set defaultOutputCalendar(outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  }
  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */


  static get throwOnInvalid() {
    return throwOnInvalid;
  }
  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */


  static set throwOnInvalid(t) {
    throwOnInvalid = t;
  }
  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */


  static resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
  }

}

function stringifyTokens(splits, tokenToString) {
  let s = "";

  for (const token of splits) {
    if (token.literal) {
      s += token.val;
    } else {
      s += tokenToString(token.val);
    }
  }

  return s;
}

const macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS
};
/**
 * @private
 */

class Formatter {
  static create(locale, opts = {}) {
    return new Formatter(locale, opts);
  }

  static parseFormat(fmt) {
    let current = null,
        currentFull = "",
        bracketed = false;
    const splits = [];

    for (let i = 0; i < fmt.length; i++) {
      const c = fmt.charAt(i);

      if (c === "'") {
        if (currentFull.length > 0) {
          splits.push({
            literal: bracketed,
            val: currentFull
          });
        }

        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c;
      } else if (c === current) {
        currentFull += c;
      } else {
        if (currentFull.length > 0) {
          splits.push({
            literal: false,
            val: currentFull
          });
        }

        currentFull = c;
        current = c;
      }
    }

    if (currentFull.length > 0) {
      splits.push({
        literal: bracketed,
        val: currentFull
      });
    }

    return splits;
  }

  static macroTokenToFormatOpts(token) {
    return macroTokenToFormatOpts[token];
  }

  constructor(locale, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale;
    this.systemLoc = null;
  }

  formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }

    const df = this.systemLoc.dtFormatter(dt, Object.assign({}, this.opts, opts));
    return df.format();
  }

  formatDateTime(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, Object.assign({}, this.opts, opts));
    return df.format();
  }

  formatDateTimeParts(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, Object.assign({}, this.opts, opts));
    return df.formatToParts();
  }

  resolvedOptions(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, Object.assign({}, this.opts, opts));
    return df.resolvedOptions();
  }

  num(n, p = 0) {
    // we get some perf out of doing this here, annoyingly
    if (this.opts.forceSimple) {
      return padStart(n, p);
    }

    const opts = Object.assign({}, this.opts);

    if (p > 0) {
      opts.padTo = p;
    }

    return this.loc.numberFormatter(opts).format(n);
  }

  formatDateTimeFromString(dt, fmt) {
    const knownEnglish = this.loc.listingMode() === "en",
          useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory" && hasFormatToParts(),
          string = (opts, extract) => this.loc.extract(dt, opts, extract),
          formatOffset = opts => {
      if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
        return "Z";
      }

      return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
    },
          meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({
      hour: "numeric",
      hour12: true
    }, "dayperiod"),
          month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string(standalone ? {
      month: length
    } : {
      month: length,
      day: "numeric"
    }, "month"),
          weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string(standalone ? {
      weekday: length
    } : {
      weekday: length,
      month: "long",
      day: "numeric"
    }, "weekday"),
          maybeMacro = token => {
      const formatOpts = Formatter.macroTokenToFormatOpts(token);

      if (formatOpts) {
        return this.formatWithSystemDefault(dt, formatOpts);
      } else {
        return token;
      }
    },
          era = length => knownEnglish ? eraForDateTime(dt, length) : string({
      era: length
    }, "era"),
          tokenToString = token => {
      // Where possible: http://cldr.unicode.org/translation/date-time#TOC-Stand-Alone-vs.-Format-Styles
      switch (token) {
        // ms
        case "S":
          return this.num(dt.millisecond);

        case "u": // falls through

        case "SSS":
          return this.num(dt.millisecond, 3);
        // seconds

        case "s":
          return this.num(dt.second);

        case "ss":
          return this.num(dt.second, 2);
        // minutes

        case "m":
          return this.num(dt.minute);

        case "mm":
          return this.num(dt.minute, 2);
        // hours

        case "h":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);

        case "hh":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);

        case "H":
          return this.num(dt.hour);

        case "HH":
          return this.num(dt.hour, 2);
        // offset

        case "Z":
          // like +6
          return formatOffset({
            format: "narrow",
            allowZ: this.opts.allowZ
          });

        case "ZZ":
          // like +06:00
          return formatOffset({
            format: "short",
            allowZ: this.opts.allowZ
          });

        case "ZZZ":
          // like +0600
          return formatOffset({
            format: "techie",
            allowZ: false
          });

        case "ZZZZ":
          // like EST
          return dt.zone.offsetName(dt.ts, {
            format: "short",
            locale: this.loc.locale
          });

        case "ZZZZZ":
          // like Eastern Standard Time
          return dt.zone.offsetName(dt.ts, {
            format: "long",
            locale: this.loc.locale
          });
        // zone

        case "z":
          // like America/New_York
          return dt.zoneName;
        // meridiems

        case "a":
          return meridiem();
        // dates

        case "d":
          return useDateTimeFormatter ? string({
            day: "numeric"
          }, "day") : this.num(dt.day);

        case "dd":
          return useDateTimeFormatter ? string({
            day: "2-digit"
          }, "day") : this.num(dt.day, 2);
        // weekdays - standalone

        case "c":
          // like 1
          return this.num(dt.weekday);

        case "ccc":
          // like 'Tues'
          return weekday("short", true);

        case "cccc":
          // like 'Tuesday'
          return weekday("long", true);

        case "ccccc":
          // like 'T'
          return weekday("narrow", true);
        // weekdays - format

        case "E":
          // like 1
          return this.num(dt.weekday);

        case "EEE":
          // like 'Tues'
          return weekday("short", false);

        case "EEEE":
          // like 'Tuesday'
          return weekday("long", false);

        case "EEEEE":
          // like 'T'
          return weekday("narrow", false);
        // months - standalone

        case "L":
          // like 1
          return useDateTimeFormatter ? string({
            month: "numeric",
            day: "numeric"
          }, "month") : this.num(dt.month);

        case "LL":
          // like 01, doesn't seem to work
          return useDateTimeFormatter ? string({
            month: "2-digit",
            day: "numeric"
          }, "month") : this.num(dt.month, 2);

        case "LLL":
          // like Jan
          return month("short", true);

        case "LLLL":
          // like January
          return month("long", true);

        case "LLLLL":
          // like J
          return month("narrow", true);
        // months - format

        case "M":
          // like 1
          return useDateTimeFormatter ? string({
            month: "numeric"
          }, "month") : this.num(dt.month);

        case "MM":
          // like 01
          return useDateTimeFormatter ? string({
            month: "2-digit"
          }, "month") : this.num(dt.month, 2);

        case "MMM":
          // like Jan
          return month("short", false);

        case "MMMM":
          // like January
          return month("long", false);

        case "MMMMM":
          // like J
          return month("narrow", false);
        // years

        case "y":
          // like 2014
          return useDateTimeFormatter ? string({
            year: "numeric"
          }, "year") : this.num(dt.year);

        case "yy":
          // like 14
          return useDateTimeFormatter ? string({
            year: "2-digit"
          }, "year") : this.num(dt.year.toString().slice(-2), 2);

        case "yyyy":
          // like 0012
          return useDateTimeFormatter ? string({
            year: "numeric"
          }, "year") : this.num(dt.year, 4);

        case "yyyyyy":
          // like 000012
          return useDateTimeFormatter ? string({
            year: "numeric"
          }, "year") : this.num(dt.year, 6);
        // eras

        case "G":
          // like AD
          return era("short");

        case "GG":
          // like Anno Domini
          return era("long");

        case "GGGGG":
          return era("narrow");

        case "kk":
          return this.num(dt.weekYear.toString().slice(-2), 2);

        case "kkkk":
          return this.num(dt.weekYear, 4);

        case "W":
          return this.num(dt.weekNumber);

        case "WW":
          return this.num(dt.weekNumber, 2);

        case "o":
          return this.num(dt.ordinal);

        case "ooo":
          return this.num(dt.ordinal, 3);

        case "q":
          // like 1
          return this.num(dt.quarter);

        case "qq":
          // like 01
          return this.num(dt.quarter, 2);

        case "X":
          return this.num(Math.floor(dt.ts / 1000));

        case "x":
          return this.num(dt.ts);

        default:
          return maybeMacro(token);
      }
    };

    return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
  }

  formatDurationFromString(dur, fmt) {
    const tokenToField = token => {
      switch (token[0]) {
        case "S":
          return "millisecond";

        case "s":
          return "second";

        case "m":
          return "minute";

        case "h":
          return "hour";

        case "d":
          return "day";

        case "M":
          return "month";

        case "y":
          return "year";

        default:
          return null;
      }
    },
          tokenToString = lildur => token => {
      const mapped = tokenToField(token);

      if (mapped) {
        return this.num(lildur.get(mapped), token.length);
      } else {
        return token;
      }
    },
          tokens = Formatter.parseFormat(fmt),
          realTokens = tokens.reduce((found, {
      literal,
      val
    }) => literal ? found : found.concat(val), []),
          collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter(t => t));

    return stringifyTokens(tokens, tokenToString(collapsed));
  }

}

let intlDTCache = {};

function getCachedDTF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlDTCache[key];

  if (!dtf) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache[key] = dtf;
  }

  return dtf;
}

let intlNumCache = {};

function getCachendINF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let inf = intlNumCache[key];

  if (!inf) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache[key] = inf;
  }

  return inf;
}

let intlRelCache = {};

function getCachendRTF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let inf = intlRelCache[key];

  if (!inf) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache[key] = inf;
  }

  return inf;
}

let sysLocaleCache = null;

function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else if (hasIntl()) {
    const computedSys = new Intl.DateTimeFormat().resolvedOptions().locale; // node sometimes defaults to "und". Override that because that is dumb

    sysLocaleCache = !computedSys || computedSys === "und" ? "en-US" : computedSys;
    return sysLocaleCache;
  } else {
    sysLocaleCache = "en-US";
    return sysLocaleCache;
  }
}

function parseLocaleString(localeStr) {
  // I really want to avoid writing a BCP 47 parser
  // see, e.g. https://github.com/wooorm/bcp-47
  // Instead, we'll do this:
  // a) if the string has no -u extensions, just leave it alone
  // b) if it does, use Intl to resolve everything
  // c) if Intl fails, try again without the -u
  const uIndex = localeStr.indexOf("-u-");

  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options;
    const smaller = localeStr.substring(0, uIndex);

    try {
      options = getCachedDTF(localeStr).resolvedOptions();
    } catch (e) {
      options = getCachedDTF(smaller).resolvedOptions();
    }

    const {
      numberingSystem,
      calendar
    } = options; // return the smaller one so that we can append the calendar and numbering overrides to it

    return [smaller, numberingSystem, calendar];
  }
}

function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (hasIntl()) {
    if (outputCalendar || numberingSystem) {
      localeStr += "-u";

      if (outputCalendar) {
        localeStr += `-ca-${outputCalendar}`;
      }

      if (numberingSystem) {
        localeStr += `-nu-${numberingSystem}`;
      }

      return localeStr;
    } else {
      return localeStr;
    }
  } else {
    return [];
  }
}

function mapMonths(f) {
  const ms = [];

  for (let i = 1; i <= 12; i++) {
    const dt = DateTime.utc(2016, i, 1);
    ms.push(f(dt));
  }

  return ms;
}

function mapWeekdays(f) {
  const ms = [];

  for (let i = 1; i <= 7; i++) {
    const dt = DateTime.utc(2016, 11, 13 + i);
    ms.push(f(dt));
  }

  return ms;
}

function listStuff(loc, length, defaultOK, englishFn, intlFn) {
  const mode = loc.listingMode(defaultOK);

  if (mode === "error") {
    return null;
  } else if (mode === "en") {
    return englishFn(length);
  } else {
    return intlFn(length);
  }
}

function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || hasIntl() && new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
  }
}
/**
 * @private
 */


class PolyNumberFormatter {
  constructor(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;

    if (!forceSimple && hasIntl()) {
      const intlOpts = {
        useGrouping: false
      };
      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachendINF(intl, intlOpts);
    }
  }

  format(i) {
    if (this.inf) {
      const fixed = this.floor ? Math.floor(i) : i;
      return this.inf.format(fixed);
    } else {
      // to match the browser's numberformatter defaults
      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
      return padStart(fixed, this.padTo);
    }
  }

}
/**
 * @private
 */


class PolyDateFormatter {
  constructor(dt, intl, opts) {
    this.opts = opts;
    this.hasIntl = hasIntl();
    let z;

    if (dt.zone.universal && this.hasIntl) {
      // Chromium doesn't support fixed-offset zones like Etc/GMT+8 in its formatter,
      // See https://bugs.chromium.org/p/chromium/issues/detail?id=364374.
      // So we have to make do. Two cases:
      // 1. The format options tell us to show the zone. We can't do that, so the best
      // we can do is format the date in UTC.
      // 2. The format options don't tell us to show the zone. Then we can adjust them
      // the time and tell the formatter to show it to us in UTC, so that the time is right
      // and the bad zone doesn't show up.
      // We can clean all this up when Chrome fixes this.
      z = "UTC";

      if (opts.timeZoneName) {
        this.dt = dt;
      } else {
        this.dt = dt.offset === 0 ? dt : DateTime.fromMillis(dt.ts + dt.offset * 60 * 1000);
      }
    } else if (dt.zone.type === "local") {
      this.dt = dt;
    } else {
      this.dt = dt;
      z = dt.zone.name;
    }

    if (this.hasIntl) {
      const intlOpts = Object.assign({}, this.opts);

      if (z) {
        intlOpts.timeZone = z;
      }

      this.dtf = getCachedDTF(intl, intlOpts);
    }
  }

  format() {
    if (this.hasIntl) {
      return this.dtf.format(this.dt.toJSDate());
    } else {
      const tokenFormat = formatString(this.opts),
            loc = Locale.create("en-US");
      return Formatter.create(loc).formatDateTimeFromString(this.dt, tokenFormat);
    }
  }

  formatToParts() {
    if (this.hasIntl && hasFormatToParts()) {
      return this.dtf.formatToParts(this.dt.toJSDate());
    } else {
      // This is kind of a cop out. We actually could do this for English. However, we couldn't do it for intl strings
      // and IMO it's too weird to have an uncanny valley like that
      return [];
    }
  }

  resolvedOptions() {
    if (this.hasIntl) {
      return this.dtf.resolvedOptions();
    } else {
      return {
        locale: "en-US",
        numberingSystem: "latn",
        outputCalendar: "gregory"
      };
    }
  }

}
/**
 * @private
 */


class PolyRelFormatter {
  constructor(intl, isEnglish, opts) {
    this.opts = Object.assign({
      style: "long"
    }, opts);

    if (!isEnglish && hasRelative()) {
      this.rtf = getCachendRTF(intl, opts);
    }
  }

  format(count, unit) {
    if (this.rtf) {
      return this.rtf.format(count, unit);
    } else {
      return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
    }
  }

  formatToParts(count, unit) {
    if (this.rtf) {
      return this.rtf.formatToParts(count, unit);
    } else {
      return [];
    }
  }

}
/**
 * @private
 */


class Locale {
  static fromOpts(opts) {
    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
  }

  static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {
    const specifiedLocale = locale || Settings.defaultLocale,
          // the system locale is useful for human readable strings but annoying for parsing/formatting known formats
    localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale()),
          numberingSystemR = numberingSystem || Settings.defaultNumberingSystem,
          outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
  }

  static resetCache() {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
    intlRelCache = {};
  }

  static fromObject({
    locale,
    numberingSystem,
    outputCalendar
  } = {}) {
    return Locale.create(locale, numberingSystem, outputCalendar);
  }

  constructor(locale, numbering, outputCalendar, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
    this.weekdaysCache = {
      format: {},
      standalone: {}
    };
    this.monthsCache = {
      format: {},
      standalone: {}
    };
    this.meridiemCache = null;
    this.eraCache = {};
    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }

  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }

    return this.fastNumbersCached;
  }

  listingMode(defaultOK = true) {
    const intl = hasIntl(),
          hasFTP = intl && hasFormatToParts(),
          isActuallyEn = this.isEnglish(),
          hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");

    if (!hasFTP && !(isActuallyEn && hasNoWeirdness) && !defaultOK) {
      return "error";
    } else if (!hasFTP || isActuallyEn && hasNoWeirdness) {
      return "en";
    } else {
      return "intl";
    }
  }

  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return Locale.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, alts.defaultToEN || false);
    }
  }

  redefaultToEN(alts = {}) {
    return this.clone(Object.assign({}, alts, {
      defaultToEN: true
    }));
  }

  redefaultToSystem(alts = {}) {
    return this.clone(Object.assign({}, alts, {
      defaultToEN: false
    }));
  }

  months(length, format = false, defaultOK = true) {
    return listStuff(this, length, defaultOK, months, () => {
      const intl = format ? {
        month: length,
        day: "numeric"
      } : {
        month: length
      },
            formatStr = format ? "format" : "standalone";

      if (!this.monthsCache[formatStr][length]) {
        this.monthsCache[formatStr][length] = mapMonths(dt => this.extract(dt, intl, "month"));
      }

      return this.monthsCache[formatStr][length];
    });
  }

  weekdays(length, format = false, defaultOK = true) {
    return listStuff(this, length, defaultOK, weekdays, () => {
      const intl = format ? {
        weekday: length,
        year: "numeric",
        month: "long",
        day: "numeric"
      } : {
        weekday: length
      },
            formatStr = format ? "format" : "standalone";

      if (!this.weekdaysCache[formatStr][length]) {
        this.weekdaysCache[formatStr][length] = mapWeekdays(dt => this.extract(dt, intl, "weekday"));
      }

      return this.weekdaysCache[formatStr][length];
    });
  }

  meridiems(defaultOK = true) {
    return listStuff(this, undefined, defaultOK, () => meridiems, () => {
      // In theory there could be aribitrary day periods. We're gonna assume there are exactly two
      // for AM and PM. This is probably wrong, but it's makes parsing way easier.
      if (!this.meridiemCache) {
        const intl = {
          hour: "numeric",
          hour12: true
        };
        this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(dt => this.extract(dt, intl, "dayperiod"));
      }

      return this.meridiemCache;
    });
  }

  eras(length, defaultOK = true) {
    return listStuff(this, length, defaultOK, eras, () => {
      const intl = {
        era: length
      }; // This is utter bullshit. Different calendars are going to define eras totally differently. What I need is the minimum set of dates
      // to definitely enumerate them.

      if (!this.eraCache[length]) {
        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(dt => this.extract(dt, intl, "era"));
      }

      return this.eraCache[length];
    });
  }

  extract(dt, intlOpts, field) {
    const df = this.dtFormatter(dt, intlOpts),
          results = df.formatToParts(),
          matching = results.find(m => m.type.toLowerCase() === field);
    return matching ? matching.value : null;
  }

  numberFormatter(opts = {}) {
    // this forcesimple option is never used (the only caller short-circuits on it, but it seems safer to leave)
    // (in contrast, the rest of the condition is used heavily)
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  }

  dtFormatter(dt, intlOpts = {}) {
    return new PolyDateFormatter(dt, this.intl, intlOpts);
  }

  relFormatter(opts = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  }

  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || hasIntl() && new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }

  equals(other) {
    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
  }

}

/*
 * This file handles parsing for well-specified formats. Here's how it works:
 * Two things go into parsing: a regex to match with and an extractor to take apart the groups in the match.
 * An extractor is just a function that takes a regex match array and returns a { year: ..., month: ... } object
 * parse() does the work of executing the regex and applying the extractor. It takes multiple regex/extractor pairs to try in sequence.
 * Extractors can take a "cursor" representing the offset in the match to look at. This makes it easy to combine extractors.
 * combineExtractors() does the work of combining them, keeping track of the cursor through multiple extractions.
 * Some extractions are super dumb and simpleParse and fromStrings help DRY them.
 */

function combineRegexes(...regexes) {
  const full = regexes.reduce((f, r) => f + r.source, "");
  return RegExp(`^${full}$`);
}

function combineExtractors(...extractors) {
  return m => extractors.reduce(([mergedVals, mergedZone, cursor], ex) => {
    const [val, zone, next] = ex(m, cursor);
    return [Object.assign(mergedVals, val), mergedZone || zone, next];
  }, [{}, null, 1]).slice(0, 2);
}

function parse(s, ...patterns) {
  if (s == null) {
    return [null, null];
  }

  for (const [regex, extractor] of patterns) {
    const m = regex.exec(s);

    if (m) {
      return extractor(m);
    }
  }

  return [null, null];
}

function simpleParse(...keys) {
  return (match, cursor) => {
    const ret = {};
    let i;

    for (i = 0; i < keys.length; i++) {
      ret[keys[i]] = parseInteger(match[cursor + i]);
    }

    return [ret, null, cursor + i];
  };
} // ISO and SQL parsing


const offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/,
      isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,9}))?)?)?/,
      isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${offsetRegex.source}?`),
      isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`),
      isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/,
      isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/,
      isoOrdinalRegex = /(\d{4})-?(\d{3})/,
      extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay"),
      extractISOOrdinalData = simpleParse("year", "ordinal"),
      sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/,
      // dumbed-down version of the ISO one
sqlTimeRegex = RegExp(`${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`),
      sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);

function int(match, pos, fallback) {
  const m = match[pos];
  return isUndefined(m) ? fallback : parseInteger(m);
}

function extractISOYmd(match, cursor) {
  const item = {
    year: int(match, cursor),
    month: int(match, cursor + 1, 1),
    day: int(match, cursor + 2, 1)
  };
  return [item, null, cursor + 3];
}

function extractISOTime(match, cursor) {
  const item = {
    hour: int(match, cursor, 0),
    minute: int(match, cursor + 1, 0),
    second: int(match, cursor + 2, 0),
    millisecond: parseMillis(match[cursor + 3])
  };
  return [item, null, cursor + 4];
}

function extractISOOffset(match, cursor) {
  const local = !match[cursor] && !match[cursor + 1],
        fullOffset = signedOffset(match[cursor + 1], match[cursor + 2]),
        zone = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone, cursor + 3];
}

function extractIANAZone(match, cursor) {
  const zone = match[cursor] ? IANAZone.create(match[cursor]) : null;
  return [{}, zone, cursor + 1];
} // ISO duration parsing


const isoDuration = /^P(?:(?:(-?\d{1,9})Y)?(?:(-?\d{1,9})M)?(?:(-?\d{1,9})W)?(?:(-?\d{1,9})D)?(?:T(?:(-?\d{1,9})H)?(?:(-?\d{1,9})M)?(?:(-?\d{1,9})(?:[.,](-?\d{1,9}))?S)?)?)$/;

function extractISODuration(match) {
  const [, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match;
  return [{
    years: parseInteger(yearStr),
    months: parseInteger(monthStr),
    weeks: parseInteger(weekStr),
    days: parseInteger(dayStr),
    hours: parseInteger(hourStr),
    minutes: parseInteger(minuteStr),
    seconds: parseInteger(secondStr),
    milliseconds: parseMillis(millisecondsStr)
  }];
} // These are a little braindead. EDT *should* tell us that we're in, say, America/New_York
// and not just that we're in -240 *right now*. But since I don't think these are used that often
// I'm just going to ignore that


const obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};

function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  const result = {
    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr)
  };
  if (secondStr) result.second = parseInteger(secondStr);

  if (weekdayStr) {
    result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
  }

  return result;
} // RFC 2822/5322


const rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;

function extractRFC2822(match) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr, obsOffset, milOffset, offHourStr, offMinuteStr] = match,
        result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  let offset;

  if (obsOffset) {
    offset = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset = 0;
  } else {
    offset = signedOffset(offHourStr, offMinuteStr);
  }

  return [result, new FixedOffsetZone(offset)];
}

function preprocessRFC2822(s) {
  // Remove comments and folding whitespace and replace multiple-spaces with a single space
  return s.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
} // http date


const rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/,
      rfc850 = /^(Monday|Tuesday|Wedsday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/,
      ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;

function extractRFC1123Or850(match) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match,
        result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}

function extractASCII(match) {
  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match,
        result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}

const isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
const isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
const isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
const isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
const extractISOYmdTimeAndOffset = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset);
const extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset);
const extractISOOrdinalDataAndTime = combineExtractors(extractISOOrdinalData, extractISOTime);
const extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset);
/**
 * @private
 */

function parseISODate(s) {
  return parse(s, [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset], [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDataAndTime], [isoTimeCombinedRegex, extractISOTimeAndOffset]);
}
function parseRFC2822Date(s) {
  return parse(preprocessRFC2822(s), [rfc2822, extractRFC2822]);
}
function parseHTTPDate(s) {
  return parse(s, [rfc1123, extractRFC1123Or850], [rfc850, extractRFC1123Or850], [ascii, extractASCII]);
}
function parseISODuration(s) {
  return parse(s, [isoDuration, extractISODuration]);
}
const sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
const sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
const extractISOYmdTimeOffsetAndIANAZone = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone);
const extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
function parseSQL(s) {
  return parse(s, [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeOffsetAndIANAZone], [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]);
}

class Invalid {
  constructor(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }

  toMessage() {
    if (this.explanation) {
      return `${this.reason}: ${this.explanation}`;
    } else {
      return this.reason;
    }
  }

}

const INVALID = "Invalid Duration"; // unit conversion constants

const lowOrderMatrix = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1000
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1000
  },
  hours: {
    minutes: 60,
    seconds: 60 * 60,
    milliseconds: 60 * 60 * 1000
  },
  minutes: {
    seconds: 60,
    milliseconds: 60 * 1000
  },
  seconds: {
    milliseconds: 1000
  }
},
      casualMatrix = Object.assign({
  years: {
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1000
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1000
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1000
  }
}, lowOrderMatrix),
      daysInYearAccurate = 146097.0 / 400,
      daysInMonthAccurate = 146097.0 / 4800,
      accurateMatrix = Object.assign({
  years: {
    months: 12,
    weeks: daysInYearAccurate / 7,
    days: daysInYearAccurate,
    hours: daysInYearAccurate * 24,
    minutes: daysInYearAccurate * 24 * 60,
    seconds: daysInYearAccurate * 24 * 60 * 60,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000
  },
  quarters: {
    months: 3,
    weeks: daysInYearAccurate / 28,
    days: daysInYearAccurate / 4,
    hours: daysInYearAccurate * 24 / 4,
    minutes: daysInYearAccurate * 24 * 60 / 4,
    seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000 / 4
  },
  months: {
    weeks: daysInMonthAccurate / 7,
    days: daysInMonthAccurate,
    hours: daysInMonthAccurate * 24,
    minutes: daysInMonthAccurate * 24 * 60,
    seconds: daysInMonthAccurate * 24 * 60 * 60,
    milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1000
  }
}, lowOrderMatrix); // units ordered by size

const orderedUnits = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"];
const reverseUnits = orderedUnits.slice(0).reverse(); // clone really means "create another instance just like this one, but with these changes"

function clone(dur, alts, clear = false) {
  // deep merge for vals
  const conf = {
    values: clear ? alts.values : Object.assign({}, dur.values, alts.values || {}),
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy
  };
  return new Duration(conf);
}

function antiTrunc(n) {
  return n < 0 ? Math.floor(n) : Math.ceil(n);
} // NB: mutates parameters


function convert(matrix, fromMap, fromUnit, toMap, toUnit) {
  const conv = matrix[toUnit][fromUnit],
        raw = fromMap[fromUnit] / conv,
        sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]),
        // ok, so this is wild, but see the matrix in the tests
  added = !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);
  toMap[toUnit] += added;
  fromMap[fromUnit] -= added * conv;
} // NB: mutates parameters


function normalizeValues(matrix, vals) {
  reverseUnits.reduce((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        convert(matrix, vals, previous, vals, current);
      }

      return current;
    } else {
      return previous;
    }
  }, null);
}
/**
 * A Duration object represents a period of time, like "2 months" or "1 day, 1 hour". Conceptually, it's just a map of units to their quantities, accompanied by some additional configuration and methods for creating, parsing, interrogating, transforming, and formatting them. They can be used on their own or in conjunction with other Luxon types; for example, you can use {@link DateTime.plus} to add a Duration object to a DateTime, producing another DateTime.
 *
 * Here is a brief overview of commonly used methods and getters in Duration:
 *
 * * **Creation** To create a Duration, use {@link Duration.fromMillis}, {@link Duration.fromObject}, or {@link Duration.fromISO}.
 * * **Unit values** See the {@link Duration.years}, {@link Duration.months}, {@link Duration.weeks}, {@link Duration.days}, {@link Duration.hours}, {@link Duration.minutes}, {@link Duration.seconds}, {@link Duration.milliseconds} accessors.
 * * **Configuration** See  {@link Duration.locale} and {@link Duration.numberingSystem} accessors.
 * * **Transformation** To create new Durations out of old ones use {@link Duration.plus}, {@link Duration.minus}, {@link Duration.normalize}, {@link Duration.set}, {@link Duration.reconfigure}, {@link Duration.shiftTo}, and {@link Duration.negate}.
 * * **Output** To convert the Duration into other representations, see {@link Duration.as}, {@link Duration.toISO}, {@link Duration.toFormat}, and {@link Duration.toJSON}
 *
 * There's are more methods documented below. In addition, for more information on subtler topics like internationalization and validity, see the external documentation.
 */


class Duration {
  /**
   * @private
   */
  constructor(config) {
    const accurate = config.conversionAccuracy === "longterm" || false;
    /**
     * @access private
     */

    this.values = config.values;
    /**
     * @access private
     */

    this.loc = config.loc || Locale.create();
    /**
     * @access private
     */

    this.conversionAccuracy = accurate ? "longterm" : "casual";
    /**
     * @access private
     */

    this.invalid = config.invalid || null;
    /**
     * @access private
     */

    this.matrix = accurate ? accurateMatrix : casualMatrix;
    /**
     * @access private
     */

    this.isLuxonDuration = true;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */


  static fromMillis(count, opts) {
    return Duration.fromObject(Object.assign({
      milliseconds: count
    }, opts));
  }
  /**
   * Create a Duration from a Javascript object with keys like 'years' and 'hours.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {string} [obj.locale='en-US'] - the locale to use
   * @param {string} obj.numberingSystem - the numbering system to use
   * @param {string} [obj.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */


  static fromObject(obj) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError(`Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`);
    }

    return new Duration({
      values: normalizeObject(obj, Duration.normalizeUnit, ["locale", "numberingSystem", "conversionAccuracy", "zone" // a bit of debt; it's super inconvenient internally not to be able to blindly pass this
      ]),
      loc: Locale.fromObject(obj),
      conversionAccuracy: obj.conversionAccuracy
    });
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */


  static fromISO(text, opts) {
    const [parsed] = parseISODuration(text);

    if (parsed) {
      const obj = Object.assign(parsed, opts);
      return Duration.fromObject(obj);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */


  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }

    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);

    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new Duration({
        invalid
      });
    }
  }
  /**
   * @private
   */


  static normalizeUnit(unit) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[unit ? unit.toLowerCase() : unit];
    if (!normalized) throw new InvalidUnitError(unit);
    return normalized;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */


  static isDuration(o) {
    return o && o.isLuxonDuration || false;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */


  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */


  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * The duration will be converted to the set of units in the format string using {@link Duration.shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */


  toFormat(fmt, opts = {}) {
    // reverse-compat since 1.2; we always round down now, never up, and we do it by default
    const fmtOpts = Object.assign({}, opts, {
      floor: opts.round !== false && opts.floor !== false
    });
    return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID;
  }
  /**
   * Returns a Javascript object with this Duration's values.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */


  toObject(opts = {}) {
    if (!this.isValid) return {};
    const base = Object.assign({}, this.values);

    if (opts.includeConfig) {
      base.conversionAccuracy = this.conversionAccuracy;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }

    return base;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */


  toISO() {
    // we could use the formatter, but this is an easier way to get the minimum string
    if (!this.isValid) return null;
    let s = "P";
    if (this.years !== 0) s += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0) s += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0) s += this.weeks + "W";
    if (this.days !== 0) s += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) s += "T";
    if (this.hours !== 0) s += this.hours + "H";
    if (this.minutes !== 0) s += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0) s += this.seconds + this.milliseconds / 1000 + "S";
    if (s === "P") s += "T0S";
    return s;
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */


  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */


  toString() {
    return this.toISO();
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */


  valueOf() {
    return this.as("milliseconds");
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */


  plus(duration) {
    if (!this.isValid) return this;
    const dur = friendlyDuration(duration),
          result = {};

    for (const k of orderedUnits) {
      if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
        result[k] = dur.get(k) + this.get(k);
      }
    }

    return clone(this, {
      values: result
    }, true);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */


  minus(duration) {
    if (!this.isValid) return this;
    const dur = friendlyDuration(duration);
    return this.plus(dur.negate());
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).years //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).months //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).days //=> 3
   * @return {number}
   */


  get(unit) {
    return this[Duration.normalizeUnit(unit)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */


  set(values) {
    if (!this.isValid) return this;
    const mixed = Object.assign(this.values, normalizeObject(values, Duration.normalizeUnit, []));
    return clone(this, {
      values: mixed
    });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */


  reconfigure({
    locale,
    numberingSystem,
    conversionAccuracy
  } = {}) {
    const loc = this.loc.clone({
      locale,
      numberingSystem
    }),
          opts = {
      loc
    };

    if (conversionAccuracy) {
      opts.conversionAccuracy = conversionAccuracy;
    }

    return clone(this, opts);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */


  as(unit) {
    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @return {Duration}
   */


  normalize() {
    if (!this.isValid) return this;
    const vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone(this, {
      values: vals
    }, true);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */


  shiftTo(...units) {
    if (!this.isValid) return this;

    if (units.length === 0) {
      return this;
    }

    units = units.map(u => Duration.normalizeUnit(u));
    const built = {},
          accumulated = {},
          vals = this.toObject();
    let lastUnit;
    normalizeValues(this.matrix, vals);

    for (const k of orderedUnits) {
      if (units.indexOf(k) >= 0) {
        lastUnit = k;
        let own = 0; // anything we haven't boiled down yet should get boiled to this unit

        for (const ak in accumulated) {
          own += this.matrix[ak][k] * accumulated[ak];
          accumulated[ak] = 0;
        } // plus anything that's already in this unit


        if (isNumber(vals[k])) {
          own += vals[k];
        }

        const i = Math.trunc(own);
        built[k] = i;
        accumulated[k] = own - i; // we'd like to absorb these fractions in another unit
        // plus anything further down the chain that should be rolled up in to this

        for (const down in vals) {
          if (orderedUnits.indexOf(down) > orderedUnits.indexOf(k)) {
            convert(this.matrix, vals, down, built, k);
          }
        } // otherwise, keep it in the wings to boil it later

      } else if (isNumber(vals[k])) {
        accumulated[k] = vals[k];
      }
    } // anything leftover becomes the decimal for the last unit
    // lastUnit must be defined since units is not empty


    for (const key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }

    return clone(this, {
      values: built
    }, true).normalize();
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */


  negate() {
    if (!this.isValid) return this;
    const negated = {};

    for (const k of Object.keys(this.values)) {
      negated[k] = -this.values[k];
    }

    return clone(this, {
      values: negated
    }, true);
  }
  /**
   * Get the years.
   * @type {number}
   */


  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */


  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */


  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */


  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */


  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */


  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */


  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */


  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */


  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */


  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */


  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */


  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */


  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }

    if (!this.loc.equals(other.loc)) {
      return false;
    }

    for (const u of orderedUnits) {
      if (this.values[u] !== other.values[u]) {
        return false;
      }
    }

    return true;
  }

}
/**
 * @private
 */

function friendlyDuration(durationish) {
  if (isNumber(durationish)) {
    return Duration.fromMillis(durationish);
  } else if (Duration.isDuration(durationish)) {
    return durationish;
  } else if (typeof durationish === "object") {
    return Duration.fromObject(durationish);
  } else {
    throw new InvalidArgumentError(`Unknown duration argument ${durationish} of type ${typeof durationish}`);
  }
}

const INVALID$1 = "Invalid Interval"; // checks if the start is equal to or before the end

function validateStartEnd(start, end) {
  if (!start || !start.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end || !end.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end < start) {
    return Interval.invalid("end before start", `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`);
  } else {
    return null;
  }
}
/**
 * An Interval object represents a half-open interval of time, where each endpoint is a {@link DateTime}. Conceptually, it's a container for those two endpoints, accompanied by methods for creating, parsing, interrogating, comparing, transforming, and formatting them.
 *
 * Here is a brief overview of the most commonly used methods and getters in Interval:
 *
 * * **Creation** To create an Interval, use {@link fromDateTimes}, {@link after}, {@link before}, or {@link fromISO}.
 * * **Accessors** Use {@link start} and {@link end} to get the start and end.
 * * **Interrogation** To analyze the Interval, use {@link count}, {@link length}, {@link hasSame}, {@link contains}, {@link isAfter}, or {@link isBefore}.
 * * **Transformation** To create other Intervals out of this one, use {@link set}, {@link splitAt}, {@link splitBy}, {@link divideEqually}, {@link merge}, {@link xor}, {@link union}, {@link intersection}, or {@link difference}.
 * * **Comparison** To compare this Interval to another one, use {@link equals}, {@link overlaps}, {@link abutsStart}, {@link abutsEnd}, {@link engulfs}
 * * **Output*** To convert the Interval into other representations, see {@link toString}, {@link toISO}, {@link toFormat}, and {@link toDuration}.
 */


class Interval {
  /**
   * @private
   */
  constructor(config) {
    /**
     * @access private
     */
    this.s = config.start;
    /**
     * @access private
     */

    this.e = config.end;
    /**
     * @access private
     */

    this.invalid = config.invalid || null;
    /**
     * @access private
     */

    this.isLuxonInterval = true;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */


  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }

    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);

    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid);
    } else {
      return new Interval({
        invalid
      });
    }
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */


  static fromDateTimes(start, end) {
    const builtStart = friendlyDateTime(start),
          builtEnd = friendlyDateTime(end);
    const validateError = validateStartEnd(builtStart, builtEnd);

    if (validateError == null) {
      return new Interval({
        start: builtStart,
        end: builtEnd
      });
    } else {
      return validateError;
    }
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */


  static after(start, duration) {
    const dur = friendlyDuration(duration),
          dt = friendlyDateTime(start);
    return Interval.fromDateTimes(dt, dt.plus(dur));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */


  static before(end, duration) {
    const dur = friendlyDuration(duration),
          dt = friendlyDateTime(end);
    return Interval.fromDateTimes(dt.minus(dur), dt);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime.fromISO} and optionally {@link Duration.fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */


  static fromISO(text, opts) {
    const [s, e] = (text || "").split("/", 2);

    if (s && e) {
      const start = DateTime.fromISO(s, opts),
            end = DateTime.fromISO(e, opts);

      if (start.isValid && end.isValid) {
        return Interval.fromDateTimes(start, end);
      }

      if (start.isValid) {
        const dur = Duration.fromISO(e, opts);

        if (dur.isValid) {
          return Interval.after(start, dur);
        }
      } else if (end.isValid) {
        const dur = Duration.fromISO(s, opts);

        if (dur.isValid) {
          return Interval.before(end, dur);
        }
      }
    }

    return Interval.invalid("unparsable", `the input "${text}" can't be parsed asISO 8601`);
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */


  static isInterval(o) {
    return o && o.isLuxonInterval || false;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */


  get start() {
    return this.isValid ? this.s : null;
  }
  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */


  get end() {
    return this.isValid ? this.e : null;
  }
  /**
   * Returns whether this Interval's end is at least its start, i.e. that the Interval isn't 'backwards'.
   * @type {boolean}
   */


  get isValid() {
    return this.invalidReason === null;
  }
  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */


  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */


  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */


  length(unit = "milliseconds") {
    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @return {number}
   */


  count(unit = "milliseconds") {
    if (!this.isValid) return NaN;
    const start = this.start.startOf(unit),
          end = this.end.startOf(unit);
    return Math.floor(end.diff(start, unit).get(unit)) + 1;
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */


  hasSame(unit) {
    return this.isValid ? this.e.minus(1).hasSame(this.s, unit) : false;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */


  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */


  isAfter(dateTime) {
    if (!this.isValid) return false;
    return this.s > dateTime;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */


  isBefore(dateTime) {
    if (!this.isValid) return false;
    return this.e <= dateTime;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */


  contains(dateTime) {
    if (!this.isValid) return false;
    return this.s <= dateTime && this.e > dateTime;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */


  set({
    start,
    end
  } = {}) {
    if (!this.isValid) return this;
    return Interval.fromDateTimes(start || this.s, end || this.e);
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...[DateTime]} dateTimes - the unit of time to count.
   * @return {[Interval]}
   */


  splitAt(...dateTimes) {
    if (!this.isValid) return [];
    const sorted = dateTimes.map(friendlyDateTime).filter(d => this.contains(d)).sort(),
          results = [];
    let {
      s
    } = this,
        i = 0;

    while (s < this.e) {
      const added = sorted[i] || this.e,
            next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s, next));
      s = next;
      i += 1;
    }

    return results;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {[Interval]}
   */


  splitBy(duration) {
    const dur = friendlyDuration(duration);

    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }

    let {
      s
    } = this,
        added,
        next;
    const results = [];

    while (s < this.e) {
      added = s.plus(dur);
      next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s, next));
      s = next;
    }

    return results;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {[Interval]}
   */


  divideEqually(numberOfParts) {
    if (!this.isValid) return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */


  overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */


  abutsStart(other) {
    if (!this.isValid) return false;
    return +this.e === +other.s;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */


  abutsEnd(other) {
    if (!this.isValid) return false;
    return +other.e === +this.s;
  }
  /**
   * Return whether this Interval engulfs the start and end of the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */


  engulfs(other) {
    if (!this.isValid) return false;
    return this.s <= other.s && this.e >= other.e;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */


  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }

    return this.s.equals(other.s) && this.e.equals(other.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, i.e., the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */


  intersection(other) {
    if (!this.isValid) return this;
    const s = this.s > other.s ? this.s : other.s,
          e = this.e < other.e ? this.e : other.e;

    if (s > e) {
      return null;
    } else {
      return Interval.fromDateTimes(s, e);
    }
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */


  union(other) {
    if (!this.isValid) return this;
    const s = this.s < other.s ? this.s : other.s,
          e = this.e > other.e ? this.e : other.e;
    return Interval.fromDateTimes(s, e);
  }
  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {[Interval]} intervals
   * @return {[Interval]}
   */


  static merge(intervals) {
    const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(([sofar, current], item) => {
      if (!current) {
        return [sofar, item];
      } else if (current.overlaps(item) || current.abutsStart(item)) {
        return [sofar, current.union(item)];
      } else {
        return [sofar.concat([current]), item];
      }
    }, [[], null]);

    if (final) {
      found.push(final);
    }

    return found;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {[Interval]} intervals
   * @return {[Interval]}
   */


  static xor(intervals) {
    let start = null,
        currentCount = 0;
    const results = [],
          ends = intervals.map(i => [{
      time: i.s,
      type: "s"
    }, {
      time: i.e,
      type: "e"
    }]),
          flattened = Array.prototype.concat(...ends),
          arr = flattened.sort((a, b) => a.time - b.time);

    for (const i of arr) {
      currentCount += i.type === "s" ? 1 : -1;

      if (currentCount === 1) {
        start = i.time;
      } else {
        if (start && +start !== +i.time) {
          results.push(Interval.fromDateTimes(start, i.time));
        }

        start = null;
      }
    }

    return Interval.merge(results);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {[Interval]}
   */


  difference(...intervals) {
    return Interval.xor([this].concat(intervals)).map(i => this.intersection(i)).filter(i => i && !i.isEmpty());
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */


  toString() {
    if (!this.isValid) return INVALID$1;
    return `[${this.s.toISO()}  ${this.e.toISO()})`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime.toISO}
   * @return {string}
   */


  toISO(opts) {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format string.
   * @param {string} dateFormat - the format string. This string formats the start and end time. See {@link DateTime.toFormat} for details.
   * @param {Object} opts - options
   * @param {string} [opts.separator =  '  '] - a separator to place between the start and end representations
   * @return {string}
   */


  toFormat(dateFormat, {
    separator = "  "
  } = {}) {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */


  toDuration(unit, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }

    return this.e.diff(this.s, unit, opts);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */


  mapEndpoints(mapFn) {
    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  }

}

/**
 * The Info class contains static methods for retrieving general time and date related data. For example, it has methods for finding out if a time zone has a DST, for listing the months in any supported locale, and for discovering which of Luxon features are available in the current environment.
 */

class Info {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(zone = Settings.defaultZone) {
    const proto = DateTime.local().setZone(zone).set({
      month: 12
    });
    return !zone.universal && proto.offset !== proto.set({
      month: 6
    }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */


  static isValidIANAZone(zone) {
    return IANAZone.isValidSpecifier(zone) && IANAZone.isValidZone(zone);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone.isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */


  static normalizeZone(input) {
    return normalizeZone(input, Settings.defaultZone);
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> ''
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'
   * @return {[string]}
   */


  static months(length = "long", {
    locale = null,
    numberingSystem = null,
    outputCalendar = "gregory"
  } = {}) {
    return Locale.create(locale, numberingSystem, outputCalendar).months(length);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {[string]}
   */


  static monthsFormat(length = "long", {
    locale = null,
    numberingSystem = null,
    outputCalendar = "gregory"
  } = {}) {
    return Locale.create(locale, numberingSystem, outputCalendar).months(length, true);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> ''
   * @return {[string]}
   */


  static weekdays(length = "long", {
    locale = null,
    numberingSystem = null
  } = {}) {
    return Locale.create(locale, numberingSystem, null).weekdays(length);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @return {[string]}
   */


  static weekdaysFormat(length = "long", {
    locale = null,
    numberingSystem = null
  } = {}) {
    return Locale.create(locale, numberingSystem, null).weekdays(length, true);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ '', '' ]
   * @return {[string]}
   */


  static meridiems({
    locale = null
  } = {}) {
    return Locale.create(locale).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]
   * @return {[string]}
   */


  static eras(length = "short", {
    locale = null
  } = {}) {
    return Locale.create(locale, null, "gregory").eras(length);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, timezone support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `zones`: whether this environment supports IANA timezones
   * * `intlTokens`: whether this environment supports internationalized token-based formatting/parsing
   * * `intl`: whether this environment supports general internationalization
   * * `relative`: whether this environment supports relative time formatting
   * @example Info.features() //=> { intl: true, intlTokens: false, zones: true, relative: false }
   * @return {Object}
   */


  static features() {
    let intl = false,
        intlTokens = false,
        zones = false,
        relative = false;

    if (hasIntl()) {
      intl = true;
      intlTokens = hasFormatToParts();
      relative = hasRelative();

      try {
        zones = new Intl.DateTimeFormat("en", {
          timeZone: "America/New_York"
        }).resolvedOptions().timeZone === "America/New_York";
      } catch (e) {
        zones = false;
      }
    }

    return {
      intl,
      intlTokens,
      zones,
      relative
    };
  }

}

function dayDiff(earlier, later) {
  const utcDayStart = dt => dt.toUTC(0, {
    keepLocalTime: true
  }).startOf("day").valueOf(),
        ms = utcDayStart(later) - utcDayStart(earlier);

  return Math.floor(Duration.fromMillis(ms).as("days"));
}

function highOrderDiffs(cursor, later, units) {
  const differs = [["years", (a, b) => b.year - a.year], ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12], ["weeks", (a, b) => {
    const days = dayDiff(a, b);
    return (days - days % 7) / 7;
  }], ["days", dayDiff]];
  const results = {};
  let lowestOrder, highWater;

  for (const [unit, differ] of differs) {
    if (units.indexOf(unit) >= 0) {
      lowestOrder = unit;
      let delta = differ(cursor, later);
      highWater = cursor.plus({
        [unit]: delta
      });

      if (highWater > later) {
        cursor = cursor.plus({
          [unit]: delta - 1
        });
        delta -= 1;
      } else {
        cursor = highWater;
      }

      results[unit] = delta;
    }
  }

  return [cursor, results, highWater, lowestOrder];
}

function diff (earlier, later, units, opts) {
  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
  const remainingMillis = later - cursor;
  const lowerOrderUnits = units.filter(u => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0);

  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      highWater = cursor.plus({
        [lowestOrder]: 1
      });
    }

    if (highWater !== cursor) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
    }
  }

  const duration = Duration.fromObject(Object.assign(results, opts));

  if (lowerOrderUnits.length > 0) {
    return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
  } else {
    return duration;
  }
}

const numberingSystems = {
  arab: "[\u0660-\u0669]",
  arabext: "[\u06F0-\u06F9]",
  bali: "[\u1B50-\u1B59]",
  beng: "[\u09E6-\u09EF]",
  deva: "[\u0966-\u096F]",
  fullwide: "[\uFF10-\uFF19]",
  gujr: "[\u0AE6-\u0AEF]",
  hanidec: "[|||||||||]",
  khmr: "[\u17E0-\u17E9]",
  knda: "[\u0CE6-\u0CEF]",
  laoo: "[\u0ED0-\u0ED9]",
  limb: "[\u1946-\u194F]",
  mlym: "[\u0D66-\u0D6F]",
  mong: "[\u1810-\u1819]",
  mymr: "[\u1040-\u1049]",
  orya: "[\u0B66-\u0B6F]",
  tamldec: "[\u0BE6-\u0BEF]",
  telu: "[\u0C66-\u0C6F]",
  thai: "[\u0E50-\u0E59]",
  tibt: "[\u0F20-\u0F29]",
  latn: "\\d"
};
const numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
}; // eslint-disable-next-line

const hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(str) {
  let value = parseInt(str, 10);

  if (isNaN(value)) {
    value = "";

    for (let i = 0; i < str.length; i++) {
      const code = str.charCodeAt(i);

      if (str[i].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str[i]);
      } else {
        for (const key in numberingSystemsUTF16) {
          const [min, max] = numberingSystemsUTF16[key];

          if (code >= min && code <= max) {
            value += code - min;
          }
        }
      }
    }

    return parseInt(value, 10);
  } else {
    return value;
  }
}
function digitRegex({
  numberingSystem
}, append = "") {
  return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append}`);
}

const MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";

function intUnit(regex, post = i => i) {
  return {
    regex,
    deser: ([s]) => post(parseDigits(s))
  };
}

function fixListRegex(s) {
  // make dots optional and also make them literal
  return s.replace(/\./, "\\.?");
}

function stripInsensitivities(s) {
  return s.replace(/\./, "").toLowerCase();
}

function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: ([s]) => strings.findIndex(i => stripInsensitivities(s) === stripInsensitivities(i)) + startIndex
    };
  }
}

function offset(regex, groups) {
  return {
    regex,
    deser: ([, h, m]) => signedOffset(h, m),
    groups
  };
}

function simple(regex) {
  return {
    regex,
    deser: ([s]) => s
  };
}

function escapeToken(value) {
  // eslint-disable-next-line no-useless-escape
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}

function unitForToken(token, loc) {
  const one = digitRegex(loc),
        two = digitRegex(loc, "{2}"),
        three = digitRegex(loc, "{3}"),
        four = digitRegex(loc, "{4}"),
        six = digitRegex(loc, "{6}"),
        oneOrTwo = digitRegex(loc, "{1,2}"),
        oneToThree = digitRegex(loc, "{1,3}"),
        oneToSix = digitRegex(loc, "{1,6}"),
        oneToNine = digitRegex(loc, "{1,9}"),
        twoToFour = digitRegex(loc, "{2,4}"),
        fourToSix = digitRegex(loc, "{4,6}"),
        literal = t => ({
    regex: RegExp(escapeToken(t.val)),
    deser: ([s]) => s,
    literal: true
  }),
        unitate = t => {
    if (token.literal) {
      return literal(t);
    }

    switch (t.val) {
      // era
      case "G":
        return oneOf(loc.eras("short", false), 0);

      case "GG":
        return oneOf(loc.eras("long", false), 0);
      // years

      case "y":
        return intUnit(oneToSix);

      case "yy":
        return intUnit(twoToFour, untruncateYear);

      case "yyyy":
        return intUnit(four);

      case "yyyyy":
        return intUnit(fourToSix);

      case "yyyyyy":
        return intUnit(six);
      // months

      case "M":
        return intUnit(oneOrTwo);

      case "MM":
        return intUnit(two);

      case "MMM":
        return oneOf(loc.months("short", true, false), 1);

      case "MMMM":
        return oneOf(loc.months("long", true, false), 1);

      case "L":
        return intUnit(oneOrTwo);

      case "LL":
        return intUnit(two);

      case "LLL":
        return oneOf(loc.months("short", false, false), 1);

      case "LLLL":
        return oneOf(loc.months("long", false, false), 1);
      // dates

      case "d":
        return intUnit(oneOrTwo);

      case "dd":
        return intUnit(two);
      // ordinals

      case "o":
        return intUnit(oneToThree);

      case "ooo":
        return intUnit(three);
      // time

      case "HH":
        return intUnit(two);

      case "H":
        return intUnit(oneOrTwo);

      case "hh":
        return intUnit(two);

      case "h":
        return intUnit(oneOrTwo);

      case "mm":
        return intUnit(two);

      case "m":
        return intUnit(oneOrTwo);

      case "s":
        return intUnit(oneOrTwo);

      case "ss":
        return intUnit(two);

      case "S":
        return intUnit(oneToThree);

      case "SSS":
        return intUnit(three);

      case "u":
        return simple(oneToNine);
      // meridiem

      case "a":
        return oneOf(loc.meridiems(), 0);
      // weekYear (k)

      case "kkkk":
        return intUnit(four);

      case "kk":
        return intUnit(twoToFour, untruncateYear);
      // weekNumber (W)

      case "W":
        return intUnit(oneOrTwo);

      case "WW":
        return intUnit(two);
      // weekdays

      case "E":
      case "c":
        return intUnit(one);

      case "EEE":
        return oneOf(loc.weekdays("short", false, false), 1);

      case "EEEE":
        return oneOf(loc.weekdays("long", false, false), 1);

      case "ccc":
        return oneOf(loc.weekdays("short", true, false), 1);

      case "cccc":
        return oneOf(loc.weekdays("long", true, false), 1);
      // offset/zone

      case "Z":
      case "ZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);

      case "ZZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
      // we don't support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing
      // because we don't have any way to figure out what they are

      case "z":
        return simple(/[a-z_+-/]{1,256}?/i);

      default:
        return literal(t);
    }
  };

  const unit = unitate(token) || {
    invalidReason: MISSING_FTP
  };
  unit.token = token;
  return unit;
}

const partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  hour: {
    numeric: "h",
    "2-digit": "hh"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  }
};

function tokenForPart(part, locale, formatOpts) {
  const {
    type,
    value
  } = part;

  if (type === "literal") {
    return {
      literal: true,
      val: value
    };
  }

  const style = formatOpts[type];
  let val = partTypeStyleToTokenVal[type];

  if (typeof val === "object") {
    val = val[style];
  }

  if (val) {
    return {
      literal: false,
      val
    };
  }

  return undefined;
}

function buildRegex(units) {
  const re = units.map(u => u.regex).reduce((f, r) => `${f}(${r.source})`, "");
  return [`^${re}$`, units];
}

function match(input, regex, handlers) {
  const matches = input.match(regex);

  if (matches) {
    const all = {};
    let matchIndex = 1;

    for (const i in handlers) {
      if (hasOwnProperty(handlers, i)) {
        const h = handlers[i],
              groups = h.groups ? h.groups + 1 : 1;

        if (!h.literal && h.token) {
          all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
        }

        matchIndex += groups;
      }
    }

    return [matches, all];
  } else {
    return [matches, {}];
  }
}

function dateTimeFromMatches(matches) {
  const toField = token => {
    switch (token) {
      case "S":
        return "millisecond";

      case "s":
        return "second";

      case "m":
        return "minute";

      case "h":
      case "H":
        return "hour";

      case "d":
        return "day";

      case "o":
        return "ordinal";

      case "L":
      case "M":
        return "month";

      case "y":
        return "year";

      case "E":
      case "c":
        return "weekday";

      case "W":
        return "weekNumber";

      case "k":
        return "weekYear";

      default:
        return null;
    }
  };

  let zone;

  if (!isUndefined(matches.Z)) {
    zone = new FixedOffsetZone(matches.Z);
  } else if (!isUndefined(matches.z)) {
    zone = IANAZone.create(matches.z);
  } else {
    zone = null;
  }

  if (!isUndefined(matches.h)) {
    if (matches.h < 12 && matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 && matches.a === 0) {
      matches.h = 0;
    }
  }

  if (matches.G === 0 && matches.y) {
    matches.y = -matches.y;
  }

  if (!isUndefined(matches.u)) {
    matches.S = parseMillis(matches.u);
  }

  const vals = Object.keys(matches).reduce((r, k) => {
    const f = toField(k);

    if (f) {
      r[f] = matches[k];
    }

    return r;
  }, {});
  return [vals, zone];
}

let dummyDateTimeCache = null;

function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }

  return dummyDateTimeCache;
}

function maybeExpandMacroToken(token, locale) {
  if (token.literal) {
    return token;
  }

  const formatOpts = Formatter.macroTokenToFormatOpts(token.val);

  if (!formatOpts) {
    return token;
  }

  const formatter = Formatter.create(locale, formatOpts);
  const parts = formatter.formatDateTimeParts(getDummyDateTime());
  const tokens = parts.map(p => tokenForPart(p, locale, formatOpts));

  if (tokens.includes(undefined)) {
    return token;
  }

  return tokens;
}

function expandMacroTokens(tokens, locale) {
  return Array.prototype.concat(...tokens.map(t => maybeExpandMacroToken(t, locale)));
}
/**
 * @private
 */


function explainFromTokens(locale, input, format) {
  const tokens = expandMacroTokens(Formatter.parseFormat(format), locale),
        units = tokens.map(t => unitForToken(t, locale)),
        disqualifyingUnit = units.find(t => t.invalidReason);

  if (disqualifyingUnit) {
    return {
      input,
      tokens,
      invalidReason: disqualifyingUnit.invalidReason
    };
  } else {
    const [regexString, handlers] = buildRegex(units),
          regex = RegExp(regexString, "i"),
          [rawMatches, matches] = match(input, regex, handlers),
          [result, zone] = matches ? dateTimeFromMatches(matches) : [null, null];
    return {
      input,
      tokens,
      regex,
      rawMatches,
      matches,
      result,
      zone
    };
  }
}
function parseFromTokens(locale, input, format) {
  const {
    result,
    zone,
    invalidReason
  } = explainFromTokens(locale, input, format);
  return [result, zone, invalidReason];
}

const nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],
      leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];

function unitOutOfRange(unit, value) {
  return new Invalid("unit out of range", `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`);
}

function dayOfWeek(year, month, day) {
  const js = new Date(Date.UTC(year, month - 1, day)).getUTCDay();
  return js === 0 ? 7 : js;
}

function computeOrdinal(year, month, day) {
  return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
}

function uncomputeOrdinal(year, ordinal) {
  const table = isLeapYear(year) ? leapLadder : nonLeapLadder,
        month0 = table.findIndex(i => i < ordinal),
        day = ordinal - table[month0];
  return {
    month: month0 + 1,
    day
  };
}
/**
 * @private
 */


function gregorianToWeek(gregObj) {
  const {
    year,
    month,
    day
  } = gregObj,
        ordinal = computeOrdinal(year, month, day),
        weekday = dayOfWeek(year, month, day);
  let weekNumber = Math.floor((ordinal - weekday + 10) / 7),
      weekYear;

  if (weekNumber < 1) {
    weekYear = year - 1;
    weekNumber = weeksInWeekYear(weekYear);
  } else if (weekNumber > weeksInWeekYear(year)) {
    weekYear = year + 1;
    weekNumber = 1;
  } else {
    weekYear = year;
  }

  return Object.assign({
    weekYear,
    weekNumber,
    weekday
  }, timeObject(gregObj));
}
function weekToGregorian(weekData) {
  const {
    weekYear,
    weekNumber,
    weekday
  } = weekData,
        weekdayOfJan4 = dayOfWeek(weekYear, 1, 4),
        yearInDays = daysInYear(weekYear);
  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3,
      year;

  if (ordinal < 1) {
    year = weekYear - 1;
    ordinal += daysInYear(year);
  } else if (ordinal > yearInDays) {
    year = weekYear + 1;
    ordinal -= daysInYear(weekYear);
  } else {
    year = weekYear;
  }

  const {
    month,
    day
  } = uncomputeOrdinal(year, ordinal);
  return Object.assign({
    year,
    month,
    day
  }, timeObject(weekData));
}
function gregorianToOrdinal(gregData) {
  const {
    year,
    month,
    day
  } = gregData,
        ordinal = computeOrdinal(year, month, day);
  return Object.assign({
    year,
    ordinal
  }, timeObject(gregData));
}
function ordinalToGregorian(ordinalData) {
  const {
    year,
    ordinal
  } = ordinalData,
        {
    month,
    day
  } = uncomputeOrdinal(year, ordinal);
  return Object.assign({
    year,
    month,
    day
  }, timeObject(ordinalData));
}
function hasInvalidWeekData(obj) {
  const validYear = isInteger(obj.weekYear),
        validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)),
        validWeekday = integerBetween(obj.weekday, 1, 7);

  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.week);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else return false;
}
function hasInvalidOrdinalData(obj) {
  const validYear = isInteger(obj.year),
        validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));

  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else return false;
}
function hasInvalidGregorianData(obj) {
  const validYear = isInteger(obj.year),
        validMonth = integerBetween(obj.month, 1, 12),
        validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));

  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else return false;
}
function hasInvalidTimeData(obj) {
  const {
    hour,
    minute,
    second,
    millisecond
  } = obj;
  const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0,
        validMinute = integerBetween(minute, 0, 59),
        validSecond = integerBetween(second, 0, 59),
        validMillisecond = integerBetween(millisecond, 0, 999);

  if (!validHour) {
    return unitOutOfRange("hour", hour);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else return false;
}

const INVALID$2 = "Invalid DateTime";
const MAX_DATE = 8.64e15;

function unsupportedZone(zone) {
  return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
} // we cache week data on the DT object and this intermediates the cache


function possiblyCachedWeekData(dt) {
  if (dt.weekData === null) {
    dt.weekData = gregorianToWeek(dt.c);
  }

  return dt.weekData;
} // clone really means, "make a new object with these modifications". all "setters" really use this
// to create a new object while only changing some of the properties


function clone$1(inst, alts) {
  const current = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid
  };
  return new DateTime(Object.assign({}, current, alts, {
    old: current
  }));
} // find the right offset a given local time. The o input is our guess, which determines which
// offset we'll pick in ambiguous cases (e.g. there are two 3 AMs b/c Fallback DST)


function fixOffset(localTS, o, tz) {
  // Our UTC time is just a guess because our offset is just a guess
  let utcGuess = localTS - o * 60 * 1000; // Test whether the zone matches the offset for this ts

  const o2 = tz.offset(utcGuess); // If so, offset didn't change and we're done

  if (o === o2) {
    return [utcGuess, o];
  } // If not, change the ts by the difference in the offset


  utcGuess -= (o2 - o) * 60 * 1000; // If that gives us the local time we want, we're done

  const o3 = tz.offset(utcGuess);

  if (o2 === o3) {
    return [utcGuess, o2];
  } // If it's different, we're in a hole time. The offset has changed, but the we don't adjust the time


  return [localTS - Math.min(o2, o3) * 60 * 1000, Math.max(o2, o3)];
} // convert an epoch timestamp into a calendar object with the given offset


function tsToObj(ts, offset) {
  ts += offset * 60 * 1000;
  const d = new Date(ts);
  return {
    year: d.getUTCFullYear(),
    month: d.getUTCMonth() + 1,
    day: d.getUTCDate(),
    hour: d.getUTCHours(),
    minute: d.getUTCMinutes(),
    second: d.getUTCSeconds(),
    millisecond: d.getUTCMilliseconds()
  };
} // convert a calendar object to a epoch timestamp


function objToTS(obj, offset, zone) {
  return fixOffset(objToLocalTS(obj), offset, zone);
} // create a new DT instance by adding a duration, adjusting for DSTs


function adjustTime(inst, dur) {
  const keys = Object.keys(dur.values);

  if (keys.indexOf("milliseconds") === -1) {
    keys.push("milliseconds");
  }

  dur = dur.shiftTo(...keys);
  const oPre = inst.o,
        year = inst.c.year + dur.years,
        month = inst.c.month + dur.months + dur.quarters * 3,
        c = Object.assign({}, inst.c, {
    year,
    month,
    day: Math.min(inst.c.day, daysInMonth(year, month)) + dur.days + dur.weeks * 7
  }),
        millisToAdd = Duration.fromObject({
    hours: dur.hours,
    minutes: dur.minutes,
    seconds: dur.seconds,
    milliseconds: dur.milliseconds
  }).as("milliseconds"),
        localTS = objToLocalTS(c);
  let [ts, o] = fixOffset(localTS, oPre, inst.zone);

  if (millisToAdd !== 0) {
    ts += millisToAdd; // that could have changed the offset by going over a DST, but we want to keep the ts the same

    o = inst.zone.offset(ts);
  }

  return {
    ts,
    o
  };
} // helper useful in turning the results of parsing into real dates
// by handling the zone options


function parseDataToDateTime(parsed, parsedZone, opts, format, text) {
  const {
    setZone,
    zone
  } = opts;

  if (parsed && Object.keys(parsed).length !== 0) {
    const interpretationZone = parsedZone || zone,
          inst = DateTime.fromObject(Object.assign(parsed, opts, {
      zone: interpretationZone,
      // setZone is a valid option in the calling methods, but not in fromObject
      setZone: undefined
    }));
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(new Invalid("unparsable", `the input "${text}" can't be parsed as ${format}`));
  }
} // if you want to output a technical format (e.g. RFC 2822), this helper
// helps handle the details


function toTechFormat(dt, format) {
  return dt.isValid ? Formatter.create(Locale.create("en-US"), {
    allowZ: true,
    forceSimple: true
  }).formatDateTimeFromString(dt, format) : null;
} // technical time formats (e.g. the time part of ISO 8601), take some options
// and this commonizes their handling


function toTechTimeFormat(dt, {
  suppressSeconds = false,
  suppressMilliseconds = false,
  includeOffset,
  includeZone = false,
  spaceZone = false
}) {
  let fmt = "HH:mm";

  if (!suppressSeconds || dt.second !== 0 || dt.millisecond !== 0) {
    fmt += ":ss";

    if (!suppressMilliseconds || dt.millisecond !== 0) {
      fmt += ".SSS";
    }
  }

  if ((includeZone || includeOffset) && spaceZone) {
    fmt += " ";
  }

  if (includeZone) {
    fmt += "z";
  } else if (includeOffset) {
    fmt += "ZZ";
  }

  return toTechFormat(dt, fmt);
} // defaults for unspecified units in the supported calendars


const defaultUnitValues = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
},
      defaultWeekUnitValues = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
},
      defaultOrdinalUnitValues = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}; // Units in the supported calendars, sorted by bigness

const orderedUnits$1 = ["year", "month", "day", "hour", "minute", "second", "millisecond"],
      orderedWeekUnits = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"],
      orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"]; // standardize case and plurality in units

function normalizeUnit(unit) {
  const normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[unit.toLowerCase()];
  if (!normalized) throw new InvalidUnitError(unit);
  return normalized;
} // this is a dumbed down version of fromObject() that runs about 60% faster
// but doesn't do any validation, makes a bunch of assumptions about what units
// are present, and so on.


function quickDT(obj, zone) {
  // assume we have the higher-order units
  for (const u of orderedUnits$1) {
    if (isUndefined(obj[u])) {
      obj[u] = defaultUnitValues[u];
    }
  }

  const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);

  if (invalid) {
    return DateTime.invalid(invalid);
  }

  const tsNow = Settings.now(),
        offsetProvis = zone.offset(tsNow),
        [ts, o] = objToTS(obj, offsetProvis, zone);
  return new DateTime({
    ts,
    zone,
    o
  });
}

function diffRelative(start, end, opts) {
  const round = isUndefined(opts.round) ? true : opts.round,
        format = (c, unit) => {
    c = roundTo(c, round || opts.calendary ? 0 : 2, true);
    const formatter = end.loc.clone(opts).relFormatter(opts);
    return formatter.format(c, unit);
  },
        differ = unit => {
    if (opts.calendary) {
      if (!end.hasSame(start, unit)) {
        return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
      } else return 0;
    } else {
      return end.diff(start, unit).get(unit);
    }
  };

  if (opts.unit) {
    return format(differ(opts.unit), opts.unit);
  }

  for (const unit of opts.units) {
    const count = differ(unit);

    if (Math.abs(count) >= 1) {
      return format(count, unit);
    }
  }

  return format(0, opts.units[opts.units.length - 1]);
}
/**
 * A DateTime is an immutable data structure representing a specific date and time and accompanying methods. It contains class and instance methods for creating, parsing, interrogating, transforming, and formatting them.
 *
 * A DateTime comprises of:
 * * A timestamp. Each DateTime instance refers to a specific millisecond of the Unix epoch.
 * * A time zone. Each instance is considered in the context of a specific zone (by default the local system's zone).
 * * Configuration properties that effect how output strings are formatted, such as `locale`, `numberingSystem`, and `outputCalendar`.
 *
 * Here is a brief overview of the most commonly used functionality it provides:
 *
 * * **Creation**: To create a DateTime from its components, use one of its factory class methods: {@link local}, {@link utc}, and (most flexibly) {@link fromObject}. To create one from a standard string format, use {@link fromISO}, {@link fromHTTP}, and {@link fromRFC2822}. To create one from a custom string format, use {@link fromFormat}. To create one from a native JS date, use {@link fromJSDate}.
 * * **Gregorian calendar and time**: To examine the Gregorian properties of a DateTime individually (i.e as opposed to collectively through {@link toObject}), use the {@link year}, {@link month},
 * {@link day}, {@link hour}, {@link minute}, {@link second}, {@link millisecond} accessors.
 * * **Week calendar**: For ISO week calendar attributes, see the {@link weekYear}, {@link weekNumber}, and {@link weekday} accessors.
 * * **Configuration** See the {@link locale} and {@link numberingSystem} accessors.
 * * **Transformation**: To transform the DateTime into other DateTimes, use {@link set}, {@link reconfigure}, {@link setZone}, {@link setLocale}, {@link plus}, {@link minus}, {@link endOf}, {@link startOf}, {@link toUTC}, and {@link toLocal}.
 * * **Output**: To convert the DateTime to other representations, use the {@link toRelative}, {@link toRelativeCalendar}, {@link toJSON}, {@link toISO}, {@link toHTTP}, {@link toObject}, {@link toRFC2822}, {@link toString}, {@link toLocaleString}, {@link toFormat}, {@link toMillis} and {@link toJSDate}.
 *
 * There's plenty others documented below. In addition, for more information on subtler topics like internationalization, time zones, alternative calendars, validity, and so on, see the external documentation.
 */


class DateTime {
  /**
   * @access private
   */
  constructor(config) {
    const zone = config.zone || Settings.defaultZone;
    let invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
    /**
     * @access private
     */

    this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
    let c = null,
        o = null;

    if (!invalid) {
      const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);

      if (unchanged) {
        [c, o] = [config.old.c, config.old.o];
      } else {
        c = tsToObj(this.ts, zone.offset(this.ts));
        invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
        c = invalid ? null : c;
        o = invalid ? null : zone.offset(this.ts);
      }
    }
    /**
     * @access private
     */


    this._zone = zone;
    /**
     * @access private
     */

    this.loc = config.loc || Locale.create();
    /**
     * @access private
     */

    this.invalid = invalid;
    /**
     * @access private
     */

    this.weekData = null;
    /**
     * @access private
     */

    this.c = c;
    /**
     * @access private
     */

    this.o = o;
    /**
     * @access private
     */

    this.isLuxonDateTime = true;
  } // CONSTRUCT

  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, i.e. a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, i.e. a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, i.e. a number between 0 and 999
   * @example DateTime.local()                            //~> now
   * @example DateTime.local(2017)                        //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                     //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12)                 //~> 2017-03-12T00:00:00
   * @example DateTime.local(2017, 3, 12, 5)              //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, 45)          //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)      //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765) //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */


  static local(year, month, day, hour, minute, second, millisecond) {
    if (isUndefined(year)) {
      return new DateTime({
        ts: Settings.now()
      });
    } else {
      return quickDT({
        year,
        month,
        day,
        hour,
        minute,
        second,
        millisecond
      }, Settings.defaultZone);
    }
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, i.e. a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, i.e. a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, i.e. a number between 0 and 999
   * @example DateTime.utc()                            //~> now
   * @example DateTime.utc(2017)                        //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                     //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                 //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)              //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)          //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)      //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765) //~> 2017-03-12T05:45:10.765Z
   * @return {DateTime}
   */


  static utc(year, month, day, hour, minute, second, millisecond) {
    if (isUndefined(year)) {
      return new DateTime({
        ts: Settings.now(),
        zone: FixedOffsetZone.utcInstance
      });
    } else {
      return quickDT({
        year,
        month,
        day,
        hour,
        minute,
        second,
        millisecond
      }, FixedOffsetZone.utcInstance);
    }
  }
  /**
   * Create a DateTime from a Javascript Date object. Uses the default zone.
   * @param {Date} date - a Javascript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */


  static fromJSDate(date, options = {}) {
    const ts = isDate(date) ? date.valueOf() : NaN;

    if (Number.isNaN(ts)) {
      return DateTime.invalid("invalid input");
    }

    const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);

    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }

    return new DateTime({
      ts: ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options)
    });
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (i.e. since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */


  static fromMillis(milliseconds, options = {}) {
    if (!isNumber(milliseconds)) {
      throw new InvalidArgumentError("fromMillis requires a numerical input");
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      // this isn't perfect because because we can still end up out of range because of additional shifting, but it's a start
      return DateTime.invalid("Timestamp out of range");
    } else {
      return new DateTime({
        ts: milliseconds,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (i.e. since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */


  static fromSeconds(seconds, options = {}) {
    if (!isNumber(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new DateTime({
        ts: seconds * 1000,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a Javascript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {string|Zone} [obj.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [obj.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} obj.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} obj.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6, zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6, zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6, zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @return {DateTime}
   */


  static fromObject(obj) {
    const zoneToUse = normalizeZone(obj.zone, Settings.defaultZone);

    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }

    const tsNow = Settings.now(),
          offsetProvis = zoneToUse.offset(tsNow),
          normalized = normalizeObject(obj, normalizeUnit, ["zone", "locale", "outputCalendar", "numberingSystem"]),
          containsOrdinal = !isUndefined(normalized.ordinal),
          containsGregorYear = !isUndefined(normalized.year),
          containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day),
          containsGregor = containsGregorYear || containsGregorMD,
          definiteWeekDef = normalized.weekYear || normalized.weekNumber,
          loc = Locale.fromObject(obj); // cases:
    // just a weekday -> this week's instance of that weekday, no worries
    // (gregorian data or ordinal) + (weekYear or weekNumber) -> error
    // (gregorian month or day) + ordinal -> error
    // otherwise just use weeks or ordinals or gregorian, depending on what's specified

    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
    }

    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }

    const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor; // configure ourselves to deal with gregorian dates or week stuff

    let units,
        defaultValues,
        objNow = tsToObj(tsNow, offsetProvis);

    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits$1;
      defaultValues = defaultUnitValues;
    } // set default values for missing stuff


    let foundFirst = false;

    for (const u of units) {
      const v = normalized[u];

      if (!isUndefined(v)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u] = defaultValues[u];
      } else {
        normalized[u] = objNow[u];
      }
    } // make sure the values we have are in range


    const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized),
          invalid = higherOrderInvalid || hasInvalidTimeData(normalized);

    if (invalid) {
      return DateTime.invalid(invalid);
    } // compute the actual time


    const gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized,
          [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse),
          inst = new DateTime({
      ts: tsFinal,
      zone: zoneToUse,
      o: offsetFinal,
      loc
    }); // gregorian data + weekday serves only to validate

    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return DateTime.invalid("mismatched weekday", `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`);
    }

    return inst;
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */


  static fromISO(text, opts = {}) {
    const [vals, parsedZone] = parseISODate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */


  static fromRFC2822(text, opts = {}) {
    const [vals, parsedZone] = parseRFC2822Date(text);
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */


  static fromHTTP(text, opts = {}) {
    const [vals, parsedZone] = parseHTTPDate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @see https://moment.github.io/luxon/docs/manual/parsing.html#table-of-tokens
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */


  static fromFormat(text, fmt, opts = {}) {
    if (isUndefined(text) || isUndefined(fmt)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }

    const {
      locale = null,
      numberingSystem = null
    } = opts,
          localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    }),
          [vals, parsedZone, invalid] = parseFromTokens(localeToUse, text, fmt);

    if (invalid) {
      return DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text);
    }
  }
  /**
   * @deprecated use fromFormat instead
   */


  static fromString(text, fmt, opts = {}) {
    return DateTime.fromFormat(text, fmt, opts);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */


  static fromSQL(text, opts = {}) {
    const [vals, parsedZone] = parseSQL(text);
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
  }
  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */


  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }

    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);

    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid);
    } else {
      return new DateTime({
        invalid
      });
    }
  }
  /**
   * Check if an object is a DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */


  static isDateTime(o) {
    return o && o.isLuxonDateTime || false;
  } // INFO

  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */


  get(unit) {
    return this[unit];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */


  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */


  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */


  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */


  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */


  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */


  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */


  get zone() {
    return this._zone;
  }
  /**
   * Get the name of the time zone.
   * @type {string}
   */


  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */


  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */


  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */


  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */


  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */


  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */


  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */


  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */


  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekYear //=> 2015
   * @type {number}
   */


  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }
  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */


  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }
  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */


  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }
  /**
   * Get the ordinal (i.e. the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */


  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }
  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */


  get monthShort() {
    return this.isValid ? Info.months("short", {
      locale: this.locale
    })[this.month - 1] : null;
  }
  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */


  get monthLong() {
    return this.isValid ? Info.months("long", {
      locale: this.locale
    })[this.month - 1] : null;
  }
  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */


  get weekdayShort() {
    return this.isValid ? Info.weekdays("short", {
      locale: this.locale
    })[this.weekday - 1] : null;
  }
  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */


  get weekdayLong() {
    return this.isValid ? Info.weekdays("long", {
      locale: this.locale
    })[this.weekday - 1] : null;
  }
  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.local().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */


  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */


  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */


  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */


  get isOffsetFixed() {
    return this.isValid ? this.zone.universal : null;
  }
  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */


  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return this.offset > this.set({
        month: 1
      }).offset || this.offset > this.set({
        month: 5
      }).offset;
    }
  }
  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */


  get isInLeapYear() {
    return isLeapYear(this.year);
  }
  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */


  get daysInMonth() {
    return daysInMonth(this.year, this.month);
  }
  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */


  get daysInYear() {
    return this.isValid ? daysInYear(this.year) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */


  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }
  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */


  resolvedLocaleOpts(opts = {}) {
    const {
      locale,
      numberingSystem,
      calendar
    } = Formatter.create(this.loc.clone(opts), opts).resolvedOptions(this);
    return {
      locale,
      numberingSystem,
      outputCalendar: calendar
    };
  } // TRANSFORM

  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */


  toUTC(offset = 0, opts = {}) {
    return this.setZone(FixedOffsetZone.instance(offset), opts);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */


  toLocal() {
    return this.setZone(Settings.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link plus}. You may wish to use {@link toLocal} and {@link toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */


  setZone(zone, {
    keepLocalTime = false,
    keepCalendarTime = false
  } = {}) {
    zone = normalizeZone(zone, Settings.defaultZone);

    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return DateTime.invalid(unsupportedZone(zone));
    } else {
      let newTS = this.ts;

      if (keepLocalTime || keepCalendarTime) {
        const offsetGuess = this.o - zone.offset(this.ts);
        const asObj = this.toObject();
        [newTS] = objToTS(asObj, offsetGuess, zone);
      }

      return clone$1(this, {
        ts: newTS,
        zone
      });
    }
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */


  reconfigure({
    locale,
    numberingSystem,
    outputCalendar
  } = {}) {
    const loc = this.loc.clone({
      locale,
      numberingSystem,
      outputCalendar
    });
    return clone$1(this, {
      loc
    });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */


  setLocale(locale) {
    return this.reconfigure({
      locale
    });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link reconfigure} and {@link setZone}.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */


  set(values) {
    if (!this.isValid) return this;
    const normalized = normalizeObject(values, normalizeUnit, []),
          settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday);
    let mixed;

    if (settingWeekStuff) {
      mixed = weekToGregorian(Object.assign(gregorianToWeek(this.c), normalized));
    } else if (!isUndefined(normalized.ordinal)) {
      mixed = ordinalToGregorian(Object.assign(gregorianToOrdinal(this.c), normalized));
    } else {
      mixed = Object.assign(this.toObject(), normalized); // if we didn't set the day but we ended up on an overflow date,
      // use the last day of the right month

      if (isUndefined(normalized.day)) {
        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
      }
    }

    const [ts, o] = objToTS(mixed, this.o, this.zone);
    return clone$1(this, {
      ts,
      o
    });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.local().plus(123) //~> in 123 milliseconds
   * @example DateTime.local().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.local().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.local().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.local().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.local().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */


  plus(duration) {
    if (!this.isValid) return this;
    const dur = friendlyDuration(duration);
    return clone$1(this, adjustTime(this, dur));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
  */


  minus(duration) {
    if (!this.isValid) return this;
    const dur = friendlyDuration(duration).negate();
    return clone$1(this, adjustTime(this, dur));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */


  startOf(unit) {
    if (!this.isValid) return this;
    const o = {},
          normalizedUnit = Duration.normalizeUnit(unit);

    switch (normalizedUnit) {
      case "years":
        o.month = 1;
      // falls through

      case "quarters":
      case "months":
        o.day = 1;
      // falls through

      case "weeks":
      case "days":
        o.hour = 0;
      // falls through

      case "hours":
        o.minute = 0;
      // falls through

      case "minutes":
        o.second = 0;
      // falls through

      case "seconds":
        o.millisecond = 0;
        break;

      case "milliseconds":
        break;
      // no default, invalid units throw in normalizeUnit()
    }

    if (normalizedUnit === "weeks") {
      o.weekday = 1;
    }

    if (normalizedUnit === "quarters") {
      const q = Math.ceil(this.month / 3);
      o.month = (q - 1) * 3 + 1;
    }

    return this.set(o);
  }
  /**
   * "Set" this DateTime to the end (i.e. the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'month', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */


  endOf(unit) {
    return this.isValid ? this.plus({
      [unit]: 1
    }).startOf(unit).minus(1) : this;
  } // OUTPUT

  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/docs/manual/formatting.html#table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @see https://moment.github.io/luxon/docs/manual/formatting.html#table-of-tokens
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options
   * @example DateTime.local().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.local().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.local().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.local().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */


  toFormat(fmt, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID$2;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param opts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @example DateTime.local().toLocaleString(); //=> 4/20/2017
   * @example DateTime.local().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.local().toLocaleString({ locale: 'en-gb' }); //=> '20/04/2017'
   * @example DateTime.local().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.local().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.local().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.local().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.local().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.local().toLocaleString({ hour: '2-digit', minute: '2-digit', hour12: false }); //=> '11:32'
   * @return {string}
   */


  toLocaleString(opts = DATE_SHORT) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTime(this) : INVALID$2;
  }
  /**
   * Returns an array of format "parts", i.e. individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.local().toLocaleString(); //=> [
   *                                    //=>   { type: 'day', value: '25' },
   *                                    //=>   { type: 'literal', value: '/' },
   *                                    //=>   { type: 'month', value: '05' },
   *                                    //=>   { type: 'literal', value: '/' },
   *                                    //=>   { type: 'year', value: '1982' }
   *                                    //=> ]
   */


  toLocaleParts(opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @example DateTime.utc(1982, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.local().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.local().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @return {string}
   */


  toISO(opts = {}) {
    if (!this.isValid) {
      return null;
    }

    return `${this.toISODate()}T${this.toISOTime(opts)}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @return {string}
   */


  toISODate() {
    let format = "yyyy-MM-dd";

    if (this.year > 9999) {
      format = "+" + format;
    }

    return toTechFormat(this, format);
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */


  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @example DateTime.utc().hour(7).minute(34).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().hour(7).minute(34).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @return {string}
   */


  toISOTime({
    suppressMilliseconds = false,
    suppressSeconds = false,
    includeOffset = true
  } = {}) {
    return toTechTimeFormat(this, {
      suppressSeconds,
      suppressMilliseconds,
      includeOffset
    });
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime, always in UTC
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */


  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */


  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */


  toSQLDate() {
    return toTechFormat(this, "yyyy-MM-dd");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.local().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.local().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.local().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */


  toSQLTime({
    includeOffset = true,
    includeZone = false
  } = {}) {
    return toTechTimeFormat(this, {
      includeOffset,
      includeZone,
      spaceZone: true
    });
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */


  toSQL(opts = {}) {
    if (!this.isValid) {
      return null;
    }

    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */


  toString() {
    return this.isValid ? this.toISO() : INVALID$2;
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link toMillis}
   * @return {number}
   */


  valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */


  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */


  toSeconds() {
    return this.isValid ? this.ts / 1000 : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */


  toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */


  toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a Javascript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.local().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */


  toObject(opts = {}) {
    if (!this.isValid) return {};
    const base = Object.assign({}, this.c);

    if (opts.includeConfig) {
      base.outputCalendar = this.outputCalendar;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }

    return base;
  }
  /**
   * Returns a Javascript Date equivalent to this DateTime.
   * @return {Date}
   */


  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  } // COMPARE

  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */


  diff(otherDateTime, unit = "milliseconds", opts = {}) {
    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid(this.invalid || otherDateTime.invalid, "created by diffing an invalid DateTime");
    }

    const durOpts = Object.assign({
      locale: this.locale,
      numberingSystem: this.numberingSystem
    }, opts);
    const units = maybeArray(unit).map(Duration.normalizeUnit),
          otherIsLater = otherDateTime.valueOf() > this.valueOf(),
          earlier = otherIsLater ? this : otherDateTime,
          later = otherIsLater ? otherDateTime : this,
          diffed = diff(earlier, later, units, durOpts);
    return otherIsLater ? diffed.negate() : diffed;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */


  diffNow(unit = "milliseconds", opts = {}) {
    return this.diff(DateTime.local(), unit, opts);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */


  until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @example DateTime.local().hasSame(otherDT, 'day'); //~> true if both the same calendar day
   * @return {boolean}
   */


  hasSame(otherDateTime, unit) {
    if (!this.isValid) return false;

    if (unit === "millisecond") {
      return this.valueOf() === otherDateTime.valueOf();
    } else {
      const inputMs = otherDateTime.valueOf();
      return this.startOf(unit) <= inputMs && inputMs <= this.endOf(unit);
    }
  }
  /**
   * Equality check
   * Two DateTimes are equal iff they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */


  equals(other) {
    return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.local()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {boolean} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.local().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.local().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 da"
   * @example DateTime.local().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.local().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.local().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.local().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */


  toRelative(options = {}) {
    if (!this.isValid) return null;
    const base = options.base || DateTime.fromObject({
      zone: this.zone
    }),
          padding = options.padding ? this < base ? -options.padding : options.padding : 0;
    return diffRelative(base, this.plus(padding), Object.assign(options, {
      numeric: "always",
      units: ["years", "months", "days", "hours", "minutes", "seconds"]
    }));
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.local()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.local().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.local().setLocale("es").plus({ days: 1 }).toRelative() //=> ""maana"
   * @example DateTime.local().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.local().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */


  toRelativeCalendar(options = {}) {
    if (!this.isValid) return null;
    return diffRelative(options.base || DateTime.fromObject({
      zone: this.zone
    }), this, Object.assign(options, {
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true
    }));
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */


  static min(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }

    return bestBy(dateTimes, i => i.valueOf(), Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */


  static max(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }

    return bestBy(dateTimes, i => i.valueOf(), Math.max);
  } // MISC

  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */


  static fromFormatExplain(text, fmt, options = {}) {
    const {
      locale = null,
      numberingSystem = null
    } = options,
          localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    return explainFromTokens(localeToUse, text, fmt);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */


  static fromStringExplain(text, fmt, options = {}) {
    return DateTime.fromFormatExplain(text, fmt, options);
  } // FORMAT PRESETS

  /**
   * {@link toLocaleString} format like 10/14/1983
   * @type {Object}
   */


  static get DATE_SHORT() {
    return DATE_SHORT;
  }
  /**
   * {@link toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */


  static get DATE_MED() {
    return DATE_MED;
  }
  /**
   * {@link toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */


  static get DATE_FULL() {
    return DATE_FULL;
  }
  /**
   * {@link toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */


  static get DATE_HUGE() {
    return DATE_HUGE;
  }
  /**
   * {@link toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */


  static get TIME_SIMPLE() {
    return TIME_SIMPLE;
  }
  /**
   * {@link toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */


  static get TIME_WITH_SECONDS() {
    return TIME_WITH_SECONDS;
  }
  /**
   * {@link toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */


  static get TIME_WITH_SHORT_OFFSET() {
    return TIME_WITH_SHORT_OFFSET;
  }
  /**
   * {@link toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */


  static get TIME_WITH_LONG_OFFSET() {
    return TIME_WITH_LONG_OFFSET;
  }
  /**
   * {@link toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */


  static get TIME_24_SIMPLE() {
    return TIME_24_SIMPLE;
  }
  /**
   * {@link toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */


  static get TIME_24_WITH_SECONDS() {
    return TIME_24_WITH_SECONDS;
  }
  /**
   * {@link toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */


  static get TIME_24_WITH_SHORT_OFFSET() {
    return TIME_24_WITH_SHORT_OFFSET;
  }
  /**
   * {@link toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */


  static get TIME_24_WITH_LONG_OFFSET() {
    return TIME_24_WITH_LONG_OFFSET;
  }
  /**
   * {@link toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */


  static get DATETIME_SHORT() {
    return DATETIME_SHORT;
  }
  /**
   * {@link toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */


  static get DATETIME_SHORT_WITH_SECONDS() {
    return DATETIME_SHORT_WITH_SECONDS;
  }
  /**
   * {@link toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */


  static get DATETIME_MED() {
    return DATETIME_MED;
  }
  /**
   * {@link toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */


  static get DATETIME_MED_WITH_SECONDS() {
    return DATETIME_MED_WITH_SECONDS;
  }
  /**
   * {@link toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */


  static get DATETIME_MED_WITH_WEEKDAY() {
    return DATETIME_MED_WITH_WEEKDAY;
  }
  /**
   * {@link toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */


  static get DATETIME_FULL() {
    return DATETIME_FULL;
  }
  /**
   * {@link toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */


  static get DATETIME_FULL_WITH_SECONDS() {
    return DATETIME_FULL_WITH_SECONDS;
  }
  /**
   * {@link toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */


  static get DATETIME_HUGE() {
    return DATETIME_HUGE;
  }
  /**
   * {@link toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */


  static get DATETIME_HUGE_WITH_SECONDS() {
    return DATETIME_HUGE_WITH_SECONDS;
  }

}
/**
 * @private
 */

function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError(`Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`);
  }
}

exports.DateTime = DateTime;
exports.Duration = Duration;
exports.FixedOffsetZone = FixedOffsetZone;
exports.IANAZone = IANAZone;
exports.Info = Info;
exports.Interval = Interval;
exports.InvalidZone = InvalidZone;
exports.LocalZone = LocalZone;
exports.Settings = Settings;
exports.Zone = Zone;
//# sourceMappingURL=luxon.js.map


/***/ }),

/***/ "./node_modules/path-parser/dist/cjs/path-parser.js":
/*!**********************************************************!*\
  !*** ./node_modules/path-parser/dist/cjs/path-parser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

var searchParams = __webpack_require__(/*! search-params */ "./node_modules/search-params/dist/cjs/index.js");

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
};

var defaultOrConstrained = function (match) {
    return '(' +
        (match ? match.replace(/(^<|>$)/g, '') : "[a-zA-Z0-9-_.~%':|=+\\*@]+") +
        ')';
};
var rules = [
    {
        name: 'url-parameter',
        pattern: /^:([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})(<(.+?)>)?/,
        regex: function (match) {
            return new RegExp(defaultOrConstrained(match[2]));
        }
    },
    {
        name: 'url-parameter-splat',
        pattern: /^\*([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})/,
        regex: /([^?]*)/
    },
    {
        name: 'url-parameter-matrix',
        pattern: /^;([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})(<(.+?)>)?/,
        regex: function (match) {
            return new RegExp(';' + match[1] + '=' + defaultOrConstrained(match[2]));
        }
    },
    {
        name: 'query-parameter',
        pattern: /^(?:\?|&)(?::)?([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})/
    },
    {
        name: 'delimiter',
        pattern: /^(\/|\?)/,
        regex: function (match) { return new RegExp('\\' + match[0]); }
    },
    {
        name: 'sub-delimiter',
        pattern: /^(!|&|-|_|\.|;)/,
        regex: function (match) { return new RegExp(match[0]); }
    },
    {
        name: 'fragment',
        pattern: /^([0-9a-zA-Z]+)/,
        regex: function (match) { return new RegExp(match[0]); }
    }
];

var tokenise = function (str, tokens) {
    if (tokens === void 0) { tokens = []; }
    // Look for a matching rule
    var matched = rules.some(function (rule) {
        var match = str.match(rule.pattern);
        if (!match) {
            return false;
        }
        tokens.push({
            type: rule.name,
            match: match[0],
            val: match.slice(1, 2),
            otherVal: match.slice(2),
            regex: rule.regex instanceof Function ? rule.regex(match) : rule.regex
        });
        if (match[0].length < str.length) {
            tokens = tokenise(str.substr(match[0].length), tokens);
        }
        return true;
    });
    // If no rules matched, throw an error (possible malformed path)
    if (!matched) {
        throw new Error("Could not parse path '" + str + "'");
    }
    return tokens;
};

var identity = function (_) { return _; };
var exists = function (val) { return val !== undefined && val !== null; };
var optTrailingSlash = function (source, strictTrailingSlash) {
    if (strictTrailingSlash) {
        return source;
    }
    if (source === '\\/') {
        return source;
    }
    return source.replace(/\\\/$/, '') + '(?:\\/)?';
};
var upToDelimiter = function (source, delimiter) {
    if (!delimiter) {
        return source;
    }
    return /(\/)$/.test(source) ? source : source + '(\\/|\\?|\\.|;|$)';
};
var appendQueryParam = function (params, param, val) {
    if (val === void 0) { val = ''; }
    var existingVal = params[param];
    if (existingVal === undefined) {
        params[param] = val;
    }
    else {
        params[param] = Array.isArray(existingVal)
            ? existingVal.concat(val)
            : [existingVal, val];
    }
    return params;
};
var Path = /** @class */ (function () {
    function Path(path) {
        if (!path) {
            throw new Error('Missing path in Path constructor');
        }
        this.path = path;
        this.tokens = tokenise(path);
        this.hasUrlParams =
            this.tokens.filter(function (t) { return /^url-parameter/.test(t.type); }).length > 0;
        this.hasSpatParam =
            this.tokens.filter(function (t) { return /splat$/.test(t.type); }).length > 0;
        this.hasMatrixParams =
            this.tokens.filter(function (t) { return /matrix$/.test(t.type); }).length > 0;
        this.hasQueryParams =
            this.tokens.filter(function (t) { return /^query-parameter/.test(t.type); }).length > 0;
        // Extract named parameters from tokens
        this.spatParams = this.getParams('url-parameter-splat');
        this.urlParams = this.getParams(/^url-parameter/);
        // Query params
        this.queryParams = this.getParams('query-parameter');
        // All params
        this.params = this.urlParams.concat(this.queryParams);
        // Check if hasQueryParams
        // Regular expressions for url part only (full and partial match)
        this.source = this.tokens
            .filter(function (t) { return t.regex !== undefined; })
            .map(function (r) { return r.regex.source; })
            .join('');
    }
    Path.createPath = function (path) {
        return new Path(path);
    };
    Path.prototype.isQueryParam = function (name) {
        return this.queryParams.indexOf(name) !== -1;
    };
    Path.prototype.test = function (path, opts) {
        var _this = this;
        var options = __assign({ strictTrailingSlash: false, queryParams: {} }, opts);
        // trailingSlash: falsy => non optional, truthy => optional
        var source = optTrailingSlash(this.source, options.strictTrailingSlash);
        // Check if exact match
        var match = this.urlTest(path, source + (this.hasQueryParams ? '(\\?.*$|$)' : '$'), opts);
        // If no match, or no query params, no need to go further
        if (!match || !this.hasQueryParams) {
            return match;
        }
        // Extract query params
        var queryParams = searchParams.parse(path, options.queryParams);
        var unexpectedQueryParams = Object.keys(queryParams).filter(function (p) { return !_this.isQueryParam(p); });
        if (unexpectedQueryParams.length === 0) {
            // Extend url match
            Object.keys(queryParams).forEach(function (p) { return (match[p] = queryParams[p]); });
            return match;
        }
        return null;
    };
    Path.prototype.partialTest = function (path, opts) {
        var _this = this;
        var options = __assign({ delimited: true, queryParams: {} }, opts);
        // Check if partial match (start of given path matches regex)
        // trailingSlash: falsy => non optional, truthy => optional
        var source = upToDelimiter(this.source, options.delimited);
        var match = this.urlTest(path, source, options);
        if (!match) {
            return match;
        }
        if (!this.hasQueryParams) {
            return match;
        }
        var queryParams = searchParams.parse(path, options.queryParams);
        Object.keys(queryParams)
            .filter(function (p) { return _this.isQueryParam(p); })
            .forEach(function (p) { return appendQueryParam(match, p, queryParams[p]); });
        return match;
    };
    Path.prototype.build = function (params, opts) {
        var _this = this;
        if (params === void 0) { params = {}; }
        var options = __assign({ ignoreConstraints: false, ignoreSearch: false, queryParams: {} }, opts);
        var encodedUrlParams = Object.keys(params)
            .filter(function (p) { return !_this.isQueryParam(p); })
            .reduce(function (acc, key) {
            if (!exists(params[key])) {
                return acc;
            }
            var val = params[key];
            var encode = _this.isQueryParam(key) ? identity : encodeURI;
            if (typeof val === 'boolean') {
                acc[key] = val;
            }
            else if (Array.isArray(val)) {
                acc[key] = val.map(encode);
            }
            else {
                acc[key] = encode(val);
            }
            return acc;
        }, {});
        // Check all params are provided (not search parameters which are optional)
        if (this.urlParams.some(function (p) { return !exists(params[p]); })) {
            var missingParameters = this.urlParams.filter(function (p) { return !exists(params[p]); });
            throw new Error("Cannot build path: '" +
                this.path +
                "' requires missing parameters { " +
                missingParameters.join(', ') +
                ' }');
        }
        // Check constraints
        if (!options.ignoreConstraints) {
            var constraintsPassed = this.tokens
                .filter(function (t) {
                return /^url-parameter/.test(t.type) && !/-splat$/.test(t.type);
            })
                .every(function (t) {
                return new RegExp('^' + defaultOrConstrained(t.otherVal[0]) + '$').test(encodedUrlParams[t.val]);
            });
            if (!constraintsPassed) {
                throw new Error("Some parameters of '" + this.path + "' are of invalid format");
            }
        }
        var base = this.tokens
            .filter(function (t) { return /^query-parameter/.test(t.type) === false; })
            .map(function (t) {
            if (t.type === 'url-parameter-matrix') {
                return ";" + t.val + "=" + encodedUrlParams[t.val[0]];
            }
            return /^url-parameter/.test(t.type)
                ? encodedUrlParams[t.val[0]]
                : t.match;
        })
            .join('');
        if (options.ignoreSearch) {
            return base;
        }
        var searchParams$$1 = this.queryParams
            .filter(function (p) { return Object.keys(params).indexOf(p) !== -1; })
            .reduce(function (sparams, paramName) {
            sparams[paramName] = params[paramName];
            return sparams;
        }, {});
        var searchPart = searchParams.build(searchParams$$1, options.queryParams);
        return searchPart ? base + '?' + searchPart : base;
    };
    Path.prototype.getParams = function (type) {
        var predicate = type instanceof RegExp
            ? function (t) { return type.test(t.type); }
            : function (t) { return t.type === type; };
        return this.tokens.filter(predicate).map(function (t) { return t.val[0]; });
    };
    Path.prototype.urlTest = function (path, source, _a) {
        var _this = this;
        var _b = (_a === void 0 ? {} : _a).caseSensitive, caseSensitive = _b === void 0 ? false : _b;
        var regex = new RegExp('^' + source, caseSensitive ? '' : 'i');
        var match = path.match(regex);
        if (!match) {
            return null;
        }
        else if (!this.urlParams.length) {
            return {};
        }
        // Reduce named params to key-value pairs
        return match
            .slice(1, this.urlParams.length + 1)
            .reduce(function (params, m, i) {
            params[_this.urlParams[i]] = decodeURIComponent(m);
            return params;
        }, {});
    };
    return Path;
}());

exports.Path = Path;
exports.default = Path;


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/redux/lib/redux.js":
/*!*****************************************!*\
  !*** ./node_modules/redux/lib/redux.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var $$observable = _interopDefault(__webpack_require__(/*! symbol-observable */ "./node_modules/symbol-observable/lib/index.js"));

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var randomString = function randomString() {
  return Math.random().toString(36).substring(7).split('').join('.');
};

var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};

/**
 * @param {any} obj The object to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 */
function isPlainObject(obj) {
  if (typeof obj !== 'object' || obj === null) return false;
  var proto = obj;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(obj) === proto;
}

/**
 * Creates a Redux store that holds the state tree.
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [preloadedState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} [enhancer] The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */

function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
    throw new Error('It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function.');
  }

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  /**
   * This makes a shallow copy of currentListeners so we can use
   * nextListeners as a temporary list while dispatching.
   *
   * This prevents any bugs around consumers calling
   * subscribe/unsubscribe in the middle of a dispatch.
   */

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */


  function getState() {
    if (isDispatching) {
      throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');
    }

    return currentState;
  }
  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */


  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected the listener to be a function.');
    }

    if (isDispatching) {
      throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');
    }

    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      if (isDispatching) {
        throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');
      }

      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
    };
  }
  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing what changed. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */


  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;

    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }
  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */


  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.');
    }

    currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.
    // Any reducers that existed in both the new and old rootReducer
    // will receive the previous state. This effectively populates
    // the new state tree with any relevant data from the old one.

    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */


  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object' || observer === null) {
          throw new TypeError('Expected the observer to be an object.');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe: unsubscribe
        };
      }
    }, _ref[$$observable] = function () {
      return this;
    }, _ref;
  } // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.


  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}

/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */


  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
  } catch (e) {} // eslint-disable-line no-empty

}

function getUndefinedStateErrorMessage(key, action) {
  var actionType = action && action.type;
  var actionDescription = actionType && "action \"" + String(actionType) + "\"" || 'an action';
  return "Given " + actionDescription + ", reducer \"" + key + "\" returned undefined. " + "To ignore an action, you must explicitly return the previous state. " + "If you want this reducer to hold no value, you can return null instead of undefined.";
}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!isPlainObject(inputState)) {
    return "The " + argumentName + " has unexpected type of \"" + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + "\". Expected argument to be an object with the following " + ("keys: \"" + reducerKeys.join('", "') + "\"");
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });
  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });
  if (action && action.type === ActionTypes.REPLACE) return;

  if (unexpectedKeys.length > 0) {
    return "Unexpected " + (unexpectedKeys.length > 1 ? 'keys' : 'key') + " " + ("\"" + unexpectedKeys.join('", "') + "\" found in " + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ("\"" + reducerKeys.join('", "') + "\". Unexpected keys will be ignored.");
  }
}

function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, {
      type: ActionTypes.INIT
    });

    if (typeof initialState === 'undefined') {
      throw new Error("Reducer \"" + key + "\" returned undefined during initialization. " + "If the state passed to the reducer is undefined, you must " + "explicitly return the initial state. The initial state may " + "not be undefined. If you don't want to set a value for this reducer, " + "you can use null instead of undefined.");
    }

    if (typeof reducer(undefined, {
      type: ActionTypes.PROBE_UNKNOWN_ACTION()
    }) === 'undefined') {
      throw new Error("Reducer \"" + key + "\" returned undefined when probed with a random type. " + ("Don't try to handle " + ActionTypes.INIT + " or other actions in \"redux/*\" ") + "namespace. They are considered private. Instead, you must return the " + "current state for any unknown actions, unless it is undefined, " + "in which case you must return the initial state, regardless of the " + "action type. The initial state may not be undefined, but can be null.");
    }
  });
}
/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */


function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};

  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if (true) {
      if (typeof reducers[key] === 'undefined') {
        warning("No reducer provided for key \"" + key + "\"");
      }
    }

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }

  var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same
  // keys multiple times.

  var unexpectedKeyCache;

  if (true) {
    unexpectedKeyCache = {};
  }

  var shapeAssertionError;

  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }

  return function combination(state, action) {
    if (state === void 0) {
      state = {};
    }

    if (shapeAssertionError) {
      throw shapeAssertionError;
    }

    if (true) {
      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);

      if (warningMessage) {
        warning(warningMessage);
      }
    }

    var hasChanged = false;
    var nextState = {};

    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);

      if (typeof nextStateForKey === 'undefined') {
        var errorMessage = getUndefinedStateErrorMessage(_key, action);
        throw new Error(errorMessage);
      }

      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }

    return hasChanged ? nextState : state;
  };
}

function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(this, arguments));
  };
}
/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass an action creator as the first argument,
 * and get a dispatch wrapped function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */


function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error("bindActionCreators expected an object or a function, instead received " + (actionCreators === null ? 'null' : typeof actionCreators) + ". " + "Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?");
  }

  var boundActionCreators = {};

  for (var key in actionCreators) {
    var actionCreator = actionCreators[key];

    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }

  return boundActionCreators;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    keys.push.apply(keys, Object.getOwnPropertySymbols(object));
  }

  if (enumerableOnly) keys = keys.filter(function (sym) {
    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
  });
  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */
function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(function (a, b) {
    return function () {
      return a(b.apply(void 0, arguments));
    };
  });
}

/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */

function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function () {
      var store = createStore.apply(void 0, arguments);

      var _dispatch = function dispatch() {
        throw new Error('Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.');
      };

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose.apply(void 0, chain)(store.dispatch);
      return _objectSpread2({}, store, {
        dispatch: _dispatch
      });
    };
  };
}

/*
 * This is a dummy function to check if the function name has been altered by minification.
 * If the function has been minified and NODE_ENV !== 'production', warn the user.
 */

function isCrushed() {}

if ( true && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
  warning('You are currently using minified code outside of NODE_ENV === "production". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');
}

exports.__DO_NOT_USE__ActionTypes = ActionTypes;
exports.applyMiddleware = applyMiddleware;
exports.bindActionCreators = bindActionCreators;
exports.combineReducers = combineReducers;
exports.compose = compose;
exports.createStore = createStore;


/***/ }),

/***/ "./node_modules/reflect-metadata/Reflect.js":
/*!**************************************************!*\
  !*** ./node_modules/reflect-metadata/Reflect.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, global) {/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
    // Metadata Proposal
    // https://rbuckton.github.io/reflect-metadata/
    (function (factory) {
        var root = typeof global === "object" ? global :
            typeof self === "object" ? self :
                typeof this === "object" ? this :
                    Function("return this;")();
        var exporter = makeExporter(Reflect);
        if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect;
        }
        else {
            exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter);
        function makeExporter(target, previous) {
            return function (key, value) {
                if (typeof target[key] !== "function") {
                    Object.defineProperty(target, key, { configurable: true, writable: true, value: value });
                }
                if (previous)
                    previous(key, value);
            };
        }
    })(function (exporter) {
        var hasOwn = Object.prototype.hasOwnProperty;
        // feature test for Symbol support
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate
                ? function () { return MakeDictionary(Object.create(null)); }
                : supportsProto
                    ? function () { return MakeDictionary({ __proto__: null }); }
                    : function () { return MakeDictionary({}); },
            has: downLevel
                ? function (map, key) { return hasOwn.call(map, key); }
                : function (map, key) { return key in map; },
            get: downLevel
                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
                : function (map, key) { return map[key]; },
        };
        // Load global or shim versions of Map, Set, and WeakMap
        var functionPrototype = Object.getPrototypeOf(Function);
        var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
        var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        // [[Metadata]] internal slot
        // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
        var Metadata = new _WeakMap();
        /**
         * Applies a set of decorators to a property of a target object.
         * @param decorators An array of decorators.
         * @param target The target object.
         * @param propertyKey (Optional) The property key to decorate.
         * @param attributes (Optional) The property descriptor for the target key.
         * @remarks Decorators are applied in reverse order.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Example = Reflect.decorate(decoratorsArray, Example);
         *
         *     // property (on constructor)
         *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Object.defineProperty(Example, "staticMethod",
         *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
         *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
         *
         *     // method (on prototype)
         *     Object.defineProperty(Example.prototype, "method",
         *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
         *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
         *
         */
        function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                    throw new TypeError();
                if (IsNull(attributes))
                    attributes = undefined;
                propertyKey = ToPropertyKey(propertyKey);
                return DecorateProperty(decorators, target, propertyKey, attributes);
            }
            else {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsConstructor(target))
                    throw new TypeError();
                return DecorateConstructor(decorators, target);
            }
        }
        exporter("decorate", decorate);
        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
        /**
         * A default metadata decorator factory that can be used on a class, class member, or parameter.
         * @param metadataKey The key for the metadata entry.
         * @param metadataValue The value for the metadata entry.
         * @returns A decorator function.
         * @remarks
         * If `metadataKey` is already defined for the target and target key, the
         * metadataValue for that key will be overwritten.
         * @example
         *
         *     // constructor
         *     @Reflect.metadata(key, value)
         *     class Example {
         *     }
         *
         *     // property (on constructor, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticProperty;
         *     }
         *
         *     // property (on prototype, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         property;
         *     }
         *
         *     // method (on constructor)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticMethod() { }
         *     }
         *
         *     // method (on prototype)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         method() { }
         *     }
         *
         */
        function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                    throw new TypeError();
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
        }
        exporter("metadata", metadata);
        /**
         * Define a unique metadata entry on the target.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param metadataValue A value that contains attached metadata.
         * @param target The target object on which to define metadata.
         * @param propertyKey (Optional) The property key for the target.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Reflect.defineMetadata("custom:annotation", options, Example);
         *
         *     // property (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
         *
         *     // method (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
         *
         *     // decorator factory as metadata-producing annotation.
         *     function MyAnnotation(options): Decorator {
         *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
         *     }
         *
         */
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        /**
         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        /**
         * Gets a value indicating whether the target object has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        /**
         * Gets the metadata keys defined on the target object or its prototype chain.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "method");
         *
         */
        function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        /**
         * Gets the unique metadata keys defined on the target object.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
         *
         */
        function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        /**
         * Deletes the metadata entry from the target object with the provided key.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata entry was found and deleted; otherwise, false.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.deleteMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            if (!metadataMap.delete(metadataKey))
                return false;
            if (metadataMap.size > 0)
                return true;
            var targetMetadata = Metadata.get(target);
            targetMetadata.delete(propertyKey);
            if (targetMetadata.size > 0)
                return true;
            Metadata.delete(target);
            return true;
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsConstructor(decorated))
                        throw new TypeError();
                    target = decorated;
                }
            }
            return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target, propertyKey, descriptor);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsObject(decorated))
                        throw new TypeError();
                    descriptor = decorated;
                }
            }
            return descriptor;
        }
        function GetOrCreateMetadataMap(O, P, Create) {
            var targetMetadata = Metadata.get(O);
            if (IsUndefined(targetMetadata)) {
                if (!Create)
                    return undefined;
                targetMetadata = new _Map();
                Metadata.set(O, targetMetadata);
            }
            var metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
                if (!Create)
                    return undefined;
                metadataMap = new _Map();
                targetMetadata.set(P, metadataMap);
            }
            return metadataMap;
        }
        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
        function OrdinaryHasMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return true;
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryHasMetadata(MetadataKey, parent, P);
            return false;
        }
        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            return ToBoolean(metadataMap.has(MetadataKey));
        }
        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
        function OrdinaryGetMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryGetMetadata(MetadataKey, parent, P);
            return undefined;
        }
        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return undefined;
            return metadataMap.get(MetadataKey);
        }
        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
            metadataMap.set(MetadataKey, MetadataValue);
        }
        // 3.1.6.1 OrdinaryMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
        function OrdinaryMetadataKeys(O, P) {
            var ownKeys = OrdinaryOwnMetadataKeys(O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (parent === null)
                return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P);
            if (parentKeys.length <= 0)
                return ownKeys;
            if (ownKeys.length <= 0)
                return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
                var key = ownKeys_1[_i];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
                var key = parentKeys_1[_a];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            return keys;
        }
        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
        function OrdinaryOwnMetadataKeys(O, P) {
            var keys = [];
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return keys;
            var keysObj = metadataMap.keys();
            var iterator = GetIterator(keysObj);
            var k = 0;
            while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                    keys.length = k;
                    return keys;
                }
                var nextValue = IteratorValue(next);
                try {
                    keys[k] = nextValue;
                }
                catch (e) {
                    try {
                        IteratorClose(iterator);
                    }
                    finally {
                        throw e;
                    }
                }
                k++;
            }
        }
        // 6 ECMAScript Data Typ0es and Values
        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
        function Type(x) {
            if (x === null)
                return 1 /* Null */;
            switch (typeof x) {
                case "undefined": return 0 /* Undefined */;
                case "boolean": return 2 /* Boolean */;
                case "string": return 3 /* String */;
                case "symbol": return 4 /* Symbol */;
                case "number": return 5 /* Number */;
                case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
                default: return 6 /* Object */;
            }
        }
        // 6.1.1 The Undefined Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
        function IsUndefined(x) {
            return x === undefined;
        }
        // 6.1.2 The Null Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
        function IsNull(x) {
            return x === null;
        }
        // 6.1.5 The Symbol Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
        function IsSymbol(x) {
            return typeof x === "symbol";
        }
        // 6.1.7 The Object Type
        // https://tc39.github.io/ecma262/#sec-object-type
        function IsObject(x) {
            return typeof x === "object" ? x !== null : typeof x === "function";
        }
        // 7.1 Type Conversion
        // https://tc39.github.io/ecma262/#sec-type-conversion
        // 7.1.1 ToPrimitive(input [, PreferredType])
        // https://tc39.github.io/ecma262/#sec-toprimitive
        function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
                case 0 /* Undefined */: return input;
                case 1 /* Null */: return input;
                case 2 /* Boolean */: return input;
                case 3 /* String */: return input;
                case 4 /* Symbol */: return input;
                case 5 /* Number */: return input;
            }
            var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== undefined) {
                var result = exoticToPrim.call(input, hint);
                if (IsObject(result))
                    throw new TypeError();
                return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        // 7.1.1.1 OrdinaryToPrimitive(O, hint)
        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
        function OrdinaryToPrimitive(O, hint) {
            if (hint === "string") {
                var toString_1 = O.toString;
                if (IsCallable(toString_1)) {
                    var result = toString_1.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            else {
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var toString_2 = O.toString;
                if (IsCallable(toString_2)) {
                    var result = toString_2.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            throw new TypeError();
        }
        // 7.1.2 ToBoolean(argument)
        // https://tc39.github.io/ecma262/2016/#sec-toboolean
        function ToBoolean(argument) {
            return !!argument;
        }
        // 7.1.12 ToString(argument)
        // https://tc39.github.io/ecma262/#sec-tostring
        function ToString(argument) {
            return "" + argument;
        }
        // 7.1.14 ToPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-topropertykey
        function ToPropertyKey(argument) {
            var key = ToPrimitive(argument, 3 /* String */);
            if (IsSymbol(key))
                return key;
            return ToString(key);
        }
        // 7.2 Testing and Comparison Operations
        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
        // 7.2.2 IsArray(argument)
        // https://tc39.github.io/ecma262/#sec-isarray
        function IsArray(argument) {
            return Array.isArray
                ? Array.isArray(argument)
                : argument instanceof Object
                    ? argument instanceof Array
                    : Object.prototype.toString.call(argument) === "[object Array]";
        }
        // 7.2.3 IsCallable(argument)
        // https://tc39.github.io/ecma262/#sec-iscallable
        function IsCallable(argument) {
            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
            return typeof argument === "function";
        }
        // 7.2.4 IsConstructor(argument)
        // https://tc39.github.io/ecma262/#sec-isconstructor
        function IsConstructor(argument) {
            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
            return typeof argument === "function";
        }
        // 7.2.7 IsPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-ispropertykey
        function IsPropertyKey(argument) {
            switch (Type(argument)) {
                case 3 /* String */: return true;
                case 4 /* Symbol */: return true;
                default: return false;
            }
        }
        // 7.3 Operations on Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-objects
        // 7.3.9 GetMethod(V, P)
        // https://tc39.github.io/ecma262/#sec-getmethod
        function GetMethod(V, P) {
            var func = V[P];
            if (func === undefined || func === null)
                return undefined;
            if (!IsCallable(func))
                throw new TypeError();
            return func;
        }
        // 7.4 Operations on Iterator Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
        function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
                throw new TypeError(); // from Call
            var iterator = method.call(obj);
            if (!IsObject(iterator))
                throw new TypeError();
            return iterator;
        }
        // 7.4.4 IteratorValue(iterResult)
        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
        function IteratorValue(iterResult) {
            return iterResult.value;
        }
        // 7.4.5 IteratorStep(iterator)
        // https://tc39.github.io/ecma262/#sec-iteratorstep
        function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
        }
        // 7.4.6 IteratorClose(iterator, completion)
        // https://tc39.github.io/ecma262/#sec-iteratorclose
        function IteratorClose(iterator) {
            var f = iterator["return"];
            if (f)
                f.call(iterator);
        }
        // 9.1 Ordinary Object Internal Methods and Internal Slots
        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
        // 9.1.1.1 OrdinaryGetPrototypeOf(O)
        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
        function OrdinaryGetPrototypeOf(O) {
            var proto = Object.getPrototypeOf(O);
            if (typeof O !== "function" || O === functionPrototype)
                return proto;
            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
            // Try to determine the superclass constructor. Compatible implementations
            // must either set __proto__ on a subclass constructor to the superclass constructor,
            // or ensure each class has a valid `constructor` property on its prototype that
            // points back to the constructor.
            // If this is not the same as Function.[[Prototype]], then this is definately inherited.
            // This is the case when in ES6 or when using __proto__ in a compatible browser.
            if (proto !== functionPrototype)
                return proto;
            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
            var prototype = O.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
                return proto;
            // If the constructor was not a function, then we cannot determine the heritage.
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
                return proto;
            // If we have some kind of self-reference, then we cannot determine the heritage.
            if (constructor === O)
                return proto;
            // we have a pretty good guess at the heritage.
            return constructor;
        }
        // naive Map shim
        function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = /** @class */ (function () {
                function MapIterator(keys, values, selector) {
                    this._index = 0;
                    this._keys = keys;
                    this._values = values;
                    this._selector = selector;
                }
                MapIterator.prototype["@@iterator"] = function () { return this; };
                MapIterator.prototype[iteratorSymbol] = function () { return this; };
                MapIterator.prototype.next = function () {
                    var index = this._index;
                    if (index >= 0 && index < this._keys.length) {
                        var result = this._selector(this._keys[index], this._values[index]);
                        if (index + 1 >= this._keys.length) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        }
                        else {
                            this._index++;
                        }
                        return { value: result, done: false };
                    }
                    return { value: undefined, done: true };
                };
                MapIterator.prototype.throw = function (error) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    throw error;
                };
                MapIterator.prototype.return = function (value) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    return { value: value, done: true };
                };
                return MapIterator;
            }());
            return /** @class */ (function () {
                function Map() {
                    this._keys = [];
                    this._values = [];
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                }
                Object.defineProperty(Map.prototype, "size", {
                    get: function () { return this._keys.length; },
                    enumerable: true,
                    configurable: true
                });
                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
                Map.prototype.get = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    return index >= 0 ? this._values[index] : undefined;
                };
                Map.prototype.set = function (key, value) {
                    var index = this._find(key, /*insert*/ true);
                    this._values[index] = value;
                    return this;
                };
                Map.prototype.delete = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    if (index >= 0) {
                        var size = this._keys.length;
                        for (var i = index + 1; i < size; i++) {
                            this._keys[i - 1] = this._keys[i];
                            this._values[i - 1] = this._values[i];
                        }
                        this._keys.length--;
                        this._values.length--;
                        if (key === this._cacheKey) {
                            this._cacheKey = cacheSentinel;
                            this._cacheIndex = -2;
                        }
                        return true;
                    }
                    return false;
                };
                Map.prototype.clear = function () {
                    this._keys.length = 0;
                    this._values.length = 0;
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                };
                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
                Map.prototype["@@iterator"] = function () { return this.entries(); };
                Map.prototype[iteratorSymbol] = function () { return this.entries(); };
                Map.prototype._find = function (key, insert) {
                    if (this._cacheKey !== key) {
                        this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                    }
                    if (this._cacheIndex < 0 && insert) {
                        this._cacheIndex = this._keys.length;
                        this._keys.push(key);
                        this._values.push(undefined);
                    }
                    return this._cacheIndex;
                };
                return Map;
            }());
            function getKey(key, _) {
                return key;
            }
            function getValue(_, value) {
                return value;
            }
            function getEntry(key, value) {
                return [key, value];
            }
        }
        // naive Set shim
        function CreateSetPolyfill() {
            return /** @class */ (function () {
                function Set() {
                    this._map = new _Map();
                }
                Object.defineProperty(Set.prototype, "size", {
                    get: function () { return this._map.size; },
                    enumerable: true,
                    configurable: true
                });
                Set.prototype.has = function (value) { return this._map.has(value); };
                Set.prototype.add = function (value) { return this._map.set(value, value), this; };
                Set.prototype.delete = function (value) { return this._map.delete(value); };
                Set.prototype.clear = function () { this._map.clear(); };
                Set.prototype.keys = function () { return this._map.keys(); };
                Set.prototype.values = function () { return this._map.values(); };
                Set.prototype.entries = function () { return this._map.entries(); };
                Set.prototype["@@iterator"] = function () { return this.keys(); };
                Set.prototype[iteratorSymbol] = function () { return this.keys(); };
                return Set;
            }());
        }
        // naive WeakMap shim
        function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return /** @class */ (function () {
                function WeakMap() {
                    this._key = CreateUniqueKey();
                }
                WeakMap.prototype.has = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.has(table, this._key) : false;
                };
                WeakMap.prototype.get = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.get(table, this._key) : undefined;
                };
                WeakMap.prototype.set = function (target, value) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                    table[this._key] = value;
                    return this;
                };
                WeakMap.prototype.delete = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? delete table[this._key] : false;
                };
                WeakMap.prototype.clear = function () {
                    // NOTE: not a real clear, just makes the previous data unreachable
                    this._key = CreateUniqueKey();
                };
                return WeakMap;
            }());
            function CreateUniqueKey() {
                var key;
                do
                    key = "@@WeakMap@@" + CreateUUID();
                while (HashMap.has(keys, key));
                keys[key] = true;
                return key;
            }
            function GetOrCreateWeakMapTable(target, create) {
                if (!hasOwn.call(target, rootKey)) {
                    if (!create)
                        return undefined;
                    Object.defineProperty(target, rootKey, { value: HashMap.create() });
                }
                return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
                for (var i = 0; i < size; ++i)
                    buffer[i] = Math.random() * 0xff | 0;
                return buffer;
            }
            function GenRandomBytes(size) {
                if (typeof Uint8Array === "function") {
                    if (typeof crypto !== "undefined")
                        return crypto.getRandomValues(new Uint8Array(size));
                    if (typeof msCrypto !== "undefined")
                        return msCrypto.getRandomValues(new Uint8Array(size));
                    return FillRandomBytes(new Uint8Array(size), size);
                }
                return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
                var data = GenRandomBytes(UUID_SIZE);
                // mark as random - RFC 4122  4.4
                data[6] = data[6] & 0x4f | 0x40;
                data[8] = data[8] & 0xbf | 0x80;
                var result = "";
                for (var offset = 0; offset < UUID_SIZE; ++offset) {
                    var byte = data[offset];
                    if (offset === 4 || offset === 6 || offset === 8)
                        result += "-";
                    if (byte < 16)
                        result += "0";
                    result += byte.toString(16).toLowerCase();
                }
                return result;
            }
        }
        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
        function MakeDictionary(obj) {
            obj.__ = undefined;
            delete obj.__;
            return obj;
        }
    });
})(Reflect || (Reflect = {}));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/route-node/dist/cjs/route-node.js":
/*!********************************************************!*\
  !*** ./node_modules/route-node/dist/cjs/route-node.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var searchParams = __webpack_require__(/*! search-params */ "./node_modules/search-params/dist/cjs/index.js");
var pathParser = __webpack_require__(/*! path-parser */ "./node_modules/path-parser/dist/cjs/path-parser.js");

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
};

var getMetaFromSegments = function (segments) {
    var accName = '';
    return segments.reduce(function (meta, segment) {
        var urlParams = segment.parser.urlParams.reduce(function (params, p) {
            params[p] = 'url';
            return params;
        }, {});
        var allParams = segment.parser.queryParams.reduce(function (params, p) {
            params[p] = 'query';
            return params;
        }, urlParams);
        if (segment.name !== undefined) {
            accName = accName ? accName + '.' + segment.name : segment.name;
            meta[accName] = allParams;
        }
        return meta;
    }, {});
};
var buildStateFromMatch = function (match) {
    if (!match || !match.segments || !match.segments.length) {
        return null;
    }
    var name = match.segments
        .map(function (segment) { return segment.name; })
        .filter(function (name) { return name; })
        .join('.');
    var params = match.params;
    return {
        name: name,
        params: params,
        meta: getMetaFromSegments(match.segments)
    };
};
var buildPathFromSegments = function (segments, params, options) {
    if (params === void 0) { params = {}; }
    if (options === void 0) { options = {}; }
    if (!segments) {
        return null;
    }
    var _a = options.queryParamsMode, queryParamsMode = _a === void 0 ? 'default' : _a, _b = options.trailingSlashMode;
    var searchParams$$1 = [];
    var nonSearchParams = [];
    for (var _i = 0, segments_1 = segments; _i < segments_1.length; _i++) {
        var segment = segments_1[_i];
        var parser = segment.parser;
        searchParams$$1.push.apply(searchParams$$1, parser.queryParams);
        nonSearchParams.push.apply(nonSearchParams, parser.urlParams);
        nonSearchParams.push.apply(nonSearchParams, parser.spatParams);
    }
    if (queryParamsMode === 'loose') {
        var extraParams = Object.keys(params).reduce(function (acc, p) {
            return searchParams$$1.indexOf(p) === -1 &&
                nonSearchParams.indexOf(p) === -1
                ? acc.concat(p)
                : acc;
        }, []);
        searchParams$$1.push.apply(searchParams$$1, extraParams);
    }
    var searchParamsObject = searchParams$$1.reduce(function (acc, paramName) {
        if (Object.keys(params).indexOf(paramName) !== -1) {
            acc[paramName] = params[paramName];
        }
        return acc;
    }, {});
    var searchPart = searchParams.build(searchParamsObject, options.queryParams);
    var path = segments
        .reduce(function (path, segment) {
        var segmentPath = segment.parser.build(params, {
            ignoreSearch: true,
            queryParams: options.queryParams
        });
        return segment.absolute ? segmentPath : path + segmentPath;
    }, '')
        .replace(/\/\/{1,}/g, '/');
    var finalPath = path;
    if (options.trailingSlashMode === 'always') {
        finalPath = /\/$/.test(path) ? path : path + "/";
    }
    else if (options.trailingSlashMode === 'never' && path !== '/') {
        finalPath = /\/$/.test(path) ? path.slice(0, -1) : path;
    }
    return finalPath + (searchPart ? '?' + searchPart : '');
};
var getPathFromSegments = function (segments) {
    return segments ? segments.map(function (segment) { return segment.path; }).join('') : null;
};

var getPath = function (path) { return path.split('?')[0]; };
var getSearch = function (path) { return path.split('?')[1] || ''; };
var matchChildren = function (nodes, pathSegment, currentMatch, options, consumedBefore) {
    if (options === void 0) { options = {}; }
    var _a = options.queryParamsMode, queryParamsMode = _a === void 0 ? 'default' : _a, _b = options.strictTrailingSlash, strictTrailingSlash = _b === void 0 ? false : _b, _c = options.strongMatching, strongMatching = _c === void 0 ? true : _c, _d = options.caseSensitive, caseSensitive = _d === void 0 ? false : _d;
    var isRoot = nodes.length === 1 && nodes[0].name === '';
    var _loop_1 = function (child) {
        // Partially match path
        var match;
        var remainingPath = void 0;
        var segment = pathSegment;
        if (consumedBefore === '/' && child.path === '/') {
            // when we encounter repeating slashes we add the slash
            // back to the URL to make it de facto pathless
            segment = '/' + pathSegment;
        }
        if (!child.children.length) {
            match = child.parser.test(segment, {
                caseSensitive: caseSensitive,
                strictTrailingSlash: strictTrailingSlash,
                queryParams: options.queryParams
            });
        }
        if (!match) {
            match = child.parser.partialTest(segment, {
                delimited: strongMatching,
                caseSensitive: caseSensitive,
                queryParams: options.queryParams
            });
        }
        if (match) {
            // Remove consumed segment from path
            var consumedPath = child.parser.build(match, {
                ignoreSearch: true
            });
            if (!strictTrailingSlash && !child.children.length) {
                consumedPath = consumedPath.replace(/\/$/, '');
            }
            // Can't create a regexp from the path because it might contain a
            // regexp character.
            if (segment.toLowerCase().indexOf(consumedPath.toLowerCase()) === 0) {
                remainingPath = segment.slice(consumedPath.length);
            }
            else {
                remainingPath = segment;
            }
            if (!strictTrailingSlash && !child.children.length) {
                remainingPath = remainingPath.replace(/^\/\?/, '?');
            }
            var querystring = searchParams.omit(getSearch(segment.replace(consumedPath, '')), child.parser.queryParams, options.queryParams).querystring;
            remainingPath =
                getPath(remainingPath) + (querystring ? "?" + querystring : '');
            if (!strictTrailingSlash &&
                !isRoot &&
                remainingPath === '/' &&
                !/\/$/.test(consumedPath)) {
                remainingPath = '';
            }
            currentMatch.segments.push(child);
            Object.keys(match).forEach(function (param) { return (currentMatch.params[param] = match[param]); });
            if (!isRoot && !remainingPath.length) {
                return { value: currentMatch };
            }
            if (!isRoot &&
                queryParamsMode !== 'strict' &&
                remainingPath.indexOf('?') === 0) {
                // unmatched queryParams in non strict mode
                var remainingQueryParams_1 = searchParams.parse(remainingPath.slice(1), options.queryParams);
                Object.keys(remainingQueryParams_1).forEach(function (name) {
                    return (currentMatch.params[name] = remainingQueryParams_1[name]);
                });
                return { value: currentMatch };
            }
            // Continue matching on non absolute children
            var children = child.getNonAbsoluteChildren();
            // If no children to match against but unmatched path left
            if (!children.length) {
                return { value: null };
            }
            return { value: matchChildren(children, remainingPath, currentMatch, options, consumedPath) };
        }
    };
    // for (child of node.children) {
    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
        var child = nodes_1[_i];
        var state_1 = _loop_1(child);
        if (typeof state_1 === "object")
            return state_1.value;
    }
    return null;
};

function sortChildren(children) {
    var originalChildren = children.slice(0);
    return children.sort(sortPredicate(originalChildren));
}
var sortPredicate = function (originalChildren) { return function (left, right) {
    var leftPath = left.path
        .replace(/<.*?>/g, '')
        .split('?')[0]
        .replace(/(.+)\/$/, '$1');
    var rightPath = right.path
        .replace(/<.*?>/g, '')
        .split('?')[0]
        .replace(/(.+)\/$/, '$1');
    // '/' last
    if (leftPath === '/') {
        return 1;
    }
    if (rightPath === '/') {
        return -1;
    }
    // Spat params last
    if (left.parser.hasSpatParam) {
        return 1;
    }
    if (right.parser.hasSpatParam) {
        return -1;
    }
    // No spat, number of segments (less segments last)
    var leftSegments = (leftPath.match(/\//g) || []).length;
    var rightSegments = (rightPath.match(/\//g) || []).length;
    if (leftSegments < rightSegments) {
        return 1;
    }
    if (leftSegments > rightSegments) {
        return -1;
    }
    // Same number of segments, number of URL params ascending
    var leftParamsCount = left.parser.urlParams.length;
    var rightParamsCount = right.parser.urlParams.length;
    if (leftParamsCount < rightParamsCount) {
        return -1;
    }
    if (leftParamsCount > rightParamsCount) {
        return 1;
    }
    // Same number of segments and params, last segment length descending
    var leftParamLength = (leftPath.split('/').slice(-1)[0] || '').length;
    var rightParamLength = (rightPath.split('/').slice(-1)[0] || '').length;
    if (leftParamLength < rightParamLength) {
        return 1;
    }
    if (leftParamLength > rightParamLength) {
        return -1;
    }
    // Same last segment length, preserve definition order. Note that we
    // cannot just return 0, as sort is not guaranteed to be a stable sort.
    return originalChildren.indexOf(left) - originalChildren.indexOf(right);
}; };

var defaultBuildOptions = {
    queryParamsMode: 'default',
    trailingSlashMode: 'default'
};
var defaultMatchOptions = __assign({}, defaultBuildOptions, { strongMatching: true });
var RouteNode = /** @class */ (function () {
    function RouteNode(name, path, childRoutes, cb, parent, finalSort, sort) {
        if (name === void 0) { name = ''; }
        if (path === void 0) { path = ''; }
        if (childRoutes === void 0) { childRoutes = []; }
        if (finalSort === void 0) { finalSort = true; }
        this.name = name;
        this.absolute = /^~/.test(path);
        this.path = this.absolute ? path.slice(1) : path;
        this.parser = this.path ? new pathParser.Path(this.path) : null;
        this.children = [];
        this.parent = parent;
        this.checkParents();
        this.add(childRoutes, cb, finalSort ? false : sort !== false);
        if (finalSort) {
            this.sortDescendants();
        }
        return this;
    }
    RouteNode.prototype.getParentSegments = function (segments) {
        if (segments === void 0) { segments = []; }
        return this.parent && this.parent.parser
            ? this.parent.getParentSegments(segments.concat(this.parent))
            : segments.reverse();
    };
    RouteNode.prototype.setParent = function (parent) {
        this.parent = parent;
        this.checkParents();
    };
    RouteNode.prototype.setPath = function (path) {
        if (path === void 0) { path = ''; }
        this.path = path;
        this.parser = path ? new pathParser.Path(path) : null;
    };
    RouteNode.prototype.add = function (route, cb, sort) {
        var _this = this;
        if (sort === void 0) { sort = true; }
        if (route === undefined || route === null) {
            return;
        }
        if (route instanceof Array) {
            route.forEach(function (r) { return _this.add(r, cb, sort); });
            return;
        }
        if (!(route instanceof RouteNode) && !(route instanceof Object)) {
            throw new Error('RouteNode.add() expects routes to be an Object or an instance of RouteNode.');
        }
        else if (route instanceof RouteNode) {
            route.setParent(this);
            this.addRouteNode(route, sort);
        }
        else {
            if (!route.name || !route.path) {
                throw new Error('RouteNode.add() expects routes to have a name and a path defined.');
            }
            var routeNode = new RouteNode(route.name, route.path, route.children, cb, this, false, sort);
            var fullName = routeNode
                .getParentSegments([routeNode])
                .map(function (_) { return _.name; })
                .join('.');
            if (cb) {
                cb(__assign({}, route, { name: fullName }));
            }
            this.addRouteNode(routeNode, sort);
        }
        return this;
    };
    RouteNode.prototype.addNode = function (name, path) {
        this.add(new RouteNode(name, path));
        return this;
    };
    RouteNode.prototype.getPath = function (routeName) {
        return getPathFromSegments(this.getSegmentsByName(routeName));
    };
    RouteNode.prototype.getNonAbsoluteChildren = function () {
        return this.children.filter(function (child) { return !child.absolute; });
    };
    RouteNode.prototype.sortChildren = function () {
        if (this.children.length) {
            sortChildren(this.children);
        }
    };
    RouteNode.prototype.sortDescendants = function () {
        this.sortChildren();
        this.children.forEach(function (child) { return child.sortDescendants(); });
    };
    RouteNode.prototype.buildPath = function (routeName, params, options) {
        if (params === void 0) { params = {}; }
        if (options === void 0) { options = {}; }
        var path = buildPathFromSegments(this.getSegmentsByName(routeName), params, options);
        return path;
    };
    RouteNode.prototype.buildState = function (name, params) {
        if (params === void 0) { params = {}; }
        var segments = this.getSegmentsByName(name);
        if (!segments || !segments.length) {
            return null;
        }
        return {
            name: name,
            params: params,
            meta: getMetaFromSegments(segments)
        };
    };
    RouteNode.prototype.matchPath = function (path, options) {
        if (options === void 0) { options = {}; }
        if (path === '' && !options.strictTrailingSlash) {
            path = '/';
        }
        var match = this.getSegmentsMatchingPath(path, options);
        if (match) {
            var matchedSegments = match.segments;
            if (matchedSegments[0].absolute) {
                var firstSegmentParams = matchedSegments[0].getParentSegments();
                matchedSegments.reverse();
                matchedSegments.push.apply(matchedSegments, firstSegmentParams);
                matchedSegments.reverse();
            }
            var lastSegment = matchedSegments[matchedSegments.length - 1];
            var lastSegmentSlashChild = lastSegment.findSlashChild();
            if (lastSegmentSlashChild) {
                matchedSegments.push(lastSegmentSlashChild);
            }
        }
        return buildStateFromMatch(match);
    };
    RouteNode.prototype.addRouteNode = function (route, sort) {
        if (sort === void 0) { sort = true; }
        var names = route.name.split('.');
        if (names.length === 1) {
            // Check duplicated routes
            if (this.children.map(function (child) { return child.name; }).indexOf(route.name) !==
                -1) {
                throw new Error("Alias \"" + route.name + "\" is already defined in route node");
            }
            // Check duplicated paths
            if (this.children.map(function (child) { return child.path; }).indexOf(route.path) !==
                -1) {
                throw new Error("Path \"" + route.path + "\" is already defined in route node");
            }
            this.children.push(route);
            if (sort) {
                this.sortChildren();
            }
        }
        else {
            // Locate parent node
            var segments = this.getSegmentsByName(names.slice(0, -1).join('.'));
            if (segments) {
                route.name = names[names.length - 1];
                segments[segments.length - 1].add(route);
            }
            else {
                throw new Error("Could not add route named '" + route.name + "', parent is missing.");
            }
        }
        return this;
    };
    RouteNode.prototype.checkParents = function () {
        if (this.absolute && this.hasParentsParams()) {
            throw new Error('[RouteNode] A RouteNode with an abolute path cannot have parents with route parameters');
        }
    };
    RouteNode.prototype.hasParentsParams = function () {
        if (this.parent && this.parent.parser) {
            var parser = this.parent.parser;
            var hasParams = parser.hasUrlParams ||
                parser.hasSpatParam ||
                parser.hasMatrixParams ||
                parser.hasQueryParams;
            return hasParams || this.parent.hasParentsParams();
        }
        return false;
    };
    RouteNode.prototype.findAbsoluteChildren = function () {
        return this.children.reduce(function (absoluteChildren, child) {
            return absoluteChildren
                .concat(child.absolute ? child : [])
                .concat(child.findAbsoluteChildren());
        }, []);
    };
    RouteNode.prototype.findSlashChild = function () {
        var slashChildren = this.getNonAbsoluteChildren().filter(function (child) { return child.parser && /^\/(\?|$)/.test(child.parser.path); });
        return slashChildren[0];
    };
    RouteNode.prototype.getSegmentsByName = function (routeName) {
        var findSegmentByName = function (name, routes) {
            var filteredRoutes = routes.filter(function (r) { return r.name === name; });
            return filteredRoutes.length ? filteredRoutes[0] : undefined;
        };
        var segments = [];
        var routes = this.parser ? [this] : this.children;
        var names = (this.parser ? [''] : []).concat(routeName.split('.'));
        var matched = names.every(function (name) {
            var segment = findSegmentByName(name, routes);
            if (segment) {
                routes = segment.children;
                segments.push(segment);
                return true;
            }
            return false;
        });
        return matched ? segments : null;
    };
    RouteNode.prototype.getSegmentsMatchingPath = function (path, options) {
        var topLevelNodes = this.parser ? [this] : this.children;
        var startingNodes = topLevelNodes.reduce(function (nodes, node) { return nodes.concat(node, node.findAbsoluteChildren()); }, []);
        var currentMatch = {
            segments: [],
            params: {}
        };
        var finalMatch = matchChildren(startingNodes, path, currentMatch, options);
        if (finalMatch &&
            finalMatch.segments.length === 1 &&
            finalMatch.segments[0].name === '') {
            return null;
        }
        return finalMatch;
    };
    return RouteNode;
}());

module.exports = RouteNode;


/***/ }),

/***/ "./node_modules/router5-plugin-browser/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/router5-plugin-browser/dist/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var router5 = __webpack_require__(/*! router5 */ "./node_modules/router5/dist/index.js");

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var value = function (arg) { return function () { return arg; }; };
var noop = function () { };
var isBrowser = typeof window !== 'undefined' && window.history;
var getBase = function () { return window.location.pathname; };
var supportsPopStateOnHashChange = function () {
    return window.navigator.userAgent.indexOf('Trident') === -1;
};
var pushState = function (state, title, path) {
    return window.history.pushState(state, title, path);
};
var replaceState = function (state, title, path) {
    return window.history.replaceState(state, title, path);
};
var addPopstateListener = function (fn, opts) {
    var shouldAddHashChangeListener = opts.useHash && !supportsPopStateOnHashChange();
    window.addEventListener('popstate', fn);
    if (shouldAddHashChangeListener) {
        window.addEventListener('hashchange', fn);
    }
    return function () {
        window.removeEventListener('popstate', fn);
        if (shouldAddHashChangeListener) {
            window.removeEventListener('hashchange', fn);
        }
    };
};
var getLocation = function (opts) {
    var path = opts.useHash
        ? window.location.hash.replace(new RegExp('^#' + opts.hashPrefix), '')
        : window.location.pathname.replace(new RegExp('^' + opts.base), '');
    // Fix issue with browsers that don't URL encode characters (Edge)
    var correctedPath = safelyEncodePath(path);
    return (correctedPath || '/') + window.location.search;
};
var safelyEncodePath = function (path) {
    try {
        return encodeURI(decodeURI(path));
    }
    catch (_) {
        return path;
    }
};
var getState = function () { return window.history.state; };
var getHash = function () { return window.location.hash; };
var browser = {};
if (isBrowser) {
    browser = {
        getBase: getBase,
        pushState: pushState,
        replaceState: replaceState,
        addPopstateListener: addPopstateListener,
        getLocation: getLocation,
        getState: getState,
        getHash: getHash
    };
}
else {
    browser = {
        getBase: value(''),
        pushState: noop,
        replaceState: noop,
        addPopstateListener: noop,
        getLocation: value(''),
        getState: value(null),
        getHash: value('')
    };
}
var safeBrowser = browser;

var defaultOptions = {
    forceDeactivate: true,
    useHash: false,
    hashPrefix: '',
    base: '',
    mergeState: false,
    preserveHash: true
};
var source = 'popstate';
function browserPluginFactory(opts, browser) {
    if (browser === void 0) { browser = safeBrowser; }
    var options = __assign({}, defaultOptions, opts);
    var transitionOptions = {
        forceDeactivate: options.forceDeactivate,
        source: source
    };
    var removePopStateListener;
    return function browserPlugin(router) {
        var routerOptions = router.getOptions();
        var routerStart = router.start;
        router.buildUrl = function (route, params) {
            var base = options.base || '';
            var prefix = options.useHash ? "#" + options.hashPrefix : '';
            var path = router.buildPath(route, params);
            if (path === null)
                return null;
            return base + prefix + path;
        };
        var urlToPath = function (url) {
            var match = url.match(/^(?:http|https):\/\/(?:[0-9a-z_\-.:]+?)(?=\/)(.*)$/);
            var path = match ? match[1] : url;
            var pathParts = path.match(/^(.+?)(#.+?)?(\?.+)?$/);
            if (!pathParts)
                throw new Error("[router5] Could not parse url " + url);
            var pathname = pathParts[1];
            var hash = pathParts[2] || '';
            var search = pathParts[3] || '';
            return ((options.useHash
                ? hash.replace(new RegExp('^#' + options.hashPrefix), '')
                : options.base
                    ? pathname.replace(new RegExp('^' + options.base), '')
                    : pathname) + search);
        };
        router.matchUrl = function (url) { return router.matchPath(urlToPath(url)); };
        router.start = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (args.length === 0 || typeof args[0] === 'function') {
                routerStart.apply(void 0, [browser.getLocation(options)].concat(args));
            }
            else {
                routerStart.apply(void 0, args);
            }
            return router;
        };
        router.replaceHistoryState = function (name, params, title) {
            if (params === void 0) { params = {}; }
            if (title === void 0) { title = ''; }
            var route = router.buildState(name, params);
            var state = router.makeState(route.name, route.params, router.buildPath(route.name, route.params), { params: route.meta });
            var url = router.buildUrl(name, params);
            router.lastKnownState = state;
            browser.replaceState(state, title, url);
        };
        function updateBrowserState(state, url, replace) {
            var trimmedState = state
                ? {
                    meta: state.meta,
                    name: state.name,
                    params: state.params,
                    path: state.path
                }
                : state;
            var finalState = options.mergeState === true
                ? __assign({}, browser.getState(), trimmedState) : trimmedState;
            if (replace)
                browser.replaceState(finalState, '', url);
            else
                browser.pushState(finalState, '', url);
        }
        function onPopState(evt) {
            var routerState = router.getState();
            // Do nothing if no state or if last know state is poped state (it should never happen)
            var newState = !evt.state || !evt.state.name;
            var state = newState
                ? router.matchPath(browser.getLocation(options), source)
                : router.makeState(evt.state.name, evt.state.params, evt.state.path, __assign({}, evt.state.meta, { source: source }), evt.state.meta.id);
            var defaultRoute = routerOptions.defaultRoute, defaultParams = routerOptions.defaultParams;
            if (!state) {
                // If current state is already the default route, we will have a double entry
                // Navigating back and forth will emit SAME_STATES error
                defaultRoute &&
                    router.navigateToDefault(__assign({}, transitionOptions, { reload: true, replace: true }));
                return;
            }
            if (routerState &&
                router.areStatesEqual(state, routerState, false)) {
                return;
            }
            router.transitionToState(state, routerState, transitionOptions, function (err, toState) {
                if (err) {
                    if (err.redirect) {
                        var _a = err.redirect, name_1 = _a.name, params = _a.params;
                        router.navigate(name_1, params, __assign({}, transitionOptions, { replace: true, force: true, redirected: true }));
                    }
                    else if (err.code === router5.errorCodes.CANNOT_DEACTIVATE) {
                        var url = router.buildUrl(routerState.name, routerState.params);
                        if (!newState) {
                            // Keep history state unchanged but use current URL
                            updateBrowserState(state, url, true);
                        }
                        // else do nothing or history will be messed up
                        // TODO: history.back()?
                    }
                    else {
                        // Force navigation to default state
                        defaultRoute &&
                            router.navigate(defaultRoute, defaultParams, __assign({}, transitionOptions, { reload: true, replace: true }));
                    }
                }
                else {
                    router.invokeEventListeners(router5.constants.TRANSITION_SUCCESS, toState, routerState, { replace: true });
                }
            });
        }
        function onStart() {
            if (options.useHash && !options.base) {
                // Guess base
                options.base = browser.getBase();
            }
            removePopStateListener = browser.addPopstateListener(onPopState, options);
        }
        function teardown() {
            if (removePopStateListener) {
                removePopStateListener();
                removePopStateListener = undefined;
            }
        }
        function onTransitionSuccess(toState, fromState, opts) {
            var historyState = browser.getState();
            var hasState = historyState &&
                historyState.meta &&
                historyState.name &&
                historyState.params;
            var statesAreEqual = fromState && router.areStatesEqual(fromState, toState, false);
            var replace = opts.replace || !hasState || statesAreEqual;
            var url = router.buildUrl(toState.name, toState.params);
            if (fromState === null &&
                options.useHash === false &&
                options.preserveHash === true) {
                url += browser.getHash();
            }
            updateBrowserState(toState, url, replace);
        }
        return {
            onStart: onStart,
            onStop: teardown,
            teardown: teardown,
            onTransitionSuccess: onTransitionSuccess,
            onPopState: onPopState
        };
    };
}

module.exports = browserPluginFactory;


/***/ }),

/***/ "./node_modules/router5-transition-path/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/router5-transition-path/dist/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

var nameToIDs = function (name) {
    return name
        .split('.')
        .reduce(function (ids, name) {
        return ids.concat(ids.length ? ids[ids.length - 1] + '.' + name : name);
    }, []);
};
var exists = function (val) { return val !== undefined && val !== null; };
var hasMetaParams = function (state) { return state && state.meta && state.meta.params; };
var extractSegmentParams = function (name, state) {
    if (!hasMetaParams(state) || !exists(state.meta.params[name]))
        return {};
    return Object.keys(state.meta.params[name]).reduce(function (params, p) {
        params[p] = state.params[p];
        return params;
    }, {});
};
function transitionPath(toState, fromState) {
    var toStateOptions = (toState.meta && toState.meta && toState.meta.options) || {};
    var fromStateIds = fromState ? nameToIDs(fromState.name) : [];
    var toStateIds = nameToIDs(toState.name);
    var maxI = Math.min(fromStateIds.length, toStateIds.length);
    function pointOfDifference() {
        var i;
        var _loop_1 = function () {
            var left = fromStateIds[i];
            var right = toStateIds[i];
            if (left !== right)
                return { value: i };
            var leftParams = extractSegmentParams(left, toState);
            var rightParams = extractSegmentParams(right, fromState);
            if (Object.keys(leftParams).length !==
                Object.keys(rightParams).length)
                return { value: i };
            if (Object.keys(leftParams).length === 0)
                return "continue";
            var different = Object.keys(leftParams).some(function (p) { return rightParams[p] !== leftParams[p]; });
            if (different) {
                return { value: i };
            }
        };
        for (i = 0; i < maxI; i += 1) {
            var state_1 = _loop_1();
            if (typeof state_1 === "object")
                return state_1.value;
        }
        return i;
    }
    var i;
    if (!fromState || toStateOptions.reload) {
        i = 0;
    }
    else if (!hasMetaParams(fromState) && !hasMetaParams(toState)) {
        i = 0;
    }
    else {
        i = pointOfDifference();
    }
    var toDeactivate = fromStateIds.slice(i).reverse();
    var toActivate = toStateIds.slice(i);
    var intersection = fromState && i > 0 ? fromStateIds[i - 1] : '';
    return {
        intersection: intersection,
        toDeactivate: toDeactivate,
        toActivate: toActivate
    };
}

function shouldUpdateNode(nodeName) {
    return function (toState, fromSate) {
        var _a = transitionPath(toState, fromSate), intersection = _a.intersection, toActivate = _a.toActivate, toDeactivateReversed = _a.toDeactivate;
        var toDeactivate = toDeactivateReversed.slice().reverse();
        if (toState.meta.options && toState.meta.options.reload) {
            return true;
        }
        if (nodeName === intersection) {
            return true;
        }
        if (toActivate.indexOf(nodeName) === -1) {
            return false;
        }
        var matching = true;
        for (var i = 0; i < toActivate.length; i += 1) {
            var activatedSegment = toActivate[i];
            var sameLevelDeactivatedSegment = toDeactivate[i];
            matching = activatedSegment === sameLevelDeactivatedSegment;
            if (matching && activatedSegment === nodeName) {
                return true;
            }
            if (!matching) {
                return false;
            }
        }
        return false;
    };
}

exports.shouldUpdateNode = shouldUpdateNode;
exports.nameToIDs = nameToIDs;
exports.default = transitionPath;


/***/ }),

/***/ "./node_modules/router5/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/router5/dist/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var $$observable = _interopDefault(__webpack_require__(/*! symbol-observable */ "./node_modules/symbol-observable/lib/index.js"));
var RouteNode = _interopDefault(__webpack_require__(/*! route-node */ "./node_modules/route-node/dist/cjs/route-node.js"));
var transitionPath = __webpack_require__(/*! router5-transition-path */ "./node_modules/router5-transition-path/dist/index.js");
var transitionPath__default = _interopDefault(transitionPath);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var defaultOptions = {
    trailingSlashMode: 'default',
    queryParamsMode: 'default',
    strictTrailingSlash: false,
    autoCleanUp: true,
    allowNotFound: false,
    strongMatching: true,
    rewritePathOnMatch: true,
    caseSensitive: false
};
function withOptions(options) {
    return function (router) {
        var routerOptions = __assign({}, defaultOptions, options);
        router.getOptions = function () { return routerOptions; };
        router.setOption = function (option, value) {
            routerOptions[option] = value;
            return router;
        };
        return router;
    };
}

var errorCodes = {
    ROUTER_NOT_STARTED: 'NOT_STARTED',
    NO_START_PATH_OR_STATE: 'NO_START_PATH_OR_STATE',
    ROUTER_ALREADY_STARTED: 'ALREADY_STARTED',
    ROUTE_NOT_FOUND: 'ROUTE_NOT_FOUND',
    SAME_STATES: 'SAME_STATES',
    CANNOT_DEACTIVATE: 'CANNOT_DEACTIVATE',
    CANNOT_ACTIVATE: 'CANNOT_ACTIVATE',
    TRANSITION_ERR: 'TRANSITION_ERR',
    TRANSITION_CANCELLED: 'CANCELLED'
};
var constants = {
    UNKNOWN_ROUTE: '@@router5/UNKNOWN_ROUTE',
    ROUTER_START: '$start',
    ROUTER_STOP: '$stop',
    TRANSITION_START: '$$start',
    TRANSITION_CANCEL: '$$cancel',
    TRANSITION_SUCCESS: '$$success',
    TRANSITION_ERROR: '$$error'
};

function withRoutes(routes) {
    return function (router) {
        router.forward = function (fromRoute, toRoute) {
            router.config.forwardMap[fromRoute] = toRoute;
            return router;
        };
        var rootNode = routes instanceof RouteNode
            ? routes
            : new RouteNode('', '', routes, onRouteAdded);
        function onRouteAdded(route) {
            if (route.canActivate)
                router.canActivate(route.name, route.canActivate);
            if (route.forwardTo)
                router.forward(route.name, route.forwardTo);
            if (route.decodeParams)
                router.config.decoders[route.name] = route.decodeParams;
            if (route.encodeParams)
                router.config.encoders[route.name] = route.encodeParams;
            if (route.defaultParams)
                router.config.defaultParams[route.name] = route.defaultParams;
        }
        router.rootNode = rootNode;
        router.add = function (routes, finalSort) {
            rootNode.add(routes, onRouteAdded, !finalSort);
            if (finalSort) {
                rootNode.sortDescendants();
            }
            return router;
        };
        router.addNode = function (name, path, canActivateHandler) {
            rootNode.addNode(name, path);
            if (canActivateHandler)
                router.canActivate(name, canActivateHandler);
            return router;
        };
        router.isActive = function (name, params, strictEquality, ignoreQueryParams) {
            if (params === void 0) { params = {}; }
            if (strictEquality === void 0) { strictEquality = false; }
            if (ignoreQueryParams === void 0) { ignoreQueryParams = true; }
            var activeState = router.getState();
            if (!activeState)
                return false;
            if (strictEquality || activeState.name === name) {
                return router.areStatesEqual(router.makeState(name, params), activeState, ignoreQueryParams);
            }
            return router.areStatesDescendants(router.makeState(name, params), activeState);
        };
        router.buildPath = function (route, params) {
            if (route === constants.UNKNOWN_ROUTE) {
                return params.path;
            }
            var paramsWithDefault = __assign({}, router.config.defaultParams[route], params);
            var _a = router.getOptions(), trailingSlashMode = _a.trailingSlashMode, queryParamsMode = _a.queryParamsMode, queryParams = _a.queryParams;
            var encodedParams = router.config.encoders[route]
                ? router.config.encoders[route](paramsWithDefault)
                : paramsWithDefault;
            return router.rootNode.buildPath(route, encodedParams, {
                trailingSlashMode: trailingSlashMode,
                queryParamsMode: queryParamsMode,
                queryParams: queryParams
            });
        };
        router.matchPath = function (path, source) {
            var options = router.getOptions();
            var match = router.rootNode.matchPath(path, options);
            if (match) {
                var name_1 = match.name, params = match.params, meta = match.meta;
                var decodedParams = router.config.decoders[name_1]
                    ? router.config.decoders[name_1](params)
                    : params;
                var _a = router.forwardState(name_1, decodedParams), routeName = _a.name, routeParams = _a.params;
                var builtPath = options.rewritePathOnMatch === false
                    ? path
                    : router.buildPath(routeName, routeParams);
                return router.makeState(routeName, routeParams, builtPath, {
                    params: meta,
                    source: source
                });
            }
            return null;
        };
        router.setRootPath = function (rootPath) {
            router.rootNode.setPath(rootPath);
        };
        return router;
    };
}

function withDependencies(dependencies) {
    return function (router) {
        var routerDependencies = dependencies;
        router.setDependency = function (dependencyName, dependency) {
            routerDependencies[dependencyName] = dependency;
            return router;
        };
        router.setDependencies = function (deps) {
            Object.keys(deps).forEach(function (name) {
                return router.setDependency(name, deps[name]);
            });
            return router;
        };
        router.getDependencies = function () { return routerDependencies; };
        router.getInjectables = function () { return [router, router.getDependencies()]; };
        router.executeFactory = function (factoryFunction) {
            return factoryFunction.apply(void 0, router.getInjectables());
        };
        return router;
    };
}

function withState(router) {
    var stateId = 0;
    var routerState = null;
    router.getState = function () { return routerState; };
    router.setState = function (state) {
        routerState = state;
    };
    router.makeState = function (name, params, path, meta, forceId) { return ({
        name: name,
        params: __assign({}, router.config.defaultParams[name], params),
        path: path,
        meta: meta
            ? __assign({}, meta, { id: forceId === undefined ? ++stateId : forceId }) : undefined
    }); };
    router.makeNotFoundState = function (path, options) {
        return router.makeState(constants.UNKNOWN_ROUTE, { path: path }, path, {
            options: options
        });
    };
    router.areStatesEqual = function (state1, state2, ignoreQueryParams) {
        if (ignoreQueryParams === void 0) { ignoreQueryParams = true; }
        if (state1.name !== state2.name)
            return false;
        var getUrlParams = function (name) {
            return router.rootNode
                //@ts-ignore
                .getSegmentsByName(name)
                .map(function (segment) { return segment.parser['urlParams']; })
                .reduce(function (params, p) { return params.concat(p); }, []);
        };
        var state1Params = ignoreQueryParams
            ? getUrlParams(state1.name)
            : Object.keys(state1.params);
        var state2Params = ignoreQueryParams
            ? getUrlParams(state2.name)
            : Object.keys(state2.params);
        return (state1Params.length === state2Params.length &&
            state1Params.every(function (p) { return state1.params[p] === state2.params[p]; }));
    };
    router.areStatesDescendants = function (parentState, childState) {
        var regex = new RegExp('^' + parentState.name + '\\.(.*)$');
        if (!regex.test(childState.name))
            return false;
        // If child state name extends parent state name, and all parent state params
        // are in child state params.
        return Object.keys(parentState.params).every(function (p) { return parentState.params[p] === childState.params[p]; });
    };
    router.forwardState = function (routeName, routeParams) {
        var name = router.config.forwardMap[routeName] || routeName;
        var params = __assign({}, router.config.defaultParams[routeName], router.config.defaultParams[name], routeParams);
        return {
            name: name,
            params: params
        };
    };
    router.buildState = function (routeName, routeParams) {
        var _a = router.forwardState(routeName, routeParams), name = _a.name, params = _a.params;
        return router.rootNode.buildState(name, params);
    };
    return router;
}

var eventsMap = {
    onStart: constants.ROUTER_START,
    onStop: constants.ROUTER_STOP,
    onTransitionSuccess: constants.TRANSITION_SUCCESS,
    onTransitionStart: constants.TRANSITION_START,
    onTransitionError: constants.TRANSITION_ERROR,
    onTransitionCancel: constants.TRANSITION_CANCEL
};
function withPlugins(router) {
    var routerPlugins = [];
    router.getPlugins = function () { return routerPlugins; };
    router.usePlugin = function () {
        var plugins = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            plugins[_i] = arguments[_i];
        }
        var removePluginFns = plugins.map(function (plugin) {
            routerPlugins.push(plugin);
            return startPlugin(plugin);
        });
        return function () {
            routerPlugins = routerPlugins.filter(function (plugin) { return plugins.indexOf(plugin) === -1; });
            removePluginFns.forEach(function (removePlugin) { return removePlugin(); });
        };
    };
    function startPlugin(plugin) {
        var appliedPlugin = router.executeFactory(plugin);
        var removeEventListeners = Object.keys(eventsMap)
            .map(function (methodName) {
            if (appliedPlugin[methodName]) {
                return router.addEventListener(eventsMap[methodName], appliedPlugin[methodName]);
            }
        })
            .filter(Boolean);
        return function () {
            removeEventListeners.forEach(function (removeListener) { return removeListener(); });
            if (appliedPlugin.teardown) {
                appliedPlugin.teardown();
            }
        };
    }
    return router;
}

function withMiddleware(router) {
    var middlewareFactories = [];
    var middlewareFunctions = [];
    router.useMiddleware = function () {
        var middlewares = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            middlewares[_i] = arguments[_i];
        }
        var removePluginFns = middlewares.map(function (middleware) {
            var middlewareFunction = router.executeFactory(middleware);
            middlewareFactories.push(middleware);
            middlewareFunctions.push(middlewareFunction);
            return function () {
                middlewareFactories = middlewareFactories.filter(function (m) { return m !== middleware; });
                middlewareFunctions = middlewareFunctions.filter(function (m) { return m !== middlewareFunction; });
            };
        });
        return function () { return removePluginFns.forEach(function (fn) { return fn(); }); };
    };
    router.clearMiddleware = function () {
        middlewareFactories = [];
        middlewareFunctions = [];
        return router;
    };
    router.getMiddlewareFactories = function () { return middlewareFactories; };
    router.getMiddlewareFunctions = function () { return middlewareFunctions; };
    return router;
}

function withObservability(router) {
    var callbacks = {};
    router.invokeEventListeners = function (eventName) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        (callbacks[eventName] || []).forEach(function (cb) { return cb.apply(void 0, args); });
    };
    router.removeEventListener = function (eventName, cb) {
        callbacks[eventName] = callbacks[eventName].filter(function (_cb) { return _cb !== cb; });
    };
    router.addEventListener = function (eventName, cb) {
        callbacks[eventName] = (callbacks[eventName] || []).concat(cb);
        return function () { return router.removeEventListener(eventName, cb); };
    };
    function subscribe(listener) {
        var isObject = typeof listener === 'object';
        var finalListener = isObject ? listener.next.bind(listener) : listener;
        var unsubscribeHandler = router.addEventListener(constants.TRANSITION_SUCCESS, function (toState, fromState) {
            finalListener({
                route: toState,
                previousRoute: fromState
            });
        });
        return isObject
            ? { unsubscribe: unsubscribeHandler }
            : unsubscribeHandler;
    }
    function observable() {
        var _a;
        return _a = {
                subscribe: function (observer) {
                    if (typeof observer !== 'object' || observer === null) {
                        throw new TypeError('Expected the observer to be an object.');
                    }
                    return subscribe(observer);
                }
            },
            _a[$$observable] = function () {
                return this;
            },
            _a;
    }
    router.subscribe = subscribe;
    //@ts-ignore
    router[$$observable] = observable;
    //@ts-ignore
    router['@@observable'] = observable;
    return router;
}

function resolve(functions, _a, callback) {
    var isCancelled = _a.isCancelled, toState = _a.toState, fromState = _a.fromState, _b = _a.errorKey, errorKey = _b === void 0 ? undefined : _b;
    var remainingFunctions = Array.isArray(functions)
        ? functions
        : Object.keys(functions);
    var isState = function (obj) {
        return typeof obj === 'object' &&
            obj.name !== undefined &&
            obj.params !== undefined &&
            obj.path !== undefined;
    };
    var hasStateChanged = function (toState, fromState) {
        return fromState.name !== toState.name ||
            fromState.params !== toState.params ||
            fromState.path !== toState.path;
    };
    var mergeStates = function (toState, fromState) { return (__assign({}, fromState, toState, { meta: __assign({}, fromState.meta, toState.meta) })); };
    var processFn = function (stepFn, errBase, state, _done) {
        var done = function (err, newState) {
            if (err) {
                _done(err);
            }
            else if (newState && newState !== state && isState(newState)) {
                if (hasStateChanged(newState, state)) {
                    console.error('[router5][transition] Warning: state values (name, params, path) were changed during transition process.');
                }
                _done(null, mergeStates(newState, state));
            }
            else {
                _done(null, state);
            }
        };
        var res = stepFn.call(null, state, fromState, done);
        if (isCancelled()) {
            done(null);
        }
        else if (typeof res === 'boolean') {
            done(res ? null : errBase);
        }
        else if (isState(res)) {
            done(null, res);
        }
        else if (res && typeof res.then === 'function') {
            res.then(function (resVal) {
                if (resVal instanceof Error)
                    done({ error: resVal }, null);
                else
                    done(null, resVal);
            }, function (err) {
                if (err instanceof Error) {
                    console.error(err.stack || err);
                    done(__assign({}, errBase, { promiseError: err }), null);
                }
                else {
                    done(typeof err === 'object'
                        ? __assign({}, errBase, err) : errBase, null);
                }
            });
        }
        // else: wait for done to be called
    };
    var next = function (err, state) {
        var _a;
        if (isCancelled()) {
            callback();
        }
        else if (err) {
            callback(err);
        }
        else {
            if (!remainingFunctions.length) {
                callback(null, state);
            }
            else {
                var isMapped = typeof remainingFunctions[0] === 'string';
                var errBase = errorKey && isMapped
                    ? (_a = {}, _a[errorKey] = remainingFunctions[0], _a) : {};
                var stepFn = isMapped
                    ? functions[remainingFunctions[0]]
                    : remainingFunctions[0];
                remainingFunctions = remainingFunctions.slice(1);
                processFn(stepFn, errBase, state, next);
            }
        }
    };
    next(null, toState);
}

function transition(router, toState, fromState, opts, callback) {
    var cancelled = false;
    var completed = false;
    var options = router.getOptions();
    var _a = router.getLifecycleFunctions(), canDeactivateFunctions = _a[0], canActivateFunctions = _a[1];
    var middlewareFunctions = router.getMiddlewareFunctions();
    var isCancelled = function () { return cancelled; };
    var cancel = function () {
        if (!cancelled && !completed) {
            cancelled = true;
            callback({ code: errorCodes.TRANSITION_CANCELLED }, null);
        }
    };
    var done = function (err, state) {
        completed = true;
        if (isCancelled()) {
            return;
        }
        if (!err && options.autoCleanUp) {
            var activeSegments_1 = transitionPath.nameToIDs(toState.name);
            Object.keys(canDeactivateFunctions).forEach(function (name) {
                if (activeSegments_1.indexOf(name) === -1)
                    router.clearCanDeactivate(name);
            });
        }
        callback(err, state || toState);
    };
    var makeError = function (base, err) { return (__assign({}, base, (err instanceof Object ? err : { error: err }))); };
    var isUnknownRoute = toState.name === constants.UNKNOWN_ROUTE;
    var asyncBase = { isCancelled: isCancelled, toState: toState, fromState: fromState };
    var _b = transitionPath__default(toState, fromState), toDeactivate = _b.toDeactivate, toActivate = _b.toActivate;
    var canDeactivate = !fromState || opts.forceDeactivate
        ? []
        : function (toState, fromState, cb) {
            var canDeactivateFunctionMap = toDeactivate
                .filter(function (name) { return canDeactivateFunctions[name]; })
                .reduce(function (fnMap, name) {
                var _a;
                return (__assign({}, fnMap, (_a = {}, _a[name] = canDeactivateFunctions[name], _a)));
            }, {});
            resolve(canDeactivateFunctionMap, __assign({}, asyncBase, { errorKey: 'segment' }), function (err) {
                return cb(err
                    ? makeError({ code: errorCodes.CANNOT_DEACTIVATE }, err)
                    : null);
            });
        };
    var canActivate = isUnknownRoute
        ? []
        : function (toState, fromState, cb) {
            var canActivateFunctionMap = toActivate
                .filter(function (name) { return canActivateFunctions[name]; })
                .reduce(function (fnMap, name) {
                var _a;
                return (__assign({}, fnMap, (_a = {}, _a[name] = canActivateFunctions[name], _a)));
            }, {});
            resolve(canActivateFunctionMap, __assign({}, asyncBase, { errorKey: 'segment' }), function (err) {
                return cb(err
                    ? makeError({ code: errorCodes.CANNOT_ACTIVATE }, err)
                    : null);
            });
        };
    var middleware = !middlewareFunctions.length
        ? []
        : function (toState, fromState, cb) {
            return resolve(middlewareFunctions, __assign({}, asyncBase), function (err, state) {
                return cb(err
                    ? makeError({ code: errorCodes.TRANSITION_ERR }, err)
                    : null, state || toState);
            });
        };
    var pipeline = []
        .concat(canDeactivate)
        .concat(canActivate)
        .concat(middleware);
    resolve(pipeline, asyncBase, done);
    return cancel;
}

var noop = function (err, state) { };
function withNavigation(router) {
    var cancelCurrentTransition;
    router.navigate = navigate;
    router.navigate = navigate;
    router.navigateToDefault = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var opts = typeof args[0] === 'object' ? args[0] : {};
        var done = args.length === 2
            ? args[1]
            : typeof args[0] === 'function'
                ? args[0]
                : noop;
        var options = router.getOptions();
        if (options.defaultRoute) {
            return navigate(options.defaultRoute, options.defaultParams, opts, done);
        }
        return function () { };
    };
    router.cancel = function () {
        if (cancelCurrentTransition) {
            cancelCurrentTransition('navigate');
            cancelCurrentTransition = null;
        }
        return router;
    };
    function navigate() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var name = args[0];
        var lastArg = args[args.length - 1];
        var done = typeof lastArg === 'function' ? lastArg : noop;
        var params = typeof args[1] === 'object' ? args[1] : {};
        var opts = typeof args[2] === 'object' ? args[2] : {};
        if (!router.isStarted()) {
            done({ code: errorCodes.ROUTER_NOT_STARTED });
            return;
        }
        var route = router.buildState(name, params);
        if (!route) {
            var err = { code: errorCodes.ROUTE_NOT_FOUND };
            done(err);
            router.invokeEventListeners(constants.TRANSITION_ERROR, null, router.getState(), err);
            return;
        }
        var toState = router.makeState(route.name, route.params, router.buildPath(route.name, route.params), { params: route.meta, options: opts });
        var sameStates = router.getState()
            ? router.areStatesEqual(router.getState(), toState, false)
            : false;
        // Do not proceed further if states are the same and no reload
        // (no deactivation and no callbacks)
        if (sameStates && !opts.reload && !opts.force) {
            var err = { code: errorCodes.SAME_STATES };
            done(err);
            router.invokeEventListeners(constants.TRANSITION_ERROR, toState, router.getState(), err);
            return;
        }
        var fromState = router.getState();
        if (opts.skipTransition) {
            done(null, toState);
            return noop;
        }
        // Transition
        return router.transitionToState(toState, fromState, opts, function (err, state) {
            if (err) {
                if (err.redirect) {
                    var _a = err.redirect, name_1 = _a.name, params_1 = _a.params;
                    navigate(name_1, params_1, __assign({}, opts, { force: true, redirected: true }), done);
                }
                else {
                    done(err);
                }
            }
            else {
                router.invokeEventListeners(constants.TRANSITION_SUCCESS, state, fromState, opts);
                done(null, state);
            }
        });
    }
    router.transitionToState = function (toState, fromState, options, done) {
        if (options === void 0) { options = {}; }
        if (done === void 0) { done = noop; }
        router.cancel();
        router.invokeEventListeners(constants.TRANSITION_START, toState, fromState);
        cancelCurrentTransition = transition(router, toState, fromState, options, function (err, state) {
            cancelCurrentTransition = null;
            state = state || toState;
            if (err) {
                if (err.code === errorCodes.TRANSITION_CANCELLED) {
                    router.invokeEventListeners(constants.TRANSITION_CANCEL, toState, fromState);
                }
                else {
                    router.invokeEventListeners(constants.TRANSITION_ERROR, toState, fromState, err);
                }
                done(err);
            }
            else {
                router.setState(state);
                done(null, state);
            }
        });
        return cancelCurrentTransition;
    };
    return router;
}

var noop$1 = function () { };
function withRouterLifecycle(router) {
    var started = false;
    router.isStarted = function () { return started; };
    //@ts-ignore
    router.start = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var options = router.getOptions();
        var lastArg = args[args.length - 1];
        var done = typeof lastArg === 'function' ? lastArg : noop$1;
        var startPathOrState = typeof args[0] !== 'function' ? args[0] : undefined;
        if (started) {
            done({ code: errorCodes.ROUTER_ALREADY_STARTED });
            return router;
        }
        var startPath, startState;
        started = true;
        router.invokeEventListeners(constants.ROUTER_START);
        // callback
        var cb = function (err, state, invokeErrCb) {
            if (invokeErrCb === void 0) { invokeErrCb = true; }
            if (!err)
                router.invokeEventListeners(constants.TRANSITION_SUCCESS, state, null, { replace: true });
            if (err && invokeErrCb)
                router.invokeEventListeners(constants.TRANSITION_ERROR, state, null, err);
            done(err, state);
        };
        if (startPathOrState === undefined && !options.defaultRoute) {
            return cb({ code: errorCodes.NO_START_PATH_OR_STATE });
        }
        if (typeof startPathOrState === 'string') {
            startPath = startPathOrState;
        }
        else if (typeof startPathOrState === 'object') {
            startState = startPathOrState;
        }
        if (!startState) {
            // If no supplied start state, get start state
            startState =
                startPath === undefined ? null : router.matchPath(startPath);
            // Navigate to default function
            var navigateToDefault_1 = function () {
                return router.navigateToDefault({ replace: true }, done);
            };
            var redirect_1 = function (route) {
                return router.navigate(route.name, route.params, { replace: true, reload: true, redirected: true }, done);
            };
            var transitionToState = function (state) {
                router.transitionToState(state, router.getState(), {}, function (err, state) {
                    if (!err)
                        cb(null, state);
                    else if (err.redirect)
                        redirect_1(err.redirect);
                    else if (options.defaultRoute)
                        navigateToDefault_1();
                    else
                        cb(err, null, false);
                });
            };
            // If matched start path
            if (startState) {
                transitionToState(startState);
            }
            else if (options.defaultRoute) {
                // If default, navigate to default
                navigateToDefault_1();
            }
            else if (options.allowNotFound) {
                transitionToState(router.makeNotFoundState(startPath, { replace: true }));
            }
            else {
                // No start match, no default => do nothing
                cb({ code: errorCodes.ROUTE_NOT_FOUND, path: startPath }, null);
            }
        }
        else {
            // Initialise router with provided start state
            router.setState(startState);
            cb(null, startState);
        }
        return router;
    };
    router.stop = function () {
        if (started) {
            router.setState(null);
            started = false;
            router.invokeEventListeners(constants.ROUTER_STOP);
        }
        return router;
    };
    return router;
}

var toFunction = function (val) { return (typeof val === 'function' ? val : function () { return function () { return val; }; }); };
function withRouteLifecycle(router) {
    var canDeactivateFactories = {};
    var canActivateFactories = {};
    var canDeactivateFunctions = {};
    var canActivateFunctions = {};
    router.getLifecycleFactories = function () {
        return [canDeactivateFactories, canActivateFactories];
    };
    router.getLifecycleFunctions = function () {
        return [canDeactivateFunctions, canActivateFunctions];
    };
    router.canDeactivate = function (name, canDeactivateHandler) {
        var factory = toFunction(canDeactivateHandler);
        canDeactivateFactories[name] = factory;
        canDeactivateFunctions[name] = router.executeFactory(factory);
        return router;
    };
    router.clearCanDeactivate = function (name) {
        canDeactivateFactories[name] = undefined;
        canDeactivateFunctions[name] = undefined;
        return router;
    };
    router.canActivate = function (name, canActivateHandler) {
        var factory = toFunction(canActivateHandler);
        canActivateFactories[name] = factory;
        canActivateFunctions[name] = router.executeFactory(factory);
        return router;
    };
    return router;
}

var pipe = function () {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return function (arg) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, arg);
    };
};
var createRouter = function (routes, options, dependencies) {
    if (routes === void 0) { routes = []; }
    if (options === void 0) { options = {}; }
    if (dependencies === void 0) { dependencies = {}; }
    var config = {
        decoders: {},
        encoders: {},
        defaultParams: {},
        forwardMap: {}
    };
    return pipe(withOptions(options), withDependencies(dependencies), withObservability, withState, withRouterLifecycle, withRouteLifecycle, withNavigation, withPlugins, withMiddleware, withRoutes(routes))({ config: config });
};

function cloneRouter(router, dependencies) {
    var clonedRouter = createRouter(router.rootNode, router.getOptions(), dependencies);
    clonedRouter.useMiddleware.apply(clonedRouter, router.getMiddlewareFactories());
    clonedRouter.usePlugin.apply(clonedRouter, router.getPlugins());
    clonedRouter.config = router.config;
    var _a = router.getLifecycleFactories(), canDeactivateFactories = _a[0], canActivateFactories = _a[1];
    Object.keys(canDeactivateFactories).forEach(function (name) {
        return clonedRouter.canDeactivate(name, canDeactivateFactories[name]);
    });
    Object.keys(canActivateFactories).forEach(function (name) {
        return clonedRouter.canActivate(name, canActivateFactories[name]);
    });
    return clonedRouter;
}

exports.RouteNode = RouteNode;
exports.transitionPath = transitionPath__default;
exports.createRouter = createRouter;
exports.cloneRouter = cloneRouter;
exports.constants = constants;
exports.errorCodes = errorCodes;
exports.default = createRouter;


/***/ }),

/***/ "./node_modules/rxjs/internal/BehaviorSubject.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/internal/BehaviorSubject.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = __webpack_require__(/*! ./Subject */ "./node_modules/rxjs/internal/Subject.js");
var ObjectUnsubscribedError_1 = __webpack_require__(/*! ./util/ObjectUnsubscribedError */ "./node_modules/rxjs/internal/util/ObjectUnsubscribedError.js");
var BehaviorSubject = (function (_super) {
    __extends(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
            throw this.thrownError;
        }
        else if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else {
            return this._value;
        }
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}(Subject_1.Subject));
exports.BehaviorSubject = BehaviorSubject;
//# sourceMappingURL=BehaviorSubject.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/InnerSubscriber.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/internal/InnerSubscriber.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = __webpack_require__(/*! ./Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
var InnerSubscriber = (function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        _this.index = 0;
        return _this;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber));
exports.InnerSubscriber = InnerSubscriber;
//# sourceMappingURL=InnerSubscriber.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/Notification.js":
/*!****************************************************!*\
  !*** ./node_modules/rxjs/internal/Notification.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var empty_1 = __webpack_require__(/*! ./observable/empty */ "./node_modules/rxjs/internal/observable/empty.js");
var of_1 = __webpack_require__(/*! ./observable/of */ "./node_modules/rxjs/internal/observable/of.js");
var throwError_1 = __webpack_require__(/*! ./observable/throwError */ "./node_modules/rxjs/internal/observable/throwError.js");
var NotificationKind;
(function (NotificationKind) {
    NotificationKind["NEXT"] = "N";
    NotificationKind["ERROR"] = "E";
    NotificationKind["COMPLETE"] = "C";
})(NotificationKind = exports.NotificationKind || (exports.NotificationKind = {}));
var Notification = (function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        }
        else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return of_1.of(this.value);
            case 'E':
                return throwError_1.throwError(this.error);
            case 'C':
                return empty_1.empty();
        }
        throw new Error('unexpected notification kind value');
    };
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return Notification.undefinedValueNotification;
    };
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}());
exports.Notification = Notification;
//# sourceMappingURL=Notification.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/Observable.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/internal/Observable.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var canReportError_1 = __webpack_require__(/*! ./util/canReportError */ "./node_modules/rxjs/internal/util/canReportError.js");
var toSubscriber_1 = __webpack_require__(/*! ./util/toSubscriber */ "./node_modules/rxjs/internal/util/toSubscriber.js");
var observable_1 = __webpack_require__(/*! ./symbol/observable */ "./node_modules/rxjs/internal/symbol/observable.js");
var pipe_1 = __webpack_require__(/*! ./util/pipe */ "./node_modules/rxjs/internal/util/pipe.js");
var config_1 = __webpack_require__(/*! ./config */ "./node_modules/rxjs/internal/config.js");
var Observable = (function () {
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            sink.add(operator.call(sink, this.source));
        }
        else {
            sink.add(this.source || (config_1.config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                this._subscribe(sink) :
                this._trySubscribe(sink));
        }
        if (config_1.config.useDeprecatedSynchronousErrorHandling) {
            if (sink.syncErrorThrowable) {
                sink.syncErrorThrowable = false;
                if (sink.syncErrorThrown) {
                    throw sink.syncErrorValue;
                }
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                sink.syncErrorThrown = true;
                sink.syncErrorValue = err;
            }
            if (canReportError_1.canReportError(sink)) {
                sink.error(err);
            }
            else {
                console.warn(err);
            }
        }
    };
    Observable.prototype.forEach = function (next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var subscription;
            subscription = _this.subscribe(function (value) {
                try {
                    next(value);
                }
                catch (err) {
                    reject(err);
                    if (subscription) {
                        subscription.unsubscribe();
                    }
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
    };
    Observable.prototype[observable_1.observable] = function () {
        return this;
    };
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return pipe_1.pipeFromArray(operations)(this);
    };
    Observable.prototype.toPromise = function (promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
exports.Observable = Observable;
function getPromiseCtor(promiseCtor) {
    if (!promiseCtor) {
        promiseCtor = config_1.config.Promise || Promise;
    }
    if (!promiseCtor) {
        throw new Error('no Promise impl found');
    }
    return promiseCtor;
}
//# sourceMappingURL=Observable.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/Observer.js":
/*!************************************************!*\
  !*** ./node_modules/rxjs/internal/Observer.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var config_1 = __webpack_require__(/*! ./config */ "./node_modules/rxjs/internal/config.js");
var hostReportError_1 = __webpack_require__(/*! ./util/hostReportError */ "./node_modules/rxjs/internal/util/hostReportError.js");
exports.empty = {
    closed: true,
    next: function (value) { },
    error: function (err) {
        if (config_1.config.useDeprecatedSynchronousErrorHandling) {
            throw err;
        }
        else {
            hostReportError_1.hostReportError(err);
        }
    },
    complete: function () { }
};
//# sourceMappingURL=Observer.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/OuterSubscriber.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/internal/OuterSubscriber.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = __webpack_require__(/*! ./Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
var OuterSubscriber = (function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber_1.Subscriber));
exports.OuterSubscriber = OuterSubscriber;
//# sourceMappingURL=OuterSubscriber.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/ReplaySubject.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/internal/ReplaySubject.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = __webpack_require__(/*! ./Subject */ "./node_modules/rxjs/internal/Subject.js");
var queue_1 = __webpack_require__(/*! ./scheduler/queue */ "./node_modules/rxjs/internal/scheduler/queue.js");
var Subscription_1 = __webpack_require__(/*! ./Subscription */ "./node_modules/rxjs/internal/Subscription.js");
var observeOn_1 = __webpack_require__(/*! ./operators/observeOn */ "./node_modules/rxjs/internal/operators/observeOn.js");
var ObjectUnsubscribedError_1 = __webpack_require__(/*! ./util/ObjectUnsubscribedError */ "./node_modules/rxjs/internal/util/ObjectUnsubscribedError.js");
var SubjectSubscription_1 = __webpack_require__(/*! ./SubjectSubscription */ "./node_modules/rxjs/internal/SubjectSubscription.js");
var ReplaySubject = (function (_super) {
    __extends(ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
        var _this = _super.call(this) || this;
        _this.scheduler = scheduler;
        _this._events = [];
        _this._infiniteTimeWindow = false;
        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this._windowTime = windowTime < 1 ? 1 : windowTime;
        if (windowTime === Number.POSITIVE_INFINITY) {
            _this._infiniteTimeWindow = true;
            _this.next = _this.nextInfiniteTimeWindow;
        }
        else {
            _this.next = _this.nextTimeWindow;
        }
        return _this;
    }
    ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
        var _events = this._events;
        _events.push(value);
        if (_events.length > this._bufferSize) {
            _events.shift();
        }
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype.nextTimeWindow = function (value) {
        this._events.push(new ReplayEvent(this._getNow(), value));
        this._trimBufferThenGetEvents();
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function (subscriber) {
        var _infiniteTimeWindow = this._infiniteTimeWindow;
        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var len = _events.length;
        var subscription;
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.isStopped || this.hasError) {
            subscription = Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));
        }
        if (_infiniteTimeWindow) {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i]);
            }
        }
        else {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i].value);
            }
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        }
        else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || queue_1.queue).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        while (spliceCount < eventsCount) {
            if ((now - _events[spliceCount].time) < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(Subject_1.Subject));
exports.ReplaySubject = ReplaySubject;
var ReplayEvent = (function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}());
//# sourceMappingURL=ReplaySubject.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/Scheduler.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/internal/Scheduler.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Scheduler = (function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) { now = Scheduler.now; }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) { delay = 0; }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = function () { return Date.now(); };
    return Scheduler;
}());
exports.Scheduler = Scheduler;
//# sourceMappingURL=Scheduler.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/Subject.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/internal/Subject.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(/*! ./Observable */ "./node_modules/rxjs/internal/Observable.js");
var Subscriber_1 = __webpack_require__(/*! ./Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
var Subscription_1 = __webpack_require__(/*! ./Subscription */ "./node_modules/rxjs/internal/Subscription.js");
var ObjectUnsubscribedError_1 = __webpack_require__(/*! ./util/ObjectUnsubscribedError */ "./node_modules/rxjs/internal/util/ObjectUnsubscribedError.js");
var SubjectSubscription_1 = __webpack_require__(/*! ./SubjectSubscription */ "./node_modules/rxjs/internal/SubjectSubscription.js");
var rxSubscriber_1 = __webpack_require__(/*! ../internal/symbol/rxSubscriber */ "./node_modules/rxjs/internal/symbol/rxSubscriber.js");
var SubjectSubscriber = (function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        return _this;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber));
exports.SubjectSubscriber = SubjectSubscriber;
var Subject = (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        var _this = _super.call(this) || this;
        _this.observers = [];
        _this.closed = false;
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
    }
    Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable));
exports.Subject = Subject;
var AnonymousSubject = (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));
exports.AnonymousSubject = AnonymousSubject;
//# sourceMappingURL=Subject.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/SubjectSubscription.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/internal/SubjectSubscription.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscription_1 = __webpack_require__(/*! ./Subscription */ "./node_modules/rxjs/internal/Subscription.js");
var SubjectSubscription = (function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        var _this = _super.call(this) || this;
        _this.subject = subject;
        _this.subscriber = subscriber;
        _this.closed = false;
        return _this;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription));
exports.SubjectSubscription = SubjectSubscription;
//# sourceMappingURL=SubjectSubscription.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/Subscriber.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/internal/Subscriber.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var isFunction_1 = __webpack_require__(/*! ./util/isFunction */ "./node_modules/rxjs/internal/util/isFunction.js");
var Observer_1 = __webpack_require__(/*! ./Observer */ "./node_modules/rxjs/internal/Observer.js");
var Subscription_1 = __webpack_require__(/*! ./Subscription */ "./node_modules/rxjs/internal/Subscription.js");
var rxSubscriber_1 = __webpack_require__(/*! ../internal/symbol/rxSubscriber */ "./node_modules/rxjs/internal/symbol/rxSubscriber.js");
var config_1 = __webpack_require__(/*! ./config */ "./node_modules/rxjs/internal/config.js");
var hostReportError_1 = __webpack_require__(/*! ./util/hostReportError */ "./node_modules/rxjs/internal/util/hostReportError.js");
var Subscriber = (function (_super) {
    __extends(Subscriber, _super);
    function Subscriber(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this.syncErrorValue = null;
        _this.syncErrorThrown = false;
        _this.syncErrorThrowable = false;
        _this.isStopped = false;
        switch (arguments.length) {
            case 0:
                _this.destination = Observer_1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    _this.destination = Observer_1.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                        _this.destination = destinationOrNext;
                        destinationOrNext.add(_this);
                    }
                    else {
                        _this.syncErrorThrowable = true;
                        _this.destination = new SafeSubscriber(_this, destinationOrNext);
                    }
                    break;
                }
            default:
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                break;
        }
        return _this;
    }
    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () { return this; };
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _parentOrParents = this._parentOrParents;
        this._parentOrParents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parentOrParents = _parentOrParents;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription));
exports.Subscriber = Subscriber;
var SafeSubscriber = (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== Observer_1.empty) {
                context = Object.create(observerOrNext);
                if (isFunction_1.isFunction(context.unsubscribe)) {
                    _this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = _this.unsubscribe.bind(_this);
            }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!config_1.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            var useDeprecatedSynchronousErrorHandling = config_1.config.useDeprecatedSynchronousErrorHandling;
            if (this._error) {
                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                if (useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                hostReportError_1.hostReportError(err);
            }
            else {
                if (useDeprecatedSynchronousErrorHandling) {
                    _parentSubscriber.syncErrorValue = err;
                    _parentSubscriber.syncErrorThrown = true;
                }
                else {
                    hostReportError_1.hostReportError(err);
                }
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!config_1.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                hostReportError_1.hostReportError(err);
            }
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        if (!config_1.config.useDeprecatedSynchronousErrorHandling) {
            throw new Error('bad call');
        }
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                parent.syncErrorValue = err;
                parent.syncErrorThrown = true;
                return true;
            }
            else {
                hostReportError_1.hostReportError(err);
                return true;
            }
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));
exports.SafeSubscriber = SafeSubscriber;
//# sourceMappingURL=Subscriber.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/Subscription.js":
/*!****************************************************!*\
  !*** ./node_modules/rxjs/internal/Subscription.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var isArray_1 = __webpack_require__(/*! ./util/isArray */ "./node_modules/rxjs/internal/util/isArray.js");
var isObject_1 = __webpack_require__(/*! ./util/isObject */ "./node_modules/rxjs/internal/util/isObject.js");
var isFunction_1 = __webpack_require__(/*! ./util/isFunction */ "./node_modules/rxjs/internal/util/isFunction.js");
var UnsubscriptionError_1 = __webpack_require__(/*! ./util/UnsubscriptionError */ "./node_modules/rxjs/internal/util/UnsubscriptionError.js");
var Subscription = (function () {
    function Subscription(unsubscribe) {
        this.closed = false;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    Subscription.prototype.unsubscribe = function () {
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parentOrParents = _a._parentOrParents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (_parentOrParents instanceof Subscription) {
            _parentOrParents.remove(this);
        }
        else if (_parentOrParents !== null) {
            for (var index = 0; index < _parentOrParents.length; ++index) {
                var parent_1 = _parentOrParents[index];
                parent_1.remove(this);
            }
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            try {
                _unsubscribe.call(this);
            }
            catch (e) {
                errors = e instanceof UnsubscriptionError_1.UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            var index = -1;
            var len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    try {
                        sub.unsubscribe();
                    }
                    catch (e) {
                        errors = errors || [];
                        if (e instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                        }
                        else {
                            errors.push(e);
                        }
                    }
                }
            }
        }
        if (errors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    Subscription.prototype.add = function (teardown) {
        var subscription = teardown;
        if (!teardown) {
            return Subscription.EMPTY;
        }
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (!(subscription instanceof Subscription)) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default: {
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
            }
        }
        var _parentOrParents = subscription._parentOrParents;
        if (_parentOrParents === null) {
            subscription._parentOrParents = this;
        }
        else if (_parentOrParents instanceof Subscription) {
            if (_parentOrParents === this) {
                return subscription;
            }
            subscription._parentOrParents = [_parentOrParents, this];
        }
        else if (_parentOrParents.indexOf(this) === -1) {
            _parentOrParents.push(this);
        }
        else {
            return subscription;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions === null) {
            this._subscriptions = [subscription];
        }
        else {
            subscriptions.push(subscription);
        }
        return subscription;
    };
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
exports.Subscription = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
}
//# sourceMappingURL=Subscription.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/config.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/internal/config.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var _enable_super_gross_mode_that_will_cause_bad_things = false;
exports.config = {
    Promise: undefined,
    set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
            var error = new Error();
            console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
        }
        else if (_enable_super_gross_mode_that_will_cause_bad_things) {
            console.log('RxJS: Back to a better error behavior. Thank you. <3');
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value;
    },
    get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
    },
};
//# sourceMappingURL=config.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/observable/combineLatest.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/internal/observable/combineLatest.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var isScheduler_1 = __webpack_require__(/*! ../util/isScheduler */ "./node_modules/rxjs/internal/util/isScheduler.js");
var isArray_1 = __webpack_require__(/*! ../util/isArray */ "./node_modules/rxjs/internal/util/isArray.js");
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/internal/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/internal/util/subscribeToResult.js");
var fromArray_1 = __webpack_require__(/*! ./fromArray */ "./node_modules/rxjs/internal/observable/fromArray.js");
var NONE = {};
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = null;
    var scheduler = null;
    if (isScheduler_1.isScheduler(observables[observables.length - 1])) {
        scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === 'function') {
        resultSelector = observables.pop();
    }
    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
        observables = observables[0];
    }
    return fromArray_1.fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
exports.combineLatest = combineLatest;
var CombineLatestOperator = (function () {
    function CombineLatestOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
    };
    return CombineLatestOperator;
}());
exports.CombineLatestOperator = CombineLatestOperator;
var CombineLatestSubscriber = (function (_super) {
    __extends(CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, resultSelector) {
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.active = 0;
        _this.values = [];
        _this.observables = [];
        return _this;
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(NONE);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond
            ? 0
            : oldVal === NONE ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.resultSelector) {
                this._tryResultSelector(values);
            }
            else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryResultSelector = function (values) {
        var result;
        try {
            result = this.resultSelector.apply(this, values);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.CombineLatestSubscriber = CombineLatestSubscriber;
//# sourceMappingURL=combineLatest.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/observable/concat.js":
/*!*********************************************************!*\
  !*** ./node_modules/rxjs/internal/observable/concat.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var of_1 = __webpack_require__(/*! ./of */ "./node_modules/rxjs/internal/observable/of.js");
var concatAll_1 = __webpack_require__(/*! ../operators/concatAll */ "./node_modules/rxjs/internal/operators/concatAll.js");
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));
}
exports.concat = concat;
//# sourceMappingURL=concat.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/observable/empty.js":
/*!********************************************************!*\
  !*** ./node_modules/rxjs/internal/observable/empty.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/internal/Observable.js");
exports.EMPTY = new Observable_1.Observable(function (subscriber) { return subscriber.complete(); });
function empty(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
}
exports.empty = empty;
function emptyScheduled(scheduler) {
    return new Observable_1.Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
}
//# sourceMappingURL=empty.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/observable/from.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/internal/observable/from.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/internal/Observable.js");
var subscribeTo_1 = __webpack_require__(/*! ../util/subscribeTo */ "./node_modules/rxjs/internal/util/subscribeTo.js");
var scheduled_1 = __webpack_require__(/*! ../scheduled/scheduled */ "./node_modules/rxjs/internal/scheduled/scheduled.js");
function from(input, scheduler) {
    if (!scheduler) {
        if (input instanceof Observable_1.Observable) {
            return input;
        }
        return new Observable_1.Observable(subscribeTo_1.subscribeTo(input));
    }
    else {
        return scheduled_1.scheduled(input, scheduler);
    }
}
exports.from = from;
//# sourceMappingURL=from.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/observable/fromArray.js":
/*!************************************************************!*\
  !*** ./node_modules/rxjs/internal/observable/fromArray.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/internal/Observable.js");
var subscribeToArray_1 = __webpack_require__(/*! ../util/subscribeToArray */ "./node_modules/rxjs/internal/util/subscribeToArray.js");
var scheduleArray_1 = __webpack_require__(/*! ../scheduled/scheduleArray */ "./node_modules/rxjs/internal/scheduled/scheduleArray.js");
function fromArray(input, scheduler) {
    if (!scheduler) {
        return new Observable_1.Observable(subscribeToArray_1.subscribeToArray(input));
    }
    else {
        return scheduleArray_1.scheduleArray(input, scheduler);
    }
}
exports.fromArray = fromArray;
//# sourceMappingURL=fromArray.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/observable/fromEvent.js":
/*!************************************************************!*\
  !*** ./node_modules/rxjs/internal/observable/fromEvent.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/internal/Observable.js");
var isArray_1 = __webpack_require__(/*! ../util/isArray */ "./node_modules/rxjs/internal/util/isArray.js");
var isFunction_1 = __webpack_require__(/*! ../util/isFunction */ "./node_modules/rxjs/internal/util/isFunction.js");
var map_1 = __webpack_require__(/*! ../operators/map */ "./node_modules/rxjs/internal/operators/map.js");
var toString = (function () { return Object.prototype.toString; })();
function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction_1.isFunction(options)) {
        resultSelector = options;
        options = undefined;
    }
    if (resultSelector) {
        return fromEvent(target, eventName, options).pipe(map_1.map(function (args) { return isArray_1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new Observable_1.Observable(function (subscriber) {
        function handler(e) {
            if (arguments.length > 1) {
                subscriber.next(Array.prototype.slice.call(arguments));
            }
            else {
                subscriber.next(e);
            }
        }
        setupSubscription(target, eventName, handler, subscriber, options);
    });
}
exports.fromEvent = fromEvent;
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
    var unsubscribe;
    if (isEventTarget(sourceObj)) {
        var source_1 = sourceObj;
        sourceObj.addEventListener(eventName, handler, options);
        unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };
    }
    else if (isJQueryStyleEventEmitter(sourceObj)) {
        var source_2 = sourceObj;
        sourceObj.on(eventName, handler);
        unsubscribe = function () { return source_2.off(eventName, handler); };
    }
    else if (isNodeStyleEventEmitter(sourceObj)) {
        var source_3 = sourceObj;
        sourceObj.addListener(eventName, handler);
        unsubscribe = function () { return source_3.removeListener(eventName, handler); };
    }
    else if (sourceObj && sourceObj.length) {
        for (var i = 0, len = sourceObj.length; i < len; i++) {
            setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
        }
    }
    else {
        throw new TypeError('Invalid event target');
    }
    subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isEventTarget(sourceObj) {
    return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}
//# sourceMappingURL=fromEvent.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/observable/interval.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/internal/observable/interval.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/internal/Observable.js");
var async_1 = __webpack_require__(/*! ../scheduler/async */ "./node_modules/rxjs/internal/scheduler/async.js");
var isNumeric_1 = __webpack_require__(/*! ../util/isNumeric */ "./node_modules/rxjs/internal/util/isNumeric.js");
function interval(period, scheduler) {
    if (period === void 0) { period = 0; }
    if (scheduler === void 0) { scheduler = async_1.async; }
    if (!isNumeric_1.isNumeric(period) || period < 0) {
        period = 0;
    }
    if (!scheduler || typeof scheduler.schedule !== 'function') {
        scheduler = async_1.async;
    }
    return new Observable_1.Observable(function (subscriber) {
        subscriber.add(scheduler.schedule(dispatch, period, { subscriber: subscriber, counter: 0, period: period }));
        return subscriber;
    });
}
exports.interval = interval;
function dispatch(state) {
    var subscriber = state.subscriber, counter = state.counter, period = state.period;
    subscriber.next(counter);
    this.schedule({ subscriber: subscriber, counter: counter + 1, period: period }, period);
}
//# sourceMappingURL=interval.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/observable/merge.js":
/*!********************************************************!*\
  !*** ./node_modules/rxjs/internal/observable/merge.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/internal/Observable.js");
var isScheduler_1 = __webpack_require__(/*! ../util/isScheduler */ "./node_modules/rxjs/internal/util/isScheduler.js");
var mergeAll_1 = __webpack_require__(/*! ../operators/mergeAll */ "./node_modules/rxjs/internal/operators/mergeAll.js");
var fromArray_1 = __webpack_require__(/*! ./fromArray */ "./node_modules/rxjs/internal/observable/fromArray.js");
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (isScheduler_1.isScheduler(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    }
    else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return mergeAll_1.mergeAll(concurrent)(fromArray_1.fromArray(observables, scheduler));
}
exports.merge = merge;
//# sourceMappingURL=merge.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/observable/never.js":
/*!********************************************************!*\
  !*** ./node_modules/rxjs/internal/observable/never.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/internal/Observable.js");
var noop_1 = __webpack_require__(/*! ../util/noop */ "./node_modules/rxjs/internal/util/noop.js");
exports.NEVER = new Observable_1.Observable(noop_1.noop);
function never() {
    return exports.NEVER;
}
exports.never = never;
//# sourceMappingURL=never.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/observable/of.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/internal/observable/of.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var isScheduler_1 = __webpack_require__(/*! ../util/isScheduler */ "./node_modules/rxjs/internal/util/isScheduler.js");
var fromArray_1 = __webpack_require__(/*! ./fromArray */ "./node_modules/rxjs/internal/observable/fromArray.js");
var scheduleArray_1 = __webpack_require__(/*! ../scheduled/scheduleArray */ "./node_modules/rxjs/internal/scheduled/scheduleArray.js");
function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var scheduler = args[args.length - 1];
    if (isScheduler_1.isScheduler(scheduler)) {
        args.pop();
        return scheduleArray_1.scheduleArray(args, scheduler);
    }
    else {
        return fromArray_1.fromArray(args);
    }
}
exports.of = of;
//# sourceMappingURL=of.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/observable/throwError.js":
/*!*************************************************************!*\
  !*** ./node_modules/rxjs/internal/observable/throwError.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/internal/Observable.js");
function throwError(error, scheduler) {
    if (!scheduler) {
        return new Observable_1.Observable(function (subscriber) { return subscriber.error(error); });
    }
    else {
        return new Observable_1.Observable(function (subscriber) { return scheduler.schedule(dispatch, 0, { error: error, subscriber: subscriber }); });
    }
}
exports.throwError = throwError;
function dispatch(_a) {
    var error = _a.error, subscriber = _a.subscriber;
    subscriber.error(error);
}
//# sourceMappingURL=throwError.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/bufferTime.js":
/*!************************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/bufferTime.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = __webpack_require__(/*! ../scheduler/async */ "./node_modules/rxjs/internal/scheduler/async.js");
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
var isScheduler_1 = __webpack_require__(/*! ../util/isScheduler */ "./node_modules/rxjs/internal/util/isScheduler.js");
function bufferTime(bufferTimeSpan) {
    var length = arguments.length;
    var scheduler = async_1.async;
    if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {
        scheduler = arguments[arguments.length - 1];
        length--;
    }
    var bufferCreationInterval = null;
    if (length >= 2) {
        bufferCreationInterval = arguments[1];
    }
    var maxBufferSize = Number.POSITIVE_INFINITY;
    if (length >= 3) {
        maxBufferSize = arguments[2];
    }
    return function bufferTimeOperatorFunction(source) {
        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
    };
}
exports.bufferTime = bufferTime;
var BufferTimeOperator = (function () {
    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
    }
    BufferTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
    };
    return BufferTimeOperator;
}());
var Context = (function () {
    function Context() {
        this.buffer = [];
    }
    return Context;
}());
var BufferTimeSubscriber = (function (_super) {
    __extends(BufferTimeSubscriber, _super);
    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.bufferTimeSpan = bufferTimeSpan;
        _this.bufferCreationInterval = bufferCreationInterval;
        _this.maxBufferSize = maxBufferSize;
        _this.scheduler = scheduler;
        _this.contexts = [];
        var context = _this.openContext();
        _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
        if (_this.timespanOnly) {
            var timeSpanOnlyState = { subscriber: _this, context: context, bufferTimeSpan: bufferTimeSpan };
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
        else {
            var closeState = { subscriber: _this, context: context };
            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: _this, scheduler: scheduler };
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        }
        return _this;
    }
    BufferTimeSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        var filledBufferContext;
        for (var i = 0; i < len; i++) {
            var context_1 = contexts[i];
            var buffer = context_1.buffer;
            buffer.push(value);
            if (buffer.length == this.maxBufferSize) {
                filledBufferContext = context_1;
            }
        }
        if (filledBufferContext) {
            this.onBufferFull(filledBufferContext);
        }
    };
    BufferTimeSubscriber.prototype._error = function (err) {
        this.contexts.length = 0;
        _super.prototype._error.call(this, err);
    };
    BufferTimeSubscriber.prototype._complete = function () {
        var _a = this, contexts = _a.contexts, destination = _a.destination;
        while (contexts.length > 0) {
            var context_2 = contexts.shift();
            destination.next(context_2.buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferTimeSubscriber.prototype._unsubscribe = function () {
        this.contexts = null;
    };
    BufferTimeSubscriber.prototype.onBufferFull = function (context) {
        this.closeContext(context);
        var closeAction = context.closeAction;
        closeAction.unsubscribe();
        this.remove(closeAction);
        if (!this.closed && this.timespanOnly) {
            context = this.openContext();
            var bufferTimeSpan = this.bufferTimeSpan;
            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
    };
    BufferTimeSubscriber.prototype.openContext = function () {
        var context = new Context();
        this.contexts.push(context);
        return context;
    };
    BufferTimeSubscriber.prototype.closeContext = function (context) {
        this.destination.next(context.buffer);
        var contexts = this.contexts;
        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
        if (spliceIndex >= 0) {
            contexts.splice(contexts.indexOf(context), 1);
        }
    };
    return BufferTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchBufferTimeSpanOnly(state) {
    var subscriber = state.subscriber;
    var prevContext = state.context;
    if (prevContext) {
        subscriber.closeContext(prevContext);
    }
    if (!subscriber.closed) {
        state.context = subscriber.openContext();
        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
    }
}
function dispatchBufferCreation(state) {
    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
    var context = subscriber.openContext();
    var action = this;
    if (!subscriber.closed) {
        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));
        action.schedule(state, bufferCreationInterval);
    }
}
function dispatchBufferClose(arg) {
    var subscriber = arg.subscriber, context = arg.context;
    subscriber.closeContext(context);
}
//# sourceMappingURL=bufferTime.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/catchError.js":
/*!************************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/catchError.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/internal/OuterSubscriber.js");
var InnerSubscriber_1 = __webpack_require__(/*! ../InnerSubscriber */ "./node_modules/rxjs/internal/InnerSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/internal/util/subscribeToResult.js");
function catchError(selector) {
    return function catchErrorOperatorFunction(source) {
        var operator = new CatchOperator(selector);
        var caught = source.lift(operator);
        return (operator.caught = caught);
    };
}
exports.catchError = catchError;
var CatchOperator = (function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}());
var CatchSubscriber = (function (_super) {
    __extends(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        var _this = _super.call(this, destination) || this;
        _this.selector = selector;
        _this.caught = caught;
        return _this;
    }
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            }
            catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            var innerSubscriber = new InnerSubscriber_1.InnerSubscriber(this, undefined, undefined);
            this.add(innerSubscriber);
            subscribeToResult_1.subscribeToResult(this, result, undefined, undefined, innerSubscriber);
        }
    };
    return CatchSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=catchError.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/concatAll.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/concatAll.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var mergeAll_1 = __webpack_require__(/*! ./mergeAll */ "./node_modules/rxjs/internal/operators/mergeAll.js");
function concatAll() {
    return mergeAll_1.mergeAll(1);
}
exports.concatAll = concatAll;
//# sourceMappingURL=concatAll.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/concatMap.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/concatMap.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var mergeMap_1 = __webpack_require__(/*! ./mergeMap */ "./node_modules/rxjs/internal/operators/mergeMap.js");
function concatMap(project, resultSelector) {
    return mergeMap_1.mergeMap(project, resultSelector, 1);
}
exports.concatMap = concatMap;
//# sourceMappingURL=concatMap.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/debounceTime.js":
/*!**************************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/debounceTime.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
var async_1 = __webpack_require__(/*! ../scheduler/async */ "./node_modules/rxjs/internal/scheduler/async.js");
function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };
}
exports.debounceTime = debounceTime;
var DebounceTimeOperator = (function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}());
var DebounceTimeSubscriber = (function (_super) {
    __extends(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.dueTime = dueTime;
        _this.scheduler = scheduler;
        _this.debouncedSubscription = null;
        _this.lastValue = null;
        _this.hasValue = false;
        return _this;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            var lastValue = this.lastValue;
            this.lastValue = null;
            this.hasValue = false;
            this.destination.next(lastValue);
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNext(subscriber) {
    subscriber.debouncedNext();
}
//# sourceMappingURL=debounceTime.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/defaultIfEmpty.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/defaultIfEmpty.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
function defaultIfEmpty(defaultValue) {
    if (defaultValue === void 0) { defaultValue = null; }
    return function (source) { return source.lift(new DefaultIfEmptyOperator(defaultValue)); };
}
exports.defaultIfEmpty = defaultIfEmpty;
var DefaultIfEmptyOperator = (function () {
    function DefaultIfEmptyOperator(defaultValue) {
        this.defaultValue = defaultValue;
    }
    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
    };
    return DefaultIfEmptyOperator;
}());
var DefaultIfEmptySubscriber = (function (_super) {
    __extends(DefaultIfEmptySubscriber, _super);
    function DefaultIfEmptySubscriber(destination, defaultValue) {
        var _this = _super.call(this, destination) || this;
        _this.defaultValue = defaultValue;
        _this.isEmpty = true;
        return _this;
    }
    DefaultIfEmptySubscriber.prototype._next = function (value) {
        this.isEmpty = false;
        this.destination.next(value);
    };
    DefaultIfEmptySubscriber.prototype._complete = function () {
        if (this.isEmpty) {
            this.destination.next(this.defaultValue);
        }
        this.destination.complete();
    };
    return DefaultIfEmptySubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=defaultIfEmpty.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/delay.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/delay.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = __webpack_require__(/*! ../scheduler/async */ "./node_modules/rxjs/internal/scheduler/async.js");
var isDate_1 = __webpack_require__(/*! ../util/isDate */ "./node_modules/rxjs/internal/util/isDate.js");
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
var Notification_1 = __webpack_require__(/*! ../Notification */ "./node_modules/rxjs/internal/Notification.js");
function delay(delay, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    var absoluteDelay = isDate_1.isDate(delay);
    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);
    return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };
}
exports.delay = delay;
var DelayOperator = (function () {
    function DelayOperator(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
    }
    DelayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator;
}());
var DelaySubscriber = (function (_super) {
    __extends(DelaySubscriber, _super);
    function DelaySubscriber(destination, delay, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.delay = delay;
        _this.scheduler = scheduler;
        _this.queue = [];
        _this.active = false;
        _this.errored = false;
        return _this;
    }
    DelaySubscriber.dispatch = function (state) {
        var source = state.source;
        var queue = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, delay_1);
        }
        else {
            this.unsubscribe();
            source.active = false;
        }
    };
    DelaySubscriber.prototype._schedule = function (scheduler) {
        this.active = true;
        var destination = this.destination;
        destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    };
    DelaySubscriber.prototype.scheduleNotification = function (notification) {
        if (this.errored === true) {
            return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };
    DelaySubscriber.prototype._next = function (value) {
        this.scheduleNotification(Notification_1.Notification.createNext(value));
    };
    DelaySubscriber.prototype._error = function (err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
        this.unsubscribe();
    };
    DelaySubscriber.prototype._complete = function () {
        this.scheduleNotification(Notification_1.Notification.createComplete());
        this.unsubscribe();
    };
    return DelaySubscriber;
}(Subscriber_1.Subscriber));
var DelayMessage = (function () {
    function DelayMessage(time, notification) {
        this.time = time;
        this.notification = notification;
    }
    return DelayMessage;
}());
//# sourceMappingURL=delay.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/distinctUntilChanged.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/distinctUntilChanged.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
function distinctUntilChanged(compare, keySelector) {
    return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };
}
exports.distinctUntilChanged = distinctUntilChanged;
var DistinctUntilChangedOperator = (function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}());
var DistinctUntilChangedSubscriber = (function (_super) {
    __extends(DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.hasKey = false;
        if (typeof compare === 'function') {
            _this.compare = compare;
        }
        return _this;
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var key;
        try {
            var keySelector = this.keySelector;
            key = keySelector ? keySelector(value) : value;
        }
        catch (err) {
            return this.destination.error(err);
        }
        var result = false;
        if (this.hasKey) {
            try {
                var compare = this.compare;
                result = compare(this.key, key);
            }
            catch (err) {
                return this.destination.error(err);
            }
        }
        else {
            this.hasKey = true;
        }
        if (!result) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=distinctUntilChanged.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/filter.js":
/*!********************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/filter.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
    };
}
exports.filter = filter;
var FilterOperator = (function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}());
var FilterSubscriber = (function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.count = 0;
        return _this;
    }
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=filter.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/finalize.js":
/*!**********************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/finalize.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
var Subscription_1 = __webpack_require__(/*! ../Subscription */ "./node_modules/rxjs/internal/Subscription.js");
function finalize(callback) {
    return function (source) { return source.lift(new FinallyOperator(callback)); };
}
exports.finalize = finalize;
var FinallyOperator = (function () {
    function FinallyOperator(callback) {
        this.callback = callback;
    }
    FinallyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
    };
    return FinallyOperator;
}());
var FinallySubscriber = (function (_super) {
    __extends(FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        var _this = _super.call(this, destination) || this;
        _this.add(new Subscription_1.Subscription(callback));
        return _this;
    }
    return FinallySubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=finalize.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/first.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/first.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var EmptyError_1 = __webpack_require__(/*! ../util/EmptyError */ "./node_modules/rxjs/internal/util/EmptyError.js");
var filter_1 = __webpack_require__(/*! ./filter */ "./node_modules/rxjs/internal/operators/filter.js");
var take_1 = __webpack_require__(/*! ./take */ "./node_modules/rxjs/internal/operators/take.js");
var defaultIfEmpty_1 = __webpack_require__(/*! ./defaultIfEmpty */ "./node_modules/rxjs/internal/operators/defaultIfEmpty.js");
var throwIfEmpty_1 = __webpack_require__(/*! ./throwIfEmpty */ "./node_modules/rxjs/internal/operators/throwIfEmpty.js");
var identity_1 = __webpack_require__(/*! ../util/identity */ "./node_modules/rxjs/internal/util/identity.js");
function first(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function (source) { return source.pipe(predicate ? filter_1.filter(function (v, i) { return predicate(v, i, source); }) : identity_1.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function () { return new EmptyError_1.EmptyError(); })); };
}
exports.first = first;
//# sourceMappingURL=first.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/groupBy.js":
/*!*********************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/groupBy.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
var Subscription_1 = __webpack_require__(/*! ../Subscription */ "./node_modules/rxjs/internal/Subscription.js");
var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/internal/Observable.js");
var Subject_1 = __webpack_require__(/*! ../Subject */ "./node_modules/rxjs/internal/Subject.js");
function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
    return function (source) {
        return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
    };
}
exports.groupBy = groupBy;
var GroupByOperator = (function () {
    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
    }
    GroupByOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
    };
    return GroupByOperator;
}());
var GroupBySubscriber = (function (_super) {
    __extends(GroupBySubscriber, _super);
    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.elementSelector = elementSelector;
        _this.durationSelector = durationSelector;
        _this.subjectSelector = subjectSelector;
        _this.groups = null;
        _this.attemptedToUnsubscribe = false;
        _this.count = 0;
        return _this;
    }
    GroupBySubscriber.prototype._next = function (value) {
        var key;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            this.error(err);
            return;
        }
        this._group(value, key);
    };
    GroupBySubscriber.prototype._group = function (value, key) {
        var groups = this.groups;
        if (!groups) {
            groups = this.groups = new Map();
        }
        var group = groups.get(key);
        var element;
        if (this.elementSelector) {
            try {
                element = this.elementSelector(value);
            }
            catch (err) {
                this.error(err);
            }
        }
        else {
            element = value;
        }
        if (!group) {
            group = (this.subjectSelector ? this.subjectSelector() : new Subject_1.Subject());
            groups.set(key, group);
            var groupedObservable = new GroupedObservable(key, group, this);
            this.destination.next(groupedObservable);
            if (this.durationSelector) {
                var duration = void 0;
                try {
                    duration = this.durationSelector(new GroupedObservable(key, group));
                }
                catch (err) {
                    this.error(err);
                    return;
                }
                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
            }
        }
        if (!group.closed) {
            group.next(element);
        }
    };
    GroupBySubscriber.prototype._error = function (err) {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.error(err);
            });
            groups.clear();
        }
        this.destination.error(err);
    };
    GroupBySubscriber.prototype._complete = function () {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.complete();
            });
            groups.clear();
        }
        this.destination.complete();
    };
    GroupBySubscriber.prototype.removeGroup = function (key) {
        this.groups.delete(key);
    };
    GroupBySubscriber.prototype.unsubscribe = function () {
        if (!this.closed) {
            this.attemptedToUnsubscribe = true;
            if (this.count === 0) {
                _super.prototype.unsubscribe.call(this);
            }
        }
    };
    return GroupBySubscriber;
}(Subscriber_1.Subscriber));
var GroupDurationSubscriber = (function (_super) {
    __extends(GroupDurationSubscriber, _super);
    function GroupDurationSubscriber(key, group, parent) {
        var _this = _super.call(this, group) || this;
        _this.key = key;
        _this.group = group;
        _this.parent = parent;
        return _this;
    }
    GroupDurationSubscriber.prototype._next = function (value) {
        this.complete();
    };
    GroupDurationSubscriber.prototype._unsubscribe = function () {
        var _a = this, parent = _a.parent, key = _a.key;
        this.key = this.parent = null;
        if (parent) {
            parent.removeGroup(key);
        }
    };
    return GroupDurationSubscriber;
}(Subscriber_1.Subscriber));
var GroupedObservable = (function (_super) {
    __extends(GroupedObservable, _super);
    function GroupedObservable(key, groupSubject, refCountSubscription) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.groupSubject = groupSubject;
        _this.refCountSubscription = refCountSubscription;
        return _this;
    }
    GroupedObservable.prototype._subscribe = function (subscriber) {
        var subscription = new Subscription_1.Subscription();
        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) {
            subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
    };
    return GroupedObservable;
}(Observable_1.Observable));
exports.GroupedObservable = GroupedObservable;
var InnerRefCountSubscription = (function (_super) {
    __extends(InnerRefCountSubscription, _super);
    function InnerRefCountSubscription(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        parent.count++;
        return _this;
    }
    InnerRefCountSubscription.prototype.unsubscribe = function () {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
            _super.prototype.unsubscribe.call(this);
            parent.count -= 1;
            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                parent.unsubscribe();
            }
        }
    };
    return InnerRefCountSubscription;
}(Subscription_1.Subscription));
//# sourceMappingURL=groupBy.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/last.js":
/*!******************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/last.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var EmptyError_1 = __webpack_require__(/*! ../util/EmptyError */ "./node_modules/rxjs/internal/util/EmptyError.js");
var filter_1 = __webpack_require__(/*! ./filter */ "./node_modules/rxjs/internal/operators/filter.js");
var takeLast_1 = __webpack_require__(/*! ./takeLast */ "./node_modules/rxjs/internal/operators/takeLast.js");
var throwIfEmpty_1 = __webpack_require__(/*! ./throwIfEmpty */ "./node_modules/rxjs/internal/operators/throwIfEmpty.js");
var defaultIfEmpty_1 = __webpack_require__(/*! ./defaultIfEmpty */ "./node_modules/rxjs/internal/operators/defaultIfEmpty.js");
var identity_1 = __webpack_require__(/*! ../util/identity */ "./node_modules/rxjs/internal/util/identity.js");
function last(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function (source) { return source.pipe(predicate ? filter_1.filter(function (v, i) { return predicate(v, i, source); }) : identity_1.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function () { return new EmptyError_1.EmptyError(); })); };
}
exports.last = last;
//# sourceMappingURL=last.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/map.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/map.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
exports.map = map;
var MapOperator = (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());
exports.MapOperator = MapOperator;
var MapSubscriber = (function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=map.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/mapTo.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/mapTo.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
function mapTo(value) {
    return function (source) { return source.lift(new MapToOperator(value)); };
}
exports.mapTo = mapTo;
var MapToOperator = (function () {
    function MapToOperator(value) {
        this.value = value;
    }
    MapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapToSubscriber(subscriber, this.value));
    };
    return MapToOperator;
}());
var MapToSubscriber = (function (_super) {
    __extends(MapToSubscriber, _super);
    function MapToSubscriber(destination, value) {
        var _this = _super.call(this, destination) || this;
        _this.value = value;
        return _this;
    }
    MapToSubscriber.prototype._next = function (x) {
        this.destination.next(this.value);
    };
    return MapToSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=mapTo.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/mergeAll.js":
/*!**********************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/mergeAll.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var mergeMap_1 = __webpack_require__(/*! ./mergeMap */ "./node_modules/rxjs/internal/operators/mergeMap.js");
var identity_1 = __webpack_require__(/*! ../util/identity */ "./node_modules/rxjs/internal/util/identity.js");
function mergeAll(concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return mergeMap_1.mergeMap(identity_1.identity, concurrent);
}
exports.mergeAll = mergeAll;
//# sourceMappingURL=mergeAll.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/mergeMap.js":
/*!**********************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/mergeMap.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/internal/util/subscribeToResult.js");
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/internal/OuterSubscriber.js");
var InnerSubscriber_1 = __webpack_require__(/*! ../InnerSubscriber */ "./node_modules/rxjs/internal/InnerSubscriber.js");
var map_1 = __webpack_require__(/*! ./map */ "./node_modules/rxjs/internal/operators/map.js");
var from_1 = __webpack_require__(/*! ../observable/from */ "./node_modules/rxjs/internal/observable/from.js");
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(mergeMap(function (a, i) { return from_1.from(project(a, i)).pipe(map_1.map(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };
    }
    else if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };
}
exports.mergeMap = mergeMap;
var MergeMapOperator = (function () {
    function MergeMapOperator(project, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        this.project = project;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
    };
    return MergeMapOperator;
}());
exports.MergeMapOperator = MergeMapOperator;
var MergeMapSubscriber = (function (_super) {
    __extends(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result, value, index);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        var innerSubscriber = new InnerSubscriber_1.InnerSubscriber(this, undefined, undefined);
        var destination = this.destination;
        destination.add(innerSubscriber);
        subscribeToResult_1.subscribeToResult(this, ish, value, index, innerSubscriber);
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.MergeMapSubscriber = MergeMapSubscriber;
//# sourceMappingURL=mergeMap.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/observeOn.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/observeOn.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
var Notification_1 = __webpack_require__(/*! ../Notification */ "./node_modules/rxjs/internal/Notification.js");
function observeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return function observeOnOperatorFunction(source) {
        return source.lift(new ObserveOnOperator(scheduler, delay));
    };
}
exports.observeOn = observeOn;
var ObserveOnOperator = (function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}());
exports.ObserveOnOperator = ObserveOnOperator;
var ObserveOnSubscriber = (function (_super) {
    __extends(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        var _this = _super.call(this, destination) || this;
        _this.scheduler = scheduler;
        _this.delay = delay;
        return _this;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        var destination = this.destination;
        destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification_1.Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification_1.Notification.createError(err));
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification_1.Notification.createComplete());
        this.unsubscribe();
    };
    return ObserveOnSubscriber;
}(Subscriber_1.Subscriber));
exports.ObserveOnSubscriber = ObserveOnSubscriber;
var ObserveOnMessage = (function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}());
exports.ObserveOnMessage = ObserveOnMessage;
//# sourceMappingURL=observeOn.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/pairwise.js":
/*!**********************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/pairwise.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
function pairwise() {
    return function (source) { return source.lift(new PairwiseOperator()); };
}
exports.pairwise = pairwise;
var PairwiseOperator = (function () {
    function PairwiseOperator() {
    }
    PairwiseOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
    };
    return PairwiseOperator;
}());
var PairwiseSubscriber = (function (_super) {
    __extends(PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasPrev = false;
        return _this;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        var pair;
        if (this.hasPrev) {
            pair = [this.prev, value];
        }
        else {
            this.hasPrev = true;
        }
        this.prev = value;
        if (pair) {
            this.destination.next(pair);
        }
    };
    return PairwiseSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=pairwise.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/reduce.js":
/*!********************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/reduce.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var scan_1 = __webpack_require__(/*! ./scan */ "./node_modules/rxjs/internal/operators/scan.js");
var takeLast_1 = __webpack_require__(/*! ./takeLast */ "./node_modules/rxjs/internal/operators/takeLast.js");
var defaultIfEmpty_1 = __webpack_require__(/*! ./defaultIfEmpty */ "./node_modules/rxjs/internal/operators/defaultIfEmpty.js");
var pipe_1 = __webpack_require__(/*! ../util/pipe */ "./node_modules/rxjs/internal/util/pipe.js");
function reduce(accumulator, seed) {
    if (arguments.length >= 2) {
        return function reduceOperatorFunctionWithSeed(source) {
            return pipe_1.pipe(scan_1.scan(accumulator, seed), takeLast_1.takeLast(1), defaultIfEmpty_1.defaultIfEmpty(seed))(source);
        };
    }
    return function reduceOperatorFunction(source) {
        return pipe_1.pipe(scan_1.scan(function (acc, value, index) { return accumulator(acc, value, index + 1); }), takeLast_1.takeLast(1))(source);
    };
}
exports.reduce = reduce;
//# sourceMappingURL=reduce.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/scan.js":
/*!******************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/scan.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
function scan(accumulator, seed) {
    var hasSeed = false;
    if (arguments.length >= 2) {
        hasSeed = true;
    }
    return function scanOperatorFunction(source) {
        return source.lift(new ScanOperator(accumulator, seed, hasSeed));
    };
}
exports.scan = scan;
var ScanOperator = (function () {
    function ScanOperator(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) { hasSeed = false; }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
    }
    ScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ScanOperator;
}());
var ScanSubscriber = (function (_super) {
    __extends(ScanSubscriber, _super);
    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this._seed = _seed;
        _this.hasSeed = hasSeed;
        _this.index = 0;
        return _this;
    }
    Object.defineProperty(ScanSubscriber.prototype, "seed", {
        get: function () {
            return this._seed;
        },
        set: function (value) {
            this.hasSeed = true;
            this._seed = value;
        },
        enumerable: true,
        configurable: true
    });
    ScanSubscriber.prototype._next = function (value) {
        if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
        }
        else {
            return this._tryNext(value);
        }
    };
    ScanSubscriber.prototype._tryNext = function (value) {
        var index = this.index++;
        var result;
        try {
            result = this.accumulator(this.seed, value, index);
        }
        catch (err) {
            this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
    };
    return ScanSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=scan.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/shareReplay.js":
/*!*************************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/shareReplay.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ReplaySubject_1 = __webpack_require__(/*! ../ReplaySubject */ "./node_modules/rxjs/internal/ReplaySubject.js");
function shareReplay(configOrBufferSize, windowTime, scheduler) {
    var config;
    if (configOrBufferSize && typeof configOrBufferSize === 'object') {
        config = configOrBufferSize;
    }
    else {
        config = {
            bufferSize: configOrBufferSize,
            windowTime: windowTime,
            refCount: false,
            scheduler: scheduler
        };
    }
    return function (source) { return source.lift(shareReplayOperator(config)); };
}
exports.shareReplay = shareReplay;
function shareReplayOperator(_a) {
    var _b = _a.bufferSize, bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b, _c = _a.windowTime, windowTime = _c === void 0 ? Number.POSITIVE_INFINITY : _c, useRefCount = _a.refCount, scheduler = _a.scheduler;
    var subject;
    var refCount = 0;
    var subscription;
    var hasError = false;
    var isComplete = false;
    return function shareReplayOperation(source) {
        refCount++;
        if (!subject || hasError) {
            hasError = false;
            subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
            subscription = source.subscribe({
                next: function (value) { subject.next(value); },
                error: function (err) {
                    hasError = true;
                    subject.error(err);
                },
                complete: function () {
                    isComplete = true;
                    subject.complete();
                },
            });
        }
        var innerSub = subject.subscribe(this);
        this.add(function () {
            refCount--;
            innerSub.unsubscribe();
            if (subscription && !isComplete && useRefCount && refCount === 0) {
                subscription.unsubscribe();
                subscription = undefined;
                subject = undefined;
            }
        });
    };
}
//# sourceMappingURL=shareReplay.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/skip.js":
/*!******************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/skip.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
function skip(count) {
    return function (source) { return source.lift(new SkipOperator(count)); };
}
exports.skip = skip;
var SkipOperator = (function () {
    function SkipOperator(total) {
        this.total = total;
    }
    SkipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipSubscriber(subscriber, this.total));
    };
    return SkipOperator;
}());
var SkipSubscriber = (function (_super) {
    __extends(SkipSubscriber, _super);
    function SkipSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    SkipSubscriber.prototype._next = function (x) {
        if (++this.count > this.total) {
            this.destination.next(x);
        }
    };
    return SkipSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=skip.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/skipUntil.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/skipUntil.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/internal/OuterSubscriber.js");
var InnerSubscriber_1 = __webpack_require__(/*! ../InnerSubscriber */ "./node_modules/rxjs/internal/InnerSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/internal/util/subscribeToResult.js");
function skipUntil(notifier) {
    return function (source) { return source.lift(new SkipUntilOperator(notifier)); };
}
exports.skipUntil = skipUntil;
var SkipUntilOperator = (function () {
    function SkipUntilOperator(notifier) {
        this.notifier = notifier;
    }
    SkipUntilOperator.prototype.call = function (destination, source) {
        return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
    };
    return SkipUntilOperator;
}());
var SkipUntilSubscriber = (function (_super) {
    __extends(SkipUntilSubscriber, _super);
    function SkipUntilSubscriber(destination, notifier) {
        var _this = _super.call(this, destination) || this;
        _this.hasValue = false;
        var innerSubscriber = new InnerSubscriber_1.InnerSubscriber(_this, undefined, undefined);
        _this.add(innerSubscriber);
        _this.innerSubscription = innerSubscriber;
        subscribeToResult_1.subscribeToResult(_this, notifier, undefined, undefined, innerSubscriber);
        return _this;
    }
    SkipUntilSubscriber.prototype._next = function (value) {
        if (this.hasValue) {
            _super.prototype._next.call(this, value);
        }
    };
    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.hasValue = true;
        if (this.innerSubscription) {
            this.innerSubscription.unsubscribe();
        }
    };
    SkipUntilSubscriber.prototype.notifyComplete = function () {
    };
    return SkipUntilSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=skipUntil.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/skipWhile.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/skipWhile.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
function skipWhile(predicate) {
    return function (source) { return source.lift(new SkipWhileOperator(predicate)); };
}
exports.skipWhile = skipWhile;
var SkipWhileOperator = (function () {
    function SkipWhileOperator(predicate) {
        this.predicate = predicate;
    }
    SkipWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
    };
    return SkipWhileOperator;
}());
var SkipWhileSubscriber = (function (_super) {
    __extends(SkipWhileSubscriber, _super);
    function SkipWhileSubscriber(destination, predicate) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.skipping = true;
        _this.index = 0;
        return _this;
    }
    SkipWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (this.skipping) {
            this.tryCallPredicate(value);
        }
        if (!this.skipping) {
            destination.next(value);
        }
    };
    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
        try {
            var result = this.predicate(value, this.index++);
            this.skipping = Boolean(result);
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    return SkipWhileSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=skipWhile.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/startWith.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/startWith.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var concat_1 = __webpack_require__(/*! ../observable/concat */ "./node_modules/rxjs/internal/observable/concat.js");
var isScheduler_1 = __webpack_require__(/*! ../util/isScheduler */ "./node_modules/rxjs/internal/util/isScheduler.js");
function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i] = arguments[_i];
    }
    var scheduler = array[array.length - 1];
    if (isScheduler_1.isScheduler(scheduler)) {
        array.pop();
        return function (source) { return concat_1.concat(array, source, scheduler); };
    }
    else {
        return function (source) { return concat_1.concat(array, source); };
    }
}
exports.startWith = startWith;
//# sourceMappingURL=startWith.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/switchMap.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/switchMap.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/internal/OuterSubscriber.js");
var InnerSubscriber_1 = __webpack_require__(/*! ../InnerSubscriber */ "./node_modules/rxjs/internal/InnerSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/internal/util/subscribeToResult.js");
var map_1 = __webpack_require__(/*! ./map */ "./node_modules/rxjs/internal/operators/map.js");
var from_1 = __webpack_require__(/*! ../observable/from */ "./node_modules/rxjs/internal/observable/from.js");
function switchMap(project, resultSelector) {
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(switchMap(function (a, i) { return from_1.from(project(a, i)).pipe(map_1.map(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };
    }
    return function (source) { return source.lift(new SwitchMapOperator(project)); };
}
exports.switchMap = switchMap;
var SwitchMapOperator = (function () {
    function SwitchMapOperator(project) {
        this.project = project;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
    };
    return SwitchMapOperator;
}());
var SwitchMapSubscriber = (function (_super) {
    __extends(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.index = 0;
        return _this;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result, value, index);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        var innerSubscriber = new InnerSubscriber_1.InnerSubscriber(this, undefined, undefined);
        var destination = this.destination;
        destination.add(innerSubscriber);
        this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index, innerSubscriber);
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
        this.unsubscribe();
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var destination = this.destination;
        destination.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    return SwitchMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=switchMap.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/take.js":
/*!******************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/take.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
var ArgumentOutOfRangeError_1 = __webpack_require__(/*! ../util/ArgumentOutOfRangeError */ "./node_modules/rxjs/internal/util/ArgumentOutOfRangeError.js");
var empty_1 = __webpack_require__(/*! ../observable/empty */ "./node_modules/rxjs/internal/observable/empty.js");
function take(count) {
    return function (source) {
        if (count === 0) {
            return empty_1.empty();
        }
        else {
            return source.lift(new TakeOperator(count));
        }
    };
}
exports.take = take;
var TakeOperator = (function () {
    function TakeOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    TakeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator;
}());
var TakeSubscriber = (function (_super) {
    __extends(TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=take.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/takeLast.js":
/*!**********************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/takeLast.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
var ArgumentOutOfRangeError_1 = __webpack_require__(/*! ../util/ArgumentOutOfRangeError */ "./node_modules/rxjs/internal/util/ArgumentOutOfRangeError.js");
var empty_1 = __webpack_require__(/*! ../observable/empty */ "./node_modules/rxjs/internal/observable/empty.js");
function takeLast(count) {
    return function takeLastOperatorFunction(source) {
        if (count === 0) {
            return empty_1.empty();
        }
        else {
            return source.lift(new TakeLastOperator(count));
        }
    };
}
exports.takeLast = takeLast;
var TakeLastOperator = (function () {
    function TakeLastOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    TakeLastOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
    };
    return TakeLastOperator;
}());
var TakeLastSubscriber = (function (_super) {
    __extends(TakeLastSubscriber, _super);
    function TakeLastSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.ring = new Array();
        _this.count = 0;
        return _this;
    }
    TakeLastSubscriber.prototype._next = function (value) {
        var ring = this.ring;
        var total = this.total;
        var count = this.count++;
        if (ring.length < total) {
            ring.push(value);
        }
        else {
            var index = count % total;
            ring[index] = value;
        }
    };
    TakeLastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        var count = this.count;
        if (count > 0) {
            var total = this.count >= this.total ? this.total : this.count;
            var ring = this.ring;
            for (var i = 0; i < total; i++) {
                var idx = (count++) % total;
                destination.next(ring[idx]);
            }
        }
        destination.complete();
    };
    return TakeLastSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=takeLast.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/takeUntil.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/takeUntil.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/internal/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/internal/util/subscribeToResult.js");
function takeUntil(notifier) {
    return function (source) { return source.lift(new TakeUntilOperator(notifier)); };
}
exports.takeUntil = takeUntil;
var TakeUntilOperator = (function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
        var notifierSubscription = subscribeToResult_1.subscribeToResult(takeUntilSubscriber, this.notifier);
        if (notifierSubscription && !takeUntilSubscriber.seenValue) {
            takeUntilSubscriber.add(notifierSubscription);
            return source.subscribe(takeUntilSubscriber);
        }
        return takeUntilSubscriber;
    };
    return TakeUntilOperator;
}());
var TakeUntilSubscriber = (function (_super) {
    __extends(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.seenValue = false;
        return _this;
    }
    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.seenValue = true;
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
    };
    return TakeUntilSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=takeUntil.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/tap.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/tap.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
var noop_1 = __webpack_require__(/*! ../util/noop */ "./node_modules/rxjs/internal/util/noop.js");
var isFunction_1 = __webpack_require__(/*! ../util/isFunction */ "./node_modules/rxjs/internal/util/isFunction.js");
function tap(nextOrObserver, error, complete) {
    return function tapOperatorFunction(source) {
        return source.lift(new DoOperator(nextOrObserver, error, complete));
    };
}
exports.tap = tap;
var DoOperator = (function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}());
var TapSubscriber = (function (_super) {
    __extends(TapSubscriber, _super);
    function TapSubscriber(destination, observerOrNext, error, complete) {
        var _this = _super.call(this, destination) || this;
        _this._tapNext = noop_1.noop;
        _this._tapError = noop_1.noop;
        _this._tapComplete = noop_1.noop;
        _this._tapError = error || noop_1.noop;
        _this._tapComplete = complete || noop_1.noop;
        if (isFunction_1.isFunction(observerOrNext)) {
            _this._context = _this;
            _this._tapNext = observerOrNext;
        }
        else if (observerOrNext) {
            _this._context = observerOrNext;
            _this._tapNext = observerOrNext.next || noop_1.noop;
            _this._tapError = observerOrNext.error || noop_1.noop;
            _this._tapComplete = observerOrNext.complete || noop_1.noop;
        }
        return _this;
    }
    TapSubscriber.prototype._next = function (value) {
        try {
            this._tapNext.call(this._context, value);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(value);
    };
    TapSubscriber.prototype._error = function (err) {
        try {
            this._tapError.call(this._context, err);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.error(err);
    };
    TapSubscriber.prototype._complete = function () {
        try {
            this._tapComplete.call(this._context);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        return this.destination.complete();
    };
    return TapSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=tap.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/throttle.js":
/*!**********************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/throttle.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/internal/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/internal/util/subscribeToResult.js");
exports.defaultThrottleConfig = {
    leading: true,
    trailing: false
};
function throttle(durationSelector, config) {
    if (config === void 0) { config = exports.defaultThrottleConfig; }
    return function (source) { return source.lift(new ThrottleOperator(durationSelector, config.leading, config.trailing)); };
}
exports.throttle = throttle;
var ThrottleOperator = (function () {
    function ThrottleOperator(durationSelector, leading, trailing) {
        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
    };
    return ThrottleOperator;
}());
var ThrottleSubscriber = (function (_super) {
    __extends(ThrottleSubscriber, _super);
    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.durationSelector = durationSelector;
        _this._leading = _leading;
        _this._trailing = _trailing;
        _this._hasValue = false;
        return _this;
    }
    ThrottleSubscriber.prototype._next = function (value) {
        this._hasValue = true;
        this._sendValue = value;
        if (!this._throttled) {
            if (this._leading) {
                this.send();
            }
            else {
                this.throttle(value);
            }
        }
    };
    ThrottleSubscriber.prototype.send = function () {
        var _a = this, _hasValue = _a._hasValue, _sendValue = _a._sendValue;
        if (_hasValue) {
            this.destination.next(_sendValue);
            this.throttle(_sendValue);
        }
        this._hasValue = false;
        this._sendValue = null;
    };
    ThrottleSubscriber.prototype.throttle = function (value) {
        var duration = this.tryDurationSelector(value);
        if (!!duration) {
            this.add(this._throttled = subscribeToResult_1.subscribeToResult(this, duration));
        }
    };
    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
        try {
            return this.durationSelector(value);
        }
        catch (err) {
            this.destination.error(err);
            return null;
        }
    };
    ThrottleSubscriber.prototype.throttlingDone = function () {
        var _a = this, _throttled = _a._throttled, _trailing = _a._trailing;
        if (_throttled) {
            _throttled.unsubscribe();
        }
        this._throttled = null;
        if (_trailing) {
            this.send();
        }
    };
    ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.throttlingDone();
    };
    ThrottleSubscriber.prototype.notifyComplete = function () {
        this.throttlingDone();
    };
    return ThrottleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=throttle.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/throttleTime.js":
/*!**************************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/throttleTime.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
var async_1 = __webpack_require__(/*! ../scheduler/async */ "./node_modules/rxjs/internal/scheduler/async.js");
var throttle_1 = __webpack_require__(/*! ./throttle */ "./node_modules/rxjs/internal/operators/throttle.js");
function throttleTime(duration, scheduler, config) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    if (config === void 0) { config = throttle_1.defaultThrottleConfig; }
    return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };
}
exports.throttleTime = throttleTime;
var ThrottleTimeOperator = (function () {
    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
    };
    return ThrottleTimeOperator;
}());
var ThrottleTimeSubscriber = (function (_super) {
    __extends(ThrottleTimeSubscriber, _super);
    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
        var _this = _super.call(this, destination) || this;
        _this.duration = duration;
        _this.scheduler = scheduler;
        _this.leading = leading;
        _this.trailing = trailing;
        _this._hasTrailingValue = false;
        _this._trailingValue = null;
        return _this;
    }
    ThrottleTimeSubscriber.prototype._next = function (value) {
        if (this.throttled) {
            if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
        else {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
            if (this.leading) {
                this.destination.next(value);
            }
            else if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
    };
    ThrottleTimeSubscriber.prototype._complete = function () {
        if (this._hasTrailingValue) {
            this.destination.next(this._trailingValue);
            this.destination.complete();
        }
        else {
            this.destination.complete();
        }
    };
    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
        var throttled = this.throttled;
        if (throttled) {
            if (this.trailing && this._hasTrailingValue) {
                this.destination.next(this._trailingValue);
                this._trailingValue = null;
                this._hasTrailingValue = false;
            }
            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
        }
    };
    return ThrottleTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNext(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
}
//# sourceMappingURL=throttleTime.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/throwIfEmpty.js":
/*!**************************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/throwIfEmpty.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var EmptyError_1 = __webpack_require__(/*! ../util/EmptyError */ "./node_modules/rxjs/internal/util/EmptyError.js");
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
function throwIfEmpty(errorFactory) {
    if (errorFactory === void 0) { errorFactory = defaultErrorFactory; }
    return function (source) {
        return source.lift(new ThrowIfEmptyOperator(errorFactory));
    };
}
exports.throwIfEmpty = throwIfEmpty;
var ThrowIfEmptyOperator = (function () {
    function ThrowIfEmptyOperator(errorFactory) {
        this.errorFactory = errorFactory;
    }
    ThrowIfEmptyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
    };
    return ThrowIfEmptyOperator;
}());
var ThrowIfEmptySubscriber = (function (_super) {
    __extends(ThrowIfEmptySubscriber, _super);
    function ThrowIfEmptySubscriber(destination, errorFactory) {
        var _this = _super.call(this, destination) || this;
        _this.errorFactory = errorFactory;
        _this.hasValue = false;
        return _this;
    }
    ThrowIfEmptySubscriber.prototype._next = function (value) {
        this.hasValue = true;
        this.destination.next(value);
    };
    ThrowIfEmptySubscriber.prototype._complete = function () {
        if (!this.hasValue) {
            var err = void 0;
            try {
                err = this.errorFactory();
            }
            catch (e) {
                err = e;
            }
            this.destination.error(err);
        }
        else {
            return this.destination.complete();
        }
    };
    return ThrowIfEmptySubscriber;
}(Subscriber_1.Subscriber));
function defaultErrorFactory() {
    return new EmptyError_1.EmptyError();
}
//# sourceMappingURL=throwIfEmpty.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/toArray.js":
/*!*********************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/toArray.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var reduce_1 = __webpack_require__(/*! ./reduce */ "./node_modules/rxjs/internal/operators/reduce.js");
function toArrayReducer(arr, item, index) {
    if (index === 0) {
        return [item];
    }
    arr.push(item);
    return arr;
}
function toArray() {
    return reduce_1.reduce(toArrayReducer, []);
}
exports.toArray = toArray;
//# sourceMappingURL=toArray.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/withLatestFrom.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/withLatestFrom.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/internal/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/internal/util/subscribeToResult.js");
function withLatestFrom() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return function (source) {
        var project;
        if (typeof args[args.length - 1] === 'function') {
            project = args.pop();
        }
        var observables = args;
        return source.lift(new WithLatestFromOperator(observables, project));
    };
}
exports.withLatestFrom = withLatestFrom;
var WithLatestFromOperator = (function () {
    function WithLatestFromOperator(observables, project) {
        this.observables = observables;
        this.project = project;
    }
    WithLatestFromOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
    };
    return WithLatestFromOperator;
}());
var WithLatestFromSubscriber = (function (_super) {
    __extends(WithLatestFromSubscriber, _super);
    function WithLatestFromSubscriber(destination, observables, project) {
        var _this = _super.call(this, destination) || this;
        _this.observables = observables;
        _this.project = project;
        _this.toRespond = [];
        var len = observables.length;
        _this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            _this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            _this.add(subscribeToResult_1.subscribeToResult(_this, observable, observable, i));
        }
        return _this;
    }
    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };
    WithLatestFromSubscriber.prototype.notifyComplete = function () {
    };
    WithLatestFromSubscriber.prototype._next = function (value) {
        if (this.toRespond.length === 0) {
            var args = [value].concat(this.values);
            if (this.project) {
                this._tryProject(args);
            }
            else {
                this.destination.next(args);
            }
        }
    };
    WithLatestFromSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return WithLatestFromSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=withLatestFrom.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/scheduled/scheduleArray.js":
/*!***************************************************************!*\
  !*** ./node_modules/rxjs/internal/scheduled/scheduleArray.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/internal/Observable.js");
var Subscription_1 = __webpack_require__(/*! ../Subscription */ "./node_modules/rxjs/internal/Subscription.js");
function scheduleArray(input, scheduler) {
    return new Observable_1.Observable(function (subscriber) {
        var sub = new Subscription_1.Subscription();
        var i = 0;
        sub.add(scheduler.schedule(function () {
            if (i === input.length) {
                subscriber.complete();
                return;
            }
            subscriber.next(input[i++]);
            if (!subscriber.closed) {
                sub.add(this.schedule());
            }
        }));
        return sub;
    });
}
exports.scheduleArray = scheduleArray;
//# sourceMappingURL=scheduleArray.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/scheduled/scheduleIterable.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/internal/scheduled/scheduleIterable.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/internal/Observable.js");
var Subscription_1 = __webpack_require__(/*! ../Subscription */ "./node_modules/rxjs/internal/Subscription.js");
var iterator_1 = __webpack_require__(/*! ../symbol/iterator */ "./node_modules/rxjs/internal/symbol/iterator.js");
function scheduleIterable(input, scheduler) {
    if (!input) {
        throw new Error('Iterable cannot be null');
    }
    return new Observable_1.Observable(function (subscriber) {
        var sub = new Subscription_1.Subscription();
        var iterator;
        sub.add(function () {
            if (iterator && typeof iterator.return === 'function') {
                iterator.return();
            }
        });
        sub.add(scheduler.schedule(function () {
            iterator = input[iterator_1.iterator]();
            sub.add(scheduler.schedule(function () {
                if (subscriber.closed) {
                    return;
                }
                var value;
                var done;
                try {
                    var result = iterator.next();
                    value = result.value;
                    done = result.done;
                }
                catch (err) {
                    subscriber.error(err);
                    return;
                }
                if (done) {
                    subscriber.complete();
                }
                else {
                    subscriber.next(value);
                    this.schedule();
                }
            }));
        }));
        return sub;
    });
}
exports.scheduleIterable = scheduleIterable;
//# sourceMappingURL=scheduleIterable.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/scheduled/scheduleObservable.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/internal/scheduled/scheduleObservable.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/internal/Observable.js");
var Subscription_1 = __webpack_require__(/*! ../Subscription */ "./node_modules/rxjs/internal/Subscription.js");
var observable_1 = __webpack_require__(/*! ../symbol/observable */ "./node_modules/rxjs/internal/symbol/observable.js");
function scheduleObservable(input, scheduler) {
    return new Observable_1.Observable(function (subscriber) {
        var sub = new Subscription_1.Subscription();
        sub.add(scheduler.schedule(function () {
            var observable = input[observable_1.observable]();
            sub.add(observable.subscribe({
                next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },
                error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },
                complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },
            }));
        }));
        return sub;
    });
}
exports.scheduleObservable = scheduleObservable;
//# sourceMappingURL=scheduleObservable.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/scheduled/schedulePromise.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/internal/scheduled/schedulePromise.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/internal/Observable.js");
var Subscription_1 = __webpack_require__(/*! ../Subscription */ "./node_modules/rxjs/internal/Subscription.js");
function schedulePromise(input, scheduler) {
    return new Observable_1.Observable(function (subscriber) {
        var sub = new Subscription_1.Subscription();
        sub.add(scheduler.schedule(function () { return input.then(function (value) {
            sub.add(scheduler.schedule(function () {
                subscriber.next(value);
                sub.add(scheduler.schedule(function () { return subscriber.complete(); }));
            }));
        }, function (err) {
            sub.add(scheduler.schedule(function () { return subscriber.error(err); }));
        }); }));
        return sub;
    });
}
exports.schedulePromise = schedulePromise;
//# sourceMappingURL=schedulePromise.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/scheduled/scheduled.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/internal/scheduled/scheduled.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var scheduleObservable_1 = __webpack_require__(/*! ./scheduleObservable */ "./node_modules/rxjs/internal/scheduled/scheduleObservable.js");
var schedulePromise_1 = __webpack_require__(/*! ./schedulePromise */ "./node_modules/rxjs/internal/scheduled/schedulePromise.js");
var scheduleArray_1 = __webpack_require__(/*! ./scheduleArray */ "./node_modules/rxjs/internal/scheduled/scheduleArray.js");
var scheduleIterable_1 = __webpack_require__(/*! ./scheduleIterable */ "./node_modules/rxjs/internal/scheduled/scheduleIterable.js");
var isInteropObservable_1 = __webpack_require__(/*! ../util/isInteropObservable */ "./node_modules/rxjs/internal/util/isInteropObservable.js");
var isPromise_1 = __webpack_require__(/*! ../util/isPromise */ "./node_modules/rxjs/internal/util/isPromise.js");
var isArrayLike_1 = __webpack_require__(/*! ../util/isArrayLike */ "./node_modules/rxjs/internal/util/isArrayLike.js");
var isIterable_1 = __webpack_require__(/*! ../util/isIterable */ "./node_modules/rxjs/internal/util/isIterable.js");
function scheduled(input, scheduler) {
    if (input != null) {
        if (isInteropObservable_1.isInteropObservable(input)) {
            return scheduleObservable_1.scheduleObservable(input, scheduler);
        }
        else if (isPromise_1.isPromise(input)) {
            return schedulePromise_1.schedulePromise(input, scheduler);
        }
        else if (isArrayLike_1.isArrayLike(input)) {
            return scheduleArray_1.scheduleArray(input, scheduler);
        }
        else if (isIterable_1.isIterable(input) || typeof input === 'string') {
            return scheduleIterable_1.scheduleIterable(input, scheduler);
        }
    }
    throw new TypeError((input !== null && typeof input || input) + ' is not observable');
}
exports.scheduled = scheduled;
//# sourceMappingURL=scheduled.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/scheduler/Action.js":
/*!********************************************************!*\
  !*** ./node_modules/rxjs/internal/scheduler/Action.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscription_1 = __webpack_require__(/*! ../Subscription */ "./node_modules/rxjs/internal/Subscription.js");
var Action = (function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        return _super.call(this) || this;
    }
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        return this;
    };
    return Action;
}(Subscription_1.Subscription));
exports.Action = Action;
//# sourceMappingURL=Action.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/scheduler/AnimationFrameAction.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rxjs/internal/scheduler/AnimationFrameAction.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncAction_1 = __webpack_require__(/*! ./AsyncAction */ "./node_modules/rxjs/internal/scheduler/AsyncAction.js");
var AnimationFrameAction = (function (_super) {
    __extends(AnimationFrameAction, _super);
    function AnimationFrameAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () { return scheduler.flush(null); }));
    };
    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            cancelAnimationFrame(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AnimationFrameAction;
}(AsyncAction_1.AsyncAction));
exports.AnimationFrameAction = AnimationFrameAction;
//# sourceMappingURL=AnimationFrameAction.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/scheduler/AnimationFrameScheduler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/rxjs/internal/scheduler/AnimationFrameScheduler.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncScheduler_1 = __webpack_require__(/*! ./AsyncScheduler */ "./node_modules/rxjs/internal/scheduler/AsyncScheduler.js");
var AnimationFrameScheduler = (function (_super) {
    __extends(AnimationFrameScheduler, _super);
    function AnimationFrameScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AnimationFrameScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.AnimationFrameScheduler = AnimationFrameScheduler;
//# sourceMappingURL=AnimationFrameScheduler.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/scheduler/AsyncAction.js":
/*!*************************************************************!*\
  !*** ./node_modules/rxjs/internal/scheduler/AsyncAction.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Action_1 = __webpack_require__(/*! ./Action */ "./node_modules/rxjs/internal/scheduler/Action.js");
var AsyncAction = (function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (this.closed) {
            return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        return setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        clearInterval(id);
        return undefined;
    };
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(Action_1.Action));
exports.AsyncAction = AsyncAction;
//# sourceMappingURL=AsyncAction.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/scheduler/AsyncScheduler.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/internal/scheduler/AsyncScheduler.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Scheduler_1 = __webpack_require__(/*! ../Scheduler */ "./node_modules/rxjs/internal/Scheduler.js");
var AsyncScheduler = (function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler(SchedulerAction, now) {
        if (now === void 0) { now = Scheduler_1.Scheduler.now; }
        var _this = _super.call(this, SchedulerAction, function () {
            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
                return AsyncScheduler.delegate.now();
            }
            else {
                return now();
            }
        }) || this;
        _this.actions = [];
        _this.active = false;
        _this.scheduled = undefined;
        return _this;
    }
    AsyncScheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) { delay = 0; }
        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
            return AsyncScheduler.delegate.schedule(work, delay, state);
        }
        else {
            return _super.prototype.schedule.call(this, work, delay, state);
        }
    };
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift());
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler_1.Scheduler));
exports.AsyncScheduler = AsyncScheduler;
//# sourceMappingURL=AsyncScheduler.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/scheduler/QueueAction.js":
/*!*************************************************************!*\
  !*** ./node_modules/rxjs/internal/scheduler/QueueAction.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncAction_1 = __webpack_require__(/*! ./AsyncAction */ "./node_modules/rxjs/internal/scheduler/AsyncAction.js");
var QueueAction = (function (_super) {
    __extends(QueueAction, _super);
    function QueueAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return (delay > 0 || this.closed) ?
            _super.prototype.execute.call(this, state, delay) :
            this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        return scheduler.flush(this);
    };
    return QueueAction;
}(AsyncAction_1.AsyncAction));
exports.QueueAction = QueueAction;
//# sourceMappingURL=QueueAction.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/scheduler/QueueScheduler.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/internal/scheduler/QueueScheduler.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncScheduler_1 = __webpack_require__(/*! ./AsyncScheduler */ "./node_modules/rxjs/internal/scheduler/AsyncScheduler.js");
var QueueScheduler = (function (_super) {
    __extends(QueueScheduler, _super);
    function QueueScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.QueueScheduler = QueueScheduler;
//# sourceMappingURL=QueueScheduler.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/scheduler/animationFrame.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/internal/scheduler/animationFrame.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var AnimationFrameAction_1 = __webpack_require__(/*! ./AnimationFrameAction */ "./node_modules/rxjs/internal/scheduler/AnimationFrameAction.js");
var AnimationFrameScheduler_1 = __webpack_require__(/*! ./AnimationFrameScheduler */ "./node_modules/rxjs/internal/scheduler/AnimationFrameScheduler.js");
exports.animationFrame = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
//# sourceMappingURL=animationFrame.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/scheduler/async.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/internal/scheduler/async.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var AsyncAction_1 = __webpack_require__(/*! ./AsyncAction */ "./node_modules/rxjs/internal/scheduler/AsyncAction.js");
var AsyncScheduler_1 = __webpack_require__(/*! ./AsyncScheduler */ "./node_modules/rxjs/internal/scheduler/AsyncScheduler.js");
exports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
//# sourceMappingURL=async.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/scheduler/queue.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/internal/scheduler/queue.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var QueueAction_1 = __webpack_require__(/*! ./QueueAction */ "./node_modules/rxjs/internal/scheduler/QueueAction.js");
var QueueScheduler_1 = __webpack_require__(/*! ./QueueScheduler */ "./node_modules/rxjs/internal/scheduler/QueueScheduler.js");
exports.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
//# sourceMappingURL=queue.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/symbol/iterator.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/internal/symbol/iterator.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function getSymbolIterator() {
    if (typeof Symbol !== 'function' || !Symbol.iterator) {
        return '@@iterator';
    }
    return Symbol.iterator;
}
exports.getSymbolIterator = getSymbolIterator;
exports.iterator = getSymbolIterator();
exports.$$iterator = exports.iterator;
//# sourceMappingURL=iterator.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/symbol/observable.js":
/*!*********************************************************!*\
  !*** ./node_modules/rxjs/internal/symbol/observable.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.observable = (function () { return typeof Symbol === 'function' && Symbol.observable || '@@observable'; })();
//# sourceMappingURL=observable.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/symbol/rxSubscriber.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/internal/symbol/rxSubscriber.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.rxSubscriber = (function () {
    return typeof Symbol === 'function'
        ? Symbol('rxSubscriber')
        : '@@rxSubscriber_' + Math.random();
})();
exports.$$rxSubscriber = exports.rxSubscriber;
//# sourceMappingURL=rxSubscriber.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/ArgumentOutOfRangeError.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/internal/util/ArgumentOutOfRangeError.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ArgumentOutOfRangeErrorImpl = (function () {
    function ArgumentOutOfRangeErrorImpl() {
        Error.call(this);
        this.message = 'argument out of range';
        this.name = 'ArgumentOutOfRangeError';
        return this;
    }
    ArgumentOutOfRangeErrorImpl.prototype = Object.create(Error.prototype);
    return ArgumentOutOfRangeErrorImpl;
})();
exports.ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
//# sourceMappingURL=ArgumentOutOfRangeError.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/EmptyError.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/internal/util/EmptyError.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var EmptyErrorImpl = (function () {
    function EmptyErrorImpl() {
        Error.call(this);
        this.message = 'no elements in sequence';
        this.name = 'EmptyError';
        return this;
    }
    EmptyErrorImpl.prototype = Object.create(Error.prototype);
    return EmptyErrorImpl;
})();
exports.EmptyError = EmptyErrorImpl;
//# sourceMappingURL=EmptyError.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/ObjectUnsubscribedError.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/internal/util/ObjectUnsubscribedError.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ObjectUnsubscribedErrorImpl = (function () {
    function ObjectUnsubscribedErrorImpl() {
        Error.call(this);
        this.message = 'object unsubscribed';
        this.name = 'ObjectUnsubscribedError';
        return this;
    }
    ObjectUnsubscribedErrorImpl.prototype = Object.create(Error.prototype);
    return ObjectUnsubscribedErrorImpl;
})();
exports.ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
//# sourceMappingURL=ObjectUnsubscribedError.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/UnsubscriptionError.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/internal/util/UnsubscriptionError.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var UnsubscriptionErrorImpl = (function () {
    function UnsubscriptionErrorImpl(errors) {
        Error.call(this);
        this.message = errors ?
            errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
        this.name = 'UnsubscriptionError';
        this.errors = errors;
        return this;
    }
    UnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);
    return UnsubscriptionErrorImpl;
})();
exports.UnsubscriptionError = UnsubscriptionErrorImpl;
//# sourceMappingURL=UnsubscriptionError.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/canReportError.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/internal/util/canReportError.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
function canReportError(observer) {
    while (observer) {
        var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
        if (closed_1 || isStopped) {
            return false;
        }
        else if (destination && destination instanceof Subscriber_1.Subscriber) {
            observer = destination;
        }
        else {
            observer = null;
        }
    }
    return true;
}
exports.canReportError = canReportError;
//# sourceMappingURL=canReportError.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/hostReportError.js":
/*!************************************************************!*\
  !*** ./node_modules/rxjs/internal/util/hostReportError.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function hostReportError(err) {
    setTimeout(function () { throw err; }, 0);
}
exports.hostReportError = hostReportError;
//# sourceMappingURL=hostReportError.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/identity.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/internal/util/identity.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function identity(x) {
    return x;
}
exports.identity = identity;
//# sourceMappingURL=identity.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/isArray.js":
/*!****************************************************!*\
  !*** ./node_modules/rxjs/internal/util/isArray.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.isArray = (function () { return Array.isArray || (function (x) { return x && typeof x.length === 'number'; }); })();
//# sourceMappingURL=isArray.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/isArrayLike.js":
/*!********************************************************!*\
  !*** ./node_modules/rxjs/internal/util/isArrayLike.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });
//# sourceMappingURL=isArrayLike.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/isDate.js":
/*!***************************************************!*\
  !*** ./node_modules/rxjs/internal/util/isDate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isDate(value) {
    return value instanceof Date && !isNaN(+value);
}
exports.isDate = isDate;
//# sourceMappingURL=isDate.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/isFunction.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/internal/util/isFunction.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isFunction(x) {
    return typeof x === 'function';
}
exports.isFunction = isFunction;
//# sourceMappingURL=isFunction.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/isInteropObservable.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/internal/util/isInteropObservable.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var observable_1 = __webpack_require__(/*! ../symbol/observable */ "./node_modules/rxjs/internal/symbol/observable.js");
function isInteropObservable(input) {
    return input && typeof input[observable_1.observable] === 'function';
}
exports.isInteropObservable = isInteropObservable;
//# sourceMappingURL=isInteropObservable.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/isIterable.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/internal/util/isIterable.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var iterator_1 = __webpack_require__(/*! ../symbol/iterator */ "./node_modules/rxjs/internal/symbol/iterator.js");
function isIterable(input) {
    return input && typeof input[iterator_1.iterator] === 'function';
}
exports.isIterable = isIterable;
//# sourceMappingURL=isIterable.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/isNumeric.js":
/*!******************************************************!*\
  !*** ./node_modules/rxjs/internal/util/isNumeric.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var isArray_1 = __webpack_require__(/*! ./isArray */ "./node_modules/rxjs/internal/util/isArray.js");
function isNumeric(val) {
    return !isArray_1.isArray(val) && (val - parseFloat(val) + 1) >= 0;
}
exports.isNumeric = isNumeric;
//# sourceMappingURL=isNumeric.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/isObject.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/internal/util/isObject.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isObject(x) {
    return x !== null && typeof x === 'object';
}
exports.isObject = isObject;
//# sourceMappingURL=isObject.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/isPromise.js":
/*!******************************************************!*\
  !*** ./node_modules/rxjs/internal/util/isPromise.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isPromise(value) {
    return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
exports.isPromise = isPromise;
//# sourceMappingURL=isPromise.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/isScheduler.js":
/*!********************************************************!*\
  !*** ./node_modules/rxjs/internal/util/isScheduler.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}
exports.isScheduler = isScheduler;
//# sourceMappingURL=isScheduler.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/noop.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/internal/util/noop.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function noop() { }
exports.noop = noop;
//# sourceMappingURL=noop.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/pipe.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/internal/util/pipe.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var noop_1 = __webpack_require__(/*! ./noop */ "./node_modules/rxjs/internal/util/noop.js");
function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
}
exports.pipe = pipe;
function pipeFromArray(fns) {
    if (!fns) {
        return noop_1.noop;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}
exports.pipeFromArray = pipeFromArray;
//# sourceMappingURL=pipe.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/subscribeTo.js":
/*!********************************************************!*\
  !*** ./node_modules/rxjs/internal/util/subscribeTo.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var subscribeToArray_1 = __webpack_require__(/*! ./subscribeToArray */ "./node_modules/rxjs/internal/util/subscribeToArray.js");
var subscribeToPromise_1 = __webpack_require__(/*! ./subscribeToPromise */ "./node_modules/rxjs/internal/util/subscribeToPromise.js");
var subscribeToIterable_1 = __webpack_require__(/*! ./subscribeToIterable */ "./node_modules/rxjs/internal/util/subscribeToIterable.js");
var subscribeToObservable_1 = __webpack_require__(/*! ./subscribeToObservable */ "./node_modules/rxjs/internal/util/subscribeToObservable.js");
var isArrayLike_1 = __webpack_require__(/*! ./isArrayLike */ "./node_modules/rxjs/internal/util/isArrayLike.js");
var isPromise_1 = __webpack_require__(/*! ./isPromise */ "./node_modules/rxjs/internal/util/isPromise.js");
var isObject_1 = __webpack_require__(/*! ./isObject */ "./node_modules/rxjs/internal/util/isObject.js");
var iterator_1 = __webpack_require__(/*! ../symbol/iterator */ "./node_modules/rxjs/internal/symbol/iterator.js");
var observable_1 = __webpack_require__(/*! ../symbol/observable */ "./node_modules/rxjs/internal/symbol/observable.js");
exports.subscribeTo = function (result) {
    if (!!result && typeof result[observable_1.observable] === 'function') {
        return subscribeToObservable_1.subscribeToObservable(result);
    }
    else if (isArrayLike_1.isArrayLike(result)) {
        return subscribeToArray_1.subscribeToArray(result);
    }
    else if (isPromise_1.isPromise(result)) {
        return subscribeToPromise_1.subscribeToPromise(result);
    }
    else if (!!result && typeof result[iterator_1.iterator] === 'function') {
        return subscribeToIterable_1.subscribeToIterable(result);
    }
    else {
        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected."
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        throw new TypeError(msg);
    }
};
//# sourceMappingURL=subscribeTo.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/subscribeToArray.js":
/*!*************************************************************!*\
  !*** ./node_modules/rxjs/internal/util/subscribeToArray.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.subscribeToArray = function (array) { return function (subscriber) {
    for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
        subscriber.next(array[i]);
    }
    subscriber.complete();
}; };
//# sourceMappingURL=subscribeToArray.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/subscribeToIterable.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/internal/util/subscribeToIterable.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var iterator_1 = __webpack_require__(/*! ../symbol/iterator */ "./node_modules/rxjs/internal/symbol/iterator.js");
exports.subscribeToIterable = function (iterable) { return function (subscriber) {
    var iterator = iterable[iterator_1.iterator]();
    do {
        var item = iterator.next();
        if (item.done) {
            subscriber.complete();
            break;
        }
        subscriber.next(item.value);
        if (subscriber.closed) {
            break;
        }
    } while (true);
    if (typeof iterator.return === 'function') {
        subscriber.add(function () {
            if (iterator.return) {
                iterator.return();
            }
        });
    }
    return subscriber;
}; };
//# sourceMappingURL=subscribeToIterable.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/subscribeToObservable.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/internal/util/subscribeToObservable.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var observable_1 = __webpack_require__(/*! ../symbol/observable */ "./node_modules/rxjs/internal/symbol/observable.js");
exports.subscribeToObservable = function (obj) { return function (subscriber) {
    var obs = obj[observable_1.observable]();
    if (typeof obs.subscribe !== 'function') {
        throw new TypeError('Provided object does not correctly implement Symbol.observable');
    }
    else {
        return obs.subscribe(subscriber);
    }
}; };
//# sourceMappingURL=subscribeToObservable.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/subscribeToPromise.js":
/*!***************************************************************!*\
  !*** ./node_modules/rxjs/internal/util/subscribeToPromise.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var hostReportError_1 = __webpack_require__(/*! ./hostReportError */ "./node_modules/rxjs/internal/util/hostReportError.js");
exports.subscribeToPromise = function (promise) { return function (subscriber) {
    promise.then(function (value) {
        if (!subscriber.closed) {
            subscriber.next(value);
            subscriber.complete();
        }
    }, function (err) { return subscriber.error(err); })
        .then(null, hostReportError_1.hostReportError);
    return subscriber;
}; };
//# sourceMappingURL=subscribeToPromise.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/subscribeToResult.js":
/*!**************************************************************!*\
  !*** ./node_modules/rxjs/internal/util/subscribeToResult.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var InnerSubscriber_1 = __webpack_require__(/*! ../InnerSubscriber */ "./node_modules/rxjs/internal/InnerSubscriber.js");
var subscribeTo_1 = __webpack_require__(/*! ./subscribeTo */ "./node_modules/rxjs/internal/util/subscribeTo.js");
var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/internal/Observable.js");
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, destination) {
    if (destination === void 0) { destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex); }
    if (destination.closed) {
        return undefined;
    }
    if (result instanceof Observable_1.Observable) {
        return result.subscribe(destination);
    }
    return subscribeTo_1.subscribeTo(result)(destination);
}
exports.subscribeToResult = subscribeToResult;
//# sourceMappingURL=subscribeToResult.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/toSubscriber.js":
/*!*********************************************************!*\
  !*** ./node_modules/rxjs/internal/util/toSubscriber.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
var rxSubscriber_1 = __webpack_require__(/*! ../symbol/rxSubscriber */ "./node_modules/rxjs/internal/symbol/rxSubscriber.js");
var Observer_1 = __webpack_require__(/*! ../Observer */ "./node_modules/rxjs/internal/Observer.js");
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
            return nextOrObserver[rxSubscriber_1.rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer_1.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;
//# sourceMappingURL=toSubscriber.js.map

/***/ }),

/***/ "./node_modules/search-params/dist/cjs/index.js":
/*!******************************************************!*\
  !*** ./node_modules/search-params/dist/cjs/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

var makeOptions = function (opts) {
    if (opts === void 0) { opts = {}; }
    return ({
        arrayFormat: opts.arrayFormat || 'none',
        booleanFormat: opts.booleanFormat || 'none',
        nullFormat: opts.nullFormat || 'default'
    });
};
var encodeValue = function (value) { return encodeURIComponent(value); };
var decodeValue = function (value) { return decodeURIComponent(value); };
var encodeBoolean = function (name, value, opts) {
    if (opts.booleanFormat === 'empty-true' && value) {
        return name;
    }
    var encodedValue;
    if (opts.booleanFormat === 'unicode') {
        encodedValue = value ? '' : '';
    }
    else {
        encodedValue = value.toString();
    }
    return name + "=" + encodedValue;
};
var encodeNull = function (name, opts) {
    if (opts.nullFormat === 'hidden') {
        return '';
    }
    if (opts.nullFormat === 'string') {
        return name + "=null";
    }
    return name;
};
var getNameEncoder = function (opts) {
    if (opts.arrayFormat === 'index') {
        return function (name, index) { return name + "[" + index + "]"; };
    }
    if (opts.arrayFormat === 'brackets') {
        return function (name) { return name + "[]"; };
    }
    return function (name) { return name; };
};
var encodeArray = function (name, arr, opts) {
    var encodeName = getNameEncoder(opts);
    return arr
        .map(function (val, index) { return encodeName(name, index) + "=" + encodeValue(val); })
        .join('&');
};
var encode = function (name, value, opts) {
    if (value === null) {
        return encodeNull(name, opts);
    }
    if (typeof value === 'boolean') {
        return encodeBoolean(name, value, opts);
    }
    if (Array.isArray(value)) {
        return encodeArray(name, value, opts);
    }
    return name + "=" + encodeValue(value);
};
var decode = function (value, opts) {
    if (value === undefined) {
        return opts.booleanFormat === 'empty-true' ? true : null;
    }
    if (opts.booleanFormat === 'string') {
        if (value === 'true') {
            return true;
        }
        if (value === 'false') {
            return false;
        }
    }
    else if (opts.booleanFormat === 'unicode') {
        if (decodeValue(value) === '') {
            return true;
        }
        if (decodeValue(value) === '') {
            return false;
        }
    }
    else if (opts.nullFormat === 'string') {
        if (value === 'null') {
            return null;
        }
    }
    return decodeValue(value);
};

var getSearch = function (path) {
    var pos = path.indexOf('?');
    if (pos === -1) {
        return path;
    }
    return path.slice(pos + 1);
};
var isSerialisable = function (val) { return val !== undefined; };
var parseName = function (name) {
    var bracketPosition = name.indexOf('[');
    var hasBrackets = bracketPosition !== -1;
    return {
        hasBrackets: hasBrackets,
        name: hasBrackets ? name.slice(0, bracketPosition) : name
    };
};

/**
 * Parse a querystring and return an object of parameters
 */
var parse = function (path, opts) {
    var options = makeOptions(opts);
    return getSearch(path)
        .split('&')
        .reduce(function (params, param) {
        var _a = param.split('='), rawName = _a[0], value = _a[1];
        var _b = parseName(rawName), hasBrackets = _b.hasBrackets, name = _b.name;
        var currentValue = params[name];
        var decodedValue = decode(value, options);
        if (currentValue === undefined) {
            params[name] = hasBrackets ? [decodedValue] : decodedValue;
        }
        else {
            params[name] = [].concat(currentValue, decodedValue);
        }
        return params;
    }, {});
};
/**
 * Build a querystring from an object of parameters
 */
var build = function (params, opts) {
    var options = makeOptions(opts);
    return Object.keys(params)
        .filter(function (paramName) { return isSerialisable(params[paramName]); })
        .map(function (paramName) { return encode(paramName, params[paramName], options); })
        .filter(Boolean)
        .join('&');
};
/**
 * Remove a list of parameters from a querystring
 */
var omit = function (path, paramsToOmit, opts) {
    var options = makeOptions(opts);
    var searchPart = getSearch(path);
    if (searchPart === '') {
        return {
            querystring: '',
            removedParams: {}
        };
    }
    var _a = path.split('&').reduce(function (_a, chunk) {
        var left = _a[0], right = _a[1];
        var rawName = chunk.split('=')[0];
        var name = parseName(rawName).name;
        return paramsToOmit.indexOf(name) === -1
            ? [left.concat(chunk), right]
            : [left, right.concat(chunk)];
    }, [[], []]), kept = _a[0], removed = _a[1];
    return {
        querystring: kept.join('&'),
        removedParams: parse(removed.join('&'), options)
    };
};
/**
 * Remove a list of parameters from a querystring
 */
var keep = function (path, paramsToKeep, opts) {
    var options = makeOptions(opts);
    var searchPart = getSearch(path);
    if (searchPart === '') {
        return {
            keptParams: {},
            querystring: ''
        };
    }
    var _a = path.split('&').reduce(function (_a, chunk) {
        var left = _a[0], right = _a[1];
        var rawName = chunk.split('=')[0];
        var name = parseName(rawName).name;
        return paramsToKeep.indexOf(name) >= 0
            ? [left.concat(chunk), right]
            : [left, right.concat(chunk)];
    }, [[], []]), kept = _a[0], removed = _a[1];
    return {
        keptParams: parse(kept.join('&'), options),
        querystring: kept.join('&')
    };
};

exports.parse = parse;
exports.build = build;
exports.omit = omit;
exports.keep = keep;


/***/ }),

/***/ "./node_modules/symbol-observable/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/symbol-observable/lib/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, module) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ponyfill = __webpack_require__(/*! ./ponyfill.js */ "./node_modules/symbol-observable/lib/ponyfill.js");

var _ponyfill2 = _interopRequireDefault(_ponyfill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var root; /* global window */


if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (true) {
  root = module;
} else {}

var result = (0, _ponyfill2['default'])(root);
exports['default'] = result;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/symbol-observable/lib/ponyfill.js":
/*!********************************************************!*\
  !*** ./node_modules/symbol-observable/lib/ponyfill.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports['default'] = symbolObservablePonyfill;
function symbolObservablePonyfill(root) {
	var result;
	var _Symbol = root.Symbol;

	if (typeof _Symbol === 'function') {
		if (_Symbol.observable) {
			result = _Symbol.observable;
		} else {
			result = _Symbol('observable');
			_Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./store/RootStore.ts":
/*!****************************!*\
  !*** ./store/RootStore.ts ***!
  \****************************/
/*! exports provided: RootStore, RootState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RootStore", function() { return RootStore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RootState", function() { return RootState; });
/* harmony import */ var _hypertype_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hypertype/app */ "./node_modules/@hypertype/app/dist/esm/index.js");
/* harmony import */ var _hypertype_app__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_hypertype_app__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _model_root__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/root */ "./model/root.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



let RootStore = class RootStore extends _hypertype_app__WEBPACK_IMPORTED_MODULE_0__["ObservableStore"] {
    constructor(rootStore, root) {
        super(rootStore, 'root');
        this.root = root;
        this.Actions = new _hypertype_app__WEBPACK_IMPORTED_MODULE_0__["ActionsCreator"]();
        this.reducer = {
            reduce: Object(_hypertype_app__WEBPACK_IMPORTED_MODULE_0__["objectReducer"])(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["Fn"].I)
        };
    }
};
RootStore = __decorate([
    Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])(),
    __metadata("design:paramtypes", [_hypertype_app__WEBPACK_IMPORTED_MODULE_0__["RootStore"], _model_root__WEBPACK_IMPORTED_MODULE_2__["Root"]])
], RootStore);

class RootState {
}


/***/ }),

/***/ "./store/selection.store.ts":
/*!**********************************!*\
  !*** ./store/selection.store.ts ***!
  \**********************************/
/*! exports provided: SelectionStore, SelectionState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectionStore", function() { return SelectionStore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectionState", function() { return SelectionState; });
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hypertype/core */ "./node_modules/@hypertype/core/dist/esm/index.js");
/* harmony import */ var _hypertype_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_hypertype_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _hypertype_app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @hypertype/app */ "./node_modules/@hypertype/app/dist/esm/index.js");
/* harmony import */ var _hypertype_app__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_hypertype_app__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _model_root__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/root */ "./model/root.ts");
/* harmony import */ var _RootStore__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RootStore */ "./store/RootStore.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




let SelectionStore = class SelectionStore extends _hypertype_app__WEBPACK_IMPORTED_MODULE_1__["ObservableStore"] {
    constructor(rootStore, root) {
        super(rootStore, 'select');
        this.root = root;
        this.Actions = new SelectionActions(this.root);
        this.reducer = new SelectionReducer(this.root);
    }
};
SelectionStore = __decorate([
    Object(_hypertype_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"])(),
    __metadata("design:paramtypes", [_RootStore__WEBPACK_IMPORTED_MODULE_3__["RootStore"], _model_root__WEBPACK_IMPORTED_MODULE_2__["Root"]])
], SelectionStore);

class SelectionState {
}
var Actions;
(function (Actions) {
    Actions[Actions["right"] = 0] = "right";
    Actions[Actions["left"] = 1] = "left";
    Actions[Actions["prev"] = 2] = "prev";
    Actions[Actions["next"] = 3] = "next";
    Actions[Actions["up"] = 4] = "up";
    Actions[Actions["down"] = 5] = "down";
})(Actions || (Actions = {}));
class SelectionActions extends _hypertype_app__WEBPACK_IMPORTED_MODULE_1__["ActionsCreator"] {
    constructor(root) {
        super();
        this.root = root;
    }
    Path(path) {
        const context = this.root.get(path);
        this.Diff({
            Path: path.join(':'),
            Key: context.Key,
        });
    }
    Prev() {
        this.Custom(Actions.prev);
    }
    Next() {
        this.Custom(Actions.next);
    }
    MoveLeft() {
        this.Custom(Actions.left);
    }
    MoveRight() {
        this.Custom(Actions.right);
    }
    MoveUp() {
        this.Custom(Actions.up);
    }
    MoveDown() {
        this.Custom(Actions.down);
    }
    Custom(type, payload) {
        return this.Action({
            type: Actions[type],
            payload
        });
    }
}
class SelectionReducer {
    constructor(root) {
        this.root = root;
        this.objectReducer = (state, action) => {
            if (!state.Path)
                state.Path = this.root.MainContext.Id;
            const selectedContext = this.root.get(state.Path.split(':'));
            switch (Actions[action.type]) {
                case Actions.left:
                    selectedContext.Actions.Move.Left();
                    return {
                        Path: selectedContext.Path.join(':'),
                        Key: selectedContext.Key,
                    };
                case Actions.right:
                    selectedContext.Actions.Move.Right();
                    return {
                        Path: selectedContext.Path.join(':'),
                        Key: selectedContext.Key,
                    };
                case Actions.up:
                    selectedContext.Actions.Move.Up();
                    return {
                        Path: selectedContext.Path.join(':'),
                        Key: selectedContext.Key,
                    };
                case Actions.down:
                    selectedContext.Actions.Move.Down();
                    return {
                        Path: selectedContext.Path.join(':'),
                        Key: selectedContext.Key,
                    };
                case Actions.prev:
                    if (!selectedContext.Prev)
                        return state;
                    return {
                        Path: selectedContext.Prev.Path.join(':'),
                        Key: selectedContext.Prev.Key,
                    };
                case Actions.next:
                    if (!selectedContext.Next)
                        return state;
                    return {
                        Path: selectedContext.Next.Path.join(':'),
                        Key: selectedContext.Next.Key,
                    };
            }
            return state;
        };
        this.reduce = Object(_hypertype_app__WEBPACK_IMPORTED_MODULE_1__["objectReducer"])(this.objectReducer);
    }
}


/***/ })

/******/ });
//# sourceMappingURL=index.js.map